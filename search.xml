<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何记录技术笔记？？</title>
    <url>/2021/11/20/%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BD%95%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>最好的笔记，是经过大脑反复思考，领悟之后先记到心里，再记到笔记上的。</p>
]]></content>
  </entry>
  <entry>
    <title>【读书笔记】Python 基础教程第3版</title>
    <url>/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Python-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E7%AC%AC3%E7%89%88/</url>
    <content><![CDATA[<p>2018年2月出版</p>
<h1 id="快速上手：基础知识"><a href="#快速上手：基础知识" class="headerlink" title="快速上手：基础知识"></a>快速上手：基础知识</h1><h2 id="数和表达式"><a href="#数和表达式" class="headerlink" title="数和表达式"></a>数和表达式</h2><p>交互式Python解释器可以当计算器来用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">53672</span> + <span class="number">235253</span></span><br><span class="line"><span class="number">288925</span></span><br></pre></td></tr></table></figure>

<p>除法运算的结果为小数，即浮点数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> / <span class="number">2</span></span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<p>执行整除运算，可使用双斜杠 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> // <span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>​    对于整除运算，需要明白的一个 重点是它向下圆整结果,对于-10 // 3， 将向下圆整到-4，而不是向上圆整到-3。</p>
<p><strong>十六进制、八进制和二进制</strong>  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0xAF</span></span><br><span class="line"><span class="number">175</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">010</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0b1011010010</span></span><br><span class="line"><span class="number">722</span></span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>使用Python变量前必须给它赋值，因为Python变量没有默认值</p>
<h2 id="获取用户输入"><a href="#获取用户输入" class="headerlink" title="获取用户输入"></a>获取用户输入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">input</span>(<span class="string">&quot;x: &quot;</span>)</span><br><span class="line">x: <span class="number">34</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="built_in">input</span>(<span class="string">&quot;y: &quot;</span>)</span><br><span class="line">y: <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">int</span>(x) * <span class="built_in">int</span>(y))</span><br><span class="line"><span class="number">1428</span></span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>执行幂运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>使用import导入模块，再以<code>module.function</code>的方式使用模块 中的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.floor(<span class="number">32.9</span>) <span class="comment">#返回小于的最大整数。</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.ceil(<span class="number">32.3</span>) <span class="comment">#返回大于的最小整数。</span></span><br><span class="line"><span class="number">33</span> </span><br></pre></td></tr></table></figure>

<p>如果确定不会从不同模块导入多个同名函数，你可能不想每次调用函数时都指定模块名。在 这种情况下，可使用命令import的如下变种, 可在调用函数时不指定模块前缀</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sqrt(<span class="number">9</span>)</span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>事实上，可使用变量来引用函数（以及其他大部分Python元素）。执行赋值语句foo = math.sqrt后，就可使用foo来计算平方根。例如，foo(4)的结果为2.0。</p>
</blockquote>
<h3 id="cmath和复数"><a href="#cmath和复数" class="headerlink" title="cmath和复数"></a>cmath和复数</h3><p>nan具有特殊含义，指的是“非数值”（not a number）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python标准库提供了一个专门用于处理复数的模块。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cmath</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmath.sqrt(<span class="number">-1</span>)</span><br><span class="line"><span class="number">1j</span></span><br></pre></td></tr></table></figure>

<h2 id="保存并执行程序"><a href="#保存并执行程序" class="headerlink" title="保存并执行程序"></a>保存并执行程序</h2><p>在文本中写好python代码，改后缀为 .py </p>
<p>就可在Windows中使用如下命令来执行这个脚本： <code>C:\&gt;python hello.py</code></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>井号（#）比较特殊：在代码中，井号后面到行尾的所有内容都将被忽略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打印圆的周长：</span><br><span class="line">print(2 * pi * radius)</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>同时支持单引号和双引号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Let&#x27;</span>s go!<span class="string">&#x27;</span></span><br><span class="line"><span class="string">SyntaxError: invalid syntax</span></span><br></pre></td></tr></table></figure>

<p>可使用反斜杠（\）对引号进行转义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Let\&#x27;s go!&#x27;</span></span><br><span class="line"><span class="string">&quot;Let&#x27;s go!&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;\&quot;Hello, world!\&quot; she said&quot;</span></span><br><span class="line"><span class="string">&#x27;&quot;Hello, world!&quot; she said&#x27;</span> </span><br></pre></td></tr></table></figure>

<p> 拼接字符串 : <code>+ </code></p>
<p> 字符串表示 str 和 repr</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hello,\nworld!&quot;</span></span><br><span class="line"><span class="string">&#x27;Hello,\nworld!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&quot;Hello,\nworld!&quot;</span>)</span><br><span class="line">Hello,</span><br><span class="line">world!</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">repr</span>(<span class="string">&quot;Hello,\nworld!&quot;</span>))</span><br><span class="line"><span class="string">&#x27;Hello,\nworld!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">str</span>(<span class="string">&quot;Hello,\nworld!&quot;</span>)) <span class="comment">#使用str能以合理的方式将值转换为用户能够看懂的字符串。</span></span><br><span class="line">Hello,</span><br><span class="line">world!</span><br><span class="line"><span class="comment">#像int一样，str也是一个类，但repr是一个函数</span></span><br></pre></td></tr></table></figure>

<p> 长字符串、原始字符串和字节</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">要表示很长的字符串（跨越多行的字符串），可使用三引号（而不是普通引号）。</span><br><span class="line">print(<span class="string">&#x27;&#x27;&#x27;This is a very long string. It continues here.</span></span><br><span class="line"><span class="string">And it&#x27;s not over yet. &quot;Hello, world!&quot;</span></span><br><span class="line"><span class="string">Still here.&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>常规字符串也可横跨多行。只要在行尾加上反斜杠，反斜杠和换行符将被转义，即被忽 略</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> + <span class="number">2</span> + \</span><br><span class="line"> <span class="number">4</span> + <span class="number">5</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> \</span><br><span class="line"> (<span class="string">&#x27;Hello, world&#x27;</span>)</span><br><span class="line">Hello, world</span><br></pre></td></tr></table></figure>

<p>原始字符串用前缀r表示。</p>
<p><code>print(r&#39;Let\&#39;s go!&#39;) Let\&#39;s go!</code></p>
<p>且未对其进行转义，Python将无法判断字符串是否到此结束。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r&quot;This is illegal\&quot;)</span></span><br><span class="line"><span class="string">SyntaxError: EOL while scanning string literal</span></span><br></pre></td></tr></table></figure>





<h1 id="列表和元组"><a href="#列表和元组" class="headerlink" title="列表和元组"></a>列表和元组</h1><h2 id="容器（container）。"><a href="#容器（container）。" class="headerlink" title="容器（container）。"></a>容器（container）。</h2><p>容器基本上就是可包含其 他对象的对象。两种主要的容器是序列（如列表和元组）和映射（如字典）</p>
<p>在序列中， 每个元素都有编号，而在映射中，每个元素都有名称（也叫键）</p>
<p>有一种既不是序列也不是映射的容器，它就是集合（set），</p>
<h2 id="通用的序列操作"><a href="#通用的序列操作" class="headerlink" title="通用的序列操作"></a>通用的序列操作</h2><p>索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>greeting = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>greeting[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;H&#x27;</span> </span><br></pre></td></tr></table></figure>

<p>-1是最后一个元素的位置。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>greeting[<span class="number">-1</span>]</span><br><span class="line"><span class="string">&#x27;o&#x27;</span> </span><br></pre></td></tr></table></figure>

<p>对于字符串字面量（以及其他的序列字面量），可直接对其执行索引操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Hello&#x27;</span>[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;e&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果函数调用返回一个序列，可直接对其执行索引操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fourth = <span class="built_in">input</span>(<span class="string">&#x27;Year: &#x27;</span>)[<span class="number">3</span>]</span><br><span class="line">Year: <span class="number">2005</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fourth</span><br><span class="line"><span class="string">&#x27;5&#x27;</span> </span><br></pre></td></tr></table></figure>

<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = <span class="string">&#x27;&lt;a href=&quot;http://www.python.org&quot;&gt;Python web site&lt;/a&gt;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag[<span class="number">9</span>:<span class="number">30</span>]</span><br><span class="line"><span class="string">&#x27;http://www.python.org&#x27;</span></span><br></pre></td></tr></table></figure>

<p>你提供两个索引来指定切片的边界，其中第一个索引指定的元素包含在切片内， 但第二个索引指定的元素不包含在切片内。</p>
<p>如果切片结束于序列末尾，可省略第二个索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; numbers[-3:]</span><br><span class="line">[8, 9, 10]</span><br></pre></td></tr></table></figure>
<p>同样，如果切片始于序列开头，可省略第一个索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; numbers[:3]</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>要复制整个序列，可将两个索引都省略。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; numbers[:]</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] </span><br></pre></td></tr></table></figure>

<p>如果要从列表末尾开始数，可使用负数索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; numbers[-3:-1]</span><br><span class="line">[8, 9]</span><br></pre></td></tr></table></figure>

<p>你显式或隐式地指定起点和终点，但通常省略另一个参数，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; numbers[0:10:1]</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">&gt;&gt;&gt; numbers[::4]</span><br><span class="line">[1, 5, 9]</span><br></pre></td></tr></table></figure>

<p>步长可以为负数，即从右向左提取元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; numbers[::-2]</span><br><span class="line">[10, 8, 6, 4, 2] </span><br></pre></td></tr></table></figure>

<h3 id="序列相加"><a href="#序列相加" class="headerlink" title="序列相加"></a>序列相加</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [1, 2, 3] + [4, 5, 6]</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; &#39;Hello,&#39; + &#39;world!&#39;</span><br><span class="line">&#39;Hello, world!&#39;</span><br><span class="line">&gt;&gt;&gt; [1, 2, 3] + &#39;world!&#39;</span><br><span class="line">Traceback (innermost last):</span><br><span class="line"> File &quot;&lt;pyshell&gt;&quot;, line 1, in ?</span><br><span class="line"> [1, 2, 3] + &#39;world!&#39;</span><br><span class="line">TypeError: can only concatenate list (not &quot;string&quot;) to list</span><br></pre></td></tr></table></figure>

<p>一般而言，不能拼接不同类 型的序列。 </p>
<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>将序列与数x相乘时，将重复这个序列x次来创建一个新序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;python&#39; * 5</span><br><span class="line">&#39;pythonpythonpythonpythonpython&#39;</span><br><span class="line">&gt;&gt;&gt; [42] * 10</span><br><span class="line">[42, 42, 42, 42, 42, 42, 42, 42, 42, 42]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在Python中，None表示什么</span><br><span class="line">都没有。因此，要将列表的长度初始化为10，可像下面这样做：</span><br><span class="line">&gt;&gt;&gt; sequence &#x3D; [None] * 10</span><br><span class="line">&gt;&gt;&gt; sequence</span><br><span class="line">[None, None, None, None, None, None, None, None, None, None]</span><br></pre></td></tr></table></figure>

<h3 id="成员资格-in"><a href="#成员资格-in" class="headerlink" title="成员资格  in"></a>成员资格  in</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; numbers &#x3D; [100, 34, 678]</span><br><span class="line">&gt;&gt;&gt; len(numbers)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; max(numbers)</span><br><span class="line">678</span><br><span class="line">&gt;&gt;&gt; min(numbers)</span><br><span class="line">34</span><br><span class="line">&gt;&gt;&gt; max(2, 3)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; min(9, 3, 2, 5)</span><br><span class="line">2 </span><br></pre></td></tr></table></figure>

<h2 id="列表：Python-的主力"><a href="#列表：Python-的主力" class="headerlink" title="列表：Python 的主力"></a>列表：Python 的主力</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; list(&#39;Hello&#39;)</span><br><span class="line">[&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]</span><br></pre></td></tr></table></figure>

<p>删除元素：  del names[2]  </p>
<p>给切片赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; name &#x3D; list(&#39;Perl&#39;)</span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">[&#39;P&#39;, &#39;e&#39;, &#39;r&#39;, &#39;l&#39;]</span><br><span class="line">&gt;&gt;&gt; name[2:] &#x3D; list(&#39;ar&#39;)</span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">[&#39;P&#39;, &#39;e&#39;, &#39;a&#39;, &#39;r&#39;]</span><br></pre></td></tr></table></figure>

<p>可以利用给切片赋值的手段 插入或者删除列表中元素</p>
<h3 id="列表方法"><a href="#列表方法" class="headerlink" title="列表方法"></a>列表方法</h3><ol>
<li>append   方法append用于将一个对象附加到列表末尾。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; lst &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; lst.append(4)</span><br><span class="line">&gt;&gt;&gt; lst</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line"># append也就地修改列表。这意味着它不会返回修改后的新列表，而是直接修改旧列表</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>clear 方法 clear就地清空列表的内容。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; lst &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; lst.clear()</span><br><span class="line">&gt;&gt;&gt; lst</span><br><span class="line">[]</span><br><span class="line"># 这类似于切片赋值语句lst[:] &#x3D; []</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>copy 方法 copy 复制列表。前面说过，常规复制只是将另一个名称关联到列表。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; b &#x3D; a</span><br><span class="line">&gt;&gt;&gt; b[1] &#x3D; 4</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 4, 3]</span><br><span class="line">要让a和b指向不同的列表，就必须将b关联到a的副本。</span><br><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; b &#x3D; a.copy()</span><br><span class="line">&gt;&gt;&gt; b[1] &#x3D; 4</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 2, 3]</span><br><span class="line">这类似于使用a[:]或list(a)，它们也都复制a。</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>count 方法count计算指定的元素在列表中出现了多少次。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [&#39;to&#39;, &#39;be&#39;, &#39;or&#39;, &#39;not&#39;, &#39;to&#39;, &#39;be&#39;].count(&#39;to&#39;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; x &#x3D; [[1, 2], 1, 1, [2, 1, [1, 2]]]</span><br><span class="line">&gt;&gt;&gt; x.count(1)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; x.count([1, 2])</span><br><span class="line">1 </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM总结-导出自思维导图</title>
    <url>/2020/11/19/1-JVM/JVM%E6%80%BB%E7%BB%93-%E5%AF%BC%E5%87%BA%E8%87%AA%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p><img src="/2020/11/19/1-JVM/JVM%E6%80%BB%E7%BB%93-%E5%AF%BC%E5%87%BA%E8%87%AA%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/JVM.png"></p>
<h2 id="Java对象区域与Java对象创建方法"><a href="#Java对象区域与Java对象创建方法" class="headerlink" title="Java对象区域与Java对象创建方法"></a>Java对象区域与Java对象创建方法</h2><h3 id="Java对象区域"><a href="#Java对象区域" class="headerlink" title="Java对象区域"></a>Java对象区域</h3><ul>
<li><p>Java堆 | 方法区</p>
</li>
<li><p>程序计数器</p>
</li>
<li><p>虚拟机栈</p>
<p>为虚拟机执行Java方法（即字节码）服务</p>
<ul>
<li><p>局部变量表</p>
<p>基本数据类型 (boolen、byte、char、short、int、 float、 long、double）<br>对象引用（reference类型，它不等于对象本身，可能是一个指向对象起始地址的指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）<br>returnAddress类型（指向了一条字节码指令的地址）</p>
</li>
</ul>
</li>
<li><p>本地方法栈</p>
<p>为虚拟机使用到的Native方法服务</p>
</li>
<li><p>运行时常量池</p>
</li>
<li><p>直接内存</p>
<p>NIO引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作</p>
</li>
</ul>
<h3 id="Java对象创建方法"><a href="#Java对象创建方法" class="headerlink" title="Java对象创建方法"></a>Java对象创建方法</h3><ul>
<li><strong>new关键字</strong> 这应该是我们最常见和最常用最简单的创建对象的方式。</li>
<li><strong>使用<code>newInstance()</code>方法</strong> 这里包括Class类的<code>newInstance()</code>方法和Constructor类的<code>newInstance()</code>方法（前者其实也是调用的后者）。</li>
<li><strong>使用<code>clone()</code>方法</strong> 要使用<code>clone()</code>方法我们必须实现实现Cloneable接口，用<code>clone()</code>方法创建对象并不会调用任何构造函数。即我们所说的浅拷贝。</li>
<li><strong>反序列化</strong> 要实现反序列化我们需要让我们的类实现<strong>Serializable接口</strong>。当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象，在反序列化时，JVM创建对象并不会调用任何构造函数。即我们所说的深拷贝。</li>
</ul>
<h2 id="对象存活判定算法"><a href="#对象存活判定算法" class="headerlink" title="对象存活判定算法"></a>对象存活判定算法</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul>
<li><p>可作为GC Roots的对象</p>
<p><strong>虚拟机栈</strong>（栈帧中的局部变量表，Local Variable Table）中引用的对象。<br>方法区中类静态属性引用的对象。<br>方法区中常量引用的对象。<br>本地方法栈中JNI（即一般说的Native方法）引用的对象。</p>
</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h3><h2 id="对象分配策略"><a href="#对象分配策略" class="headerlink" title="对象分配策略"></a>对象分配策略</h2><h3 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h3><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁</p>
<ul>
<li>参数-XX:MaxTenuringThreshold设置</li>
</ul>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><h2 id="FullGC触发条件"><a href="#FullGC触发条件" class="headerlink" title="FullGC触发条件"></a>FullGC触发条件</h2><h3 id="调用System-gc"><a href="#调用System-gc" class="headerlink" title="调用System.gc()"></a>调用System.gc()</h3><h3 id="老年代空间不足"><a href="#老年代空间不足" class="headerlink" title="老年代空间不足"></a>老年代空间不足</h3><h3 id="空间分配担保失败"><a href="#空间分配担保失败" class="headerlink" title="空间分配担保失败"></a>空间分配担保失败</h3><h3 id="JDK-1-7及以前的永久代空间不足"><a href="#JDK-1-7及以前的永久代空间不足" class="headerlink" title="JDK 1.7及以前的永久代空间不足"></a>JDK 1.7及以前的永久代空间不足</h3><p>​    永久代中存放的为一些class的信息、常量、静态变量等数据</p>
<h3 id="Concurrent-Mode-Failure"><a href="#Concurrent-Mode-Failure" class="headerlink" title="Concurrent Mode Failure"></a>Concurrent Mode Failure</h3><p>​    执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul>
<li><p>启动类加载器（Bootstrap ClassLoader）</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）</p>
</li>
<li><p>优点</p>
<p>虚拟机只有在两个类的类名相同且加载该类的加载器均相同的情况下才判定这是一个类。若不采用双亲委派机制，同一个类有可能被多个类加载器加载，这样该类会被识别为两个不同的类，相互赋值时会有问题。</p>
<p>双亲委派机制能保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同。</p>
</li>
</ul>
<h3 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h3><p>getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。</p>
<ul>
<li><p>SPI</p>
<p>SPI 的接口是Java 核心库的一部分，是由引导类加载器加载的，而SPI 实现的 Java 类一般是由系统类加载器加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。</p>
<ul>
<li>父类加载器请求子类加载器去完成类加载器的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器.</li>
</ul>
</li>
</ul>
<h2 id="7种垃圾回收器"><a href="#7种垃圾回收器" class="headerlink" title="7种垃圾回收器"></a>7种垃圾回收器</h2><h3 id="新生代-复制算法"><a href="#新生代-复制算法" class="headerlink" title="新生代 (复制算法)"></a>新生代 (复制算法)</h3><ul>
<li><p>Serial</p>
</li>
<li><p>ParNew</p>
</li>
<li><p>Parallel Scavenge</p>
<ul>
<li>吞吐量优先</li>
</ul>
</li>
</ul>
<h3 id="老年代-标记-整理"><a href="#老年代-标记-整理" class="headerlink" title="老年代 (标记-整理)"></a>老年代 (标记-整理)</h3><ul>
<li><p>Serial Old</p>
</li>
<li><p>Parallel Old</p>
<ul>
<li>吞吐量优先</li>
</ul>
</li>
<li><p>CMS (并发收集、低停顿)</p>
<ul>
<li><p>cpu资源敏感</p>
</li>
<li><p>浮动垃圾</p>
<p>+CMSScanvengeBeforeRemark：在执行remark操作之前先做一次Young GC<br>+CMSFullGCBeforeCompaction：对内存做压缩</p>
</li>
<li><p>空间碎片</p>
</li>
</ul>
</li>
</ul>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><ul>
<li>横跨整个堆内存，独立区域（Region）</li>
<li>建立可预测的时间模型</li>
<li>避免全堆扫描——每个Region维护了一个与之对应的Remembered Set</li>
</ul>
<h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。<br>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。</p>
<h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><p>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。具体原理见上一篇文章。<br>老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<h2 id="如何进行GC优化"><a href="#如何进行GC优化" class="headerlink" title="如何进行GC优化"></a>如何进行GC优化</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzY1OTU1NQ==&amp;mid=2247484236&amp;idx=1&amp;sn=b9743b2d7436f84e4617ff34e07abdd8&amp;chksm=96cd4300a1baca1635a137294bc93c518c033ce01f843c9e012a1454b9f3ea3158fa1412e9da&amp;scene=27&amp;ascene=0&amp;devicetype=android-24&amp;version=26060638&amp;nettype=WIFI&amp;abtest_cookie=BAABAAoACwASABMABAAjlx4AUJkeAFmZHgBomR4AAAA=&amp;lang=zh_CN&amp;pass_ticket=/+Lqr9N2EZtrEGLFo9vLA6Eqs89DSJ2CBKoAJFZ+BngphEP28dwmMQeSZcUB77qZ&amp;wx_header=1">https://mp.weixin.qq.com/s?__biz=MzIwMzY1OTU1NQ==&amp;mid=2247484236&amp;idx=1&amp;sn=b9743b2d7436f84e4617ff34e07abdd8&amp;chksm=96cd4300a1baca1635a137294bc93c518c033ce01f843c9e012a1454b9f3ea3158fa1412e9da&amp;scene=27&amp;ascene=0&amp;devicetype=android-24&amp;version=26060638&amp;nettype=WIFI&amp;abtest_cookie=BAABAAoACwASABMABAAjlx4AUJkeAFmZHgBomR4AAAA%3D&amp;lang=zh_CN&amp;pass_ticket=%2F%2BLqr9N2EZtrEGLFo9vLA6Eqs89DSJ2CBKoAJFZ%2BBngphEP28dwmMQeSZcUB77qZ&amp;wx_header=1</a></p>
<h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li><p>为类变量分配内存</p>
<p>在方法区中分配，仅包括类变量（被static修饰的变量），而不包括实例变量</p>
</li>
<li><p>设置类变量初始值</p>
</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<ul>
<li><p>7类符号引用</p>
<p>类或接口<br>字段<br>类方法（静态方法）<br>接口方法<br>方法类型<br>方法句柄<br>调用点限定符</p>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>虚拟机执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p><em>XMind - Trial Version</em></p>
]]></content>
      <categories>
        <category>Java面试准备</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>为毛不能自定义一个 Java.long.String/Math 类？</title>
    <url>/2020/11/19/1-JVM/%E4%B8%BA%E6%AF%9B%E4%B8%8D%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-Java-long-String-Math-%E7%B1%BB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="为什么不能自定义java-lang-String-Math"><a href="#为什么不能自定义java-lang-String-Math" class="headerlink" title="为什么不能自定义java.lang.String/Math"></a>为什么不能自定义java.lang.String/Math</h1><p>如果直接写一个java.lang.String类，并写一个main方法，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package java.lang;</span><br><span class="line"> public class String &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     System.out.println(&quot;Hello String&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>运行之后会抛一个异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误: 在类 java.lang.String 中找不到主方法, 请将主方法定义为:</span><br><span class="line">   public static void main(String[] args)</span><br></pre></td></tr></table></figure>



<p>这是什么原因呢？</p>
<p>答案先给出：</p>
<p>Java类加载机制为代理模式，先交给其父加载器去加载，如果父加载器加载不了，则由自己加载。我们自定义的类是由系统类加载器进行加载，而它的父加载器为扩展类加载器。我们定义的java.lang.String最先由扩展类加载器加载，它负责加载Java核心库，但java.lang.String正是系统中的类，已经被扩展类加载器记载过了，所以不再加载自定义的java.lang.String。但是系统的java.lang.String没有main方法，所以出现了上面的这个异常。</p>
<p>另外，自定义包不能以java.xxx.xxx开头，这是一种安全机制，如果以java开头，系统直接抛异常。</p>
<p>再来看以下两段代码：</p>
<p>片段1：</p>
<p><img src="/2020/11/19/1-JVM/%E4%B8%BA%E6%AF%9B%E4%B8%8D%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-Java-long-String-Math-%E7%B1%BB%EF%BC%9F/1.jpg" alt="img"></p>
<p>片段1执行结果：</p>
<p><img src="/2020/11/19/1-JVM/%E4%B8%BA%E6%AF%9B%E4%B8%8D%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-Java-long-String-Math-%E7%B1%BB%EF%BC%9F/2.jpg" alt="img"></p>
<p>对于代码片段1，虽然能加载自定义的com.test.String类，但是main方法中的String对象也是自定义的，不符合main方法的定义方式，故系统抛找不到mian方法。</p>
<p>片段2：</p>
<p><img src="/2020/11/19/1-JVM/%E4%B8%BA%E6%AF%9B%E4%B8%8D%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-Java-long-String-Math-%E7%B1%BB%EF%BC%9F/3.jpg" alt="img"></p>
<p>对于代码片段2，在main方法的定义中把String类的路径写全了，明确了，故能正常执行。</p>
<p><strong>原因</strong></p>
<p>这里必须要提到java加载类的过程。</p>
<p>Java在加载类时，采用的是代理模式，即，类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，以此类推。在说明代理模式背后的原因之前，首先需要说明一下Java虚拟机是如何判定两个java类是相同的。Java虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同，才认为两个类时相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的，如果此时试图对这两个类的对象进行相互赋值，会抛出运行时异常ClassCastException。</p>
<p>了解到这一点，就可以理解代理模式的设计动机了。代理模式是为了保证Java核心库的类型安全，所有的Java应用都至少需要引用java.lang.Object类，也就是说在运行时，java.lang.Object这个类需要被加载到Java虚拟机中。如果这个过程由Java应用自己的类加载器来完成的话，很可能就存在多个版本的java.lang.Object类，可是这些类之间是不兼容的。通过代理模式，对于Java核心库的类的加载工作由引导类加载器统一完成，保证了Java应用所使用的都是同一个版本的Java核心库的类，是相互兼容的。</p>
<h1 id="在源码层面解读这个问题"><a href="#在源码层面解读这个问题" class="headerlink" title="在源码层面解读这个问题"></a>在源码层面解读这个问题</h1><h2 id="需求缘起"><a href="#需求缘起" class="headerlink" title="需求缘起"></a>需求缘起</h2><p>最近学习了下java类加载相关的知识。看到网上经常会有一道这样的有一道面试题是，能不能自己写个类叫java.lang.System？</p>
<p>网上提供的答案：通常不可以，但可以采取另类方法达到这个需求。所谓的另类方法指自己写个类加载器来加载java.lang.System达到目的。</p>
<p>首先表明下我的观点。上述答案完全是误导读者，是不正确的答案。我就纳闷了网上怎么把这种完全不正确的搜索结果排在前面，而且几乎搜到的都是这种不正确的答案。可能很多不明真相的朋友就这么被误导了，所以还是希望大家对网上的内容先持怀疑态度为好。下面详细说明为什么</p>
<h2 id="网上错误答案的详细解释"><a href="#网上错误答案的详细解释" class="headerlink" title="网上错误答案的详细解释"></a><strong>网上错误答案的详细解释</strong></h2><p>“为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，爸爸们能找 到的类，儿子就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，自己写的 System类根本没有机会得到加载。</p>
<p>但是，我们可以自己定义一个类加载器来达到这个目的，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。</p>
<h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><p>类加载器可分为两类：一是启动类加载器(Bootstrap ClassLoader)，是C++实现的，是JVM的一部分；另一种是其它的类加载器，是Java实现的，独立于JVM，全部都继承自抽象类 java.lang.ClassLoader。jdk自带了三种类加载器，分别是启动类加载器（Bootstrap ClassLoader），扩展类加载器（Extension ClassLoader），应用程序类加载器（Application ClassLoader）。后两种加载器是继承自抽象类java.lang.ClassLoader。关于这三种加载器各自的作用这里不做详细说明，有兴 趣的可以自己了解下。</p>
<p>类加载器是有层次的</p>
<p>一般是： 自定义类加载器 &gt;&gt; 应用程序类加载器 &gt;&gt; 扩展类加载器 &gt;&gt; 启动类加载器</p>
<p>上面的层次关系被称为双亲委派模型(Parents Delegation Model)。除了最顶层的启动类加载器外，其余的类加载器都有对应的父类加载器。</p>
<p>再简单说下双亲委托机制：如果一个类加载器收到了类加载的请求，它首先不会自己尝试去加载这 个类，而是把这个请求委派给父类加载器，每一个层次的类加载器都是加此，因此所有的加载请求最终到达顶层的启动类加载器，只有当父类加载器反馈自己无法完 成加载请求时（指它的搜索范围没有找到所需的类），子类加载器才会尝试自己去加载。</p>
<p>再回去看下解释内容，我相信前面的部分大家应该很看懂了，也没什么大问题。最后的如果部分” 如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。” 我就不明白所以了，逻辑完全不通。我想它的本意可能是，将自己的java.lang.System类放置在特殊目录，然后系统自带的加载器无法加载，这样 最终还是由我们自己的加载器加载（因为我们自己的加载器知道其所在的特殊目录）。这种说法好像逻辑上没有问题，那么我们就来实验下了。</p>
<h2 id="自己验证"><a href="#自己验证" class="headerlink" title="自己验证"></a>自己验证</h2><p><img src="/2020/11/19/1-JVM/%E4%B8%BA%E6%AF%9B%E4%B8%8D%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-Java-long-String-Math-%E7%B1%BB%EF%BC%9F/20180124155246940" alt="img"></p>
<p>主要包括4个类：</p>
<h3 id="MyClassLoader"><a href="#MyClassLoader" class="headerlink" title="MyClassLoader:"></a>MyClassLoader:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyq.maventest.classloader;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: package-info</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 自定义类加载器</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> youqiang.xiong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2018年1月24日下午3:16:11</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line">publicclass MyClassLoader extends ClassLoader&#123;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">super</span>(<span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"> </span><br><span class="line">String className = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(name.startsWith(<span class="string">&quot;java.lang&quot;</span>))&#123;</span><br><span class="line"> </span><br><span class="line">className = <span class="string">&quot;/&quot;</span> + name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"> </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> </span><br><span class="line">className = name.substring(name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.out.println(className);</span><br><span class="line"> </span><br><span class="line">InputStream is = getClass().getResourceAsStream(className);</span><br><span class="line"> </span><br><span class="line">System.out.println(is);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(is == <span class="keyword">null</span>)</span><br><span class="line"> </span><br><span class="line">returnsuper.loadClass(name);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">byte</span>[] b = newbyte[is.available()];</span><br><span class="line"> </span><br><span class="line">is.read(b);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line"> </span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> </span><br><span class="line">e.printStackTrace();</span><br><span class="line"> </span><br><span class="line"><span class="function">thrownew <span class="title">ClassNotFoundException</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="ClassLoaderTest"><a href="#ClassLoaderTest" class="headerlink" title="ClassLoaderTest:"></a>ClassLoaderTest:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyq.maventest.classloader;</span><br><span class="line">  </span><br><span class="line">publicclassClassLoaderTest &#123;</span><br><span class="line"> </span><br><span class="line"><span class="function">publicstaticvoid <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line"> </span><br><span class="line">ClassLoader myLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line"> </span><br><span class="line">Object obj = myLoader.loadClass(<span class="string">&quot;java.lang.Math&quot;</span>).newInstance();</span><br><span class="line"> </span><br><span class="line">System.out.println(obj);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Math："><a href="#Math：" class="headerlink" title="Math："></a><strong>Math</strong>：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*****</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: Math</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 自定义Math类，复写Java.lang.Math，检查是否会加载</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> youqiang.xiong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2018年1月24日下午3:18:41</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">publicfinalclassMath &#123;</span><br><span class="line"> </span><br><span class="line"><span class="function">publicstaticvoid <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyMath："><a href="#MyMath：" class="headerlink" title="MyMath："></a>MyMath：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">publicclassMyMath &#123;</span><br><span class="line">      </span><br><span class="line">     <span class="function">publicstaticvoid <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的测试代码没用自定义java.lang.System类，因为测试代码用到了JDK自带的System类进行输出打印，会冲突，所以改用为自定义的java.lang.Math类。如果自定义的Math类能加载，那么自定义的System类同样能加载。</p>
<h2 id="先直接运行下Math类"><a href="#先直接运行下Math类" class="headerlink" title="先直接运行下Math类"></a>先直接运行下Math类</h2><p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">错误: 在类 java.lang.Math 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br></pre></td></tr></table></figure>

<p>提示Math类没有main方法。首先大家要明白一个概念，当类首次主动使用时，必须进行类 的加载，这部分工作是由类加载器来完成的。根据双亲委托原则，Math类首先由启动类加载器去尝试加载，很显然，它找到rt.jar中的 java.lang.Math类并加载进内存（并不会加载我们自定义的Math类），然后执行main方法时，发现不存在该方法，所以报方法不存在错误。 也就是说，默认情况下JVM不会加载我们自定义的Math类。</p>
<h2 id="再直接运行MyMath类"><a href="#再直接运行MyMath类" class="headerlink" title="再直接运行MyMath类"></a>再直接运行MyMath类</h2><p>Jvm弹出异常提示框</p>
<p><img src="/2020/11/19/1-JVM/%E4%B8%BA%E6%AF%9B%E4%B8%8D%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-Java-long-String-Math-%E7%B1%BB%EF%BC%9F/20180124155247455" alt="img"></p>
<p>此时打开jvisualvm 可以监控到此程序的cpu，内存等运行情况</p>
<p><img src="/2020/11/19/1-JVM/%E4%B8%BA%E6%AF%9B%E4%B8%8D%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-Java-long-String-Math-%E7%B1%BB%EF%BC%9F/20180124155248125" alt="img"></p>
<p>点击两次按钮弹出后，会出现如下异常信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br><span class="line"> </span><br><span class="line">    at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="number">662</span>)</span><br><span class="line"> </span><br><span class="line">    at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">761</span>)</span><br><span class="line"> </span><br><span class="line">    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:<span class="number">142</span>)</span><br><span class="line"> </span><br><span class="line">    at java.net.URLClassLoader.defineClass(URLClassLoader.java:<span class="number">467</span>)</span><br><span class="line"> </span><br><span class="line">    at java.net.URLClassLoader.access$<span class="number">100</span>(URLClassLoader.java:<span class="number">73</span>)</span><br><span class="line"> </span><br><span class="line">    at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">368</span>)</span><br><span class="line"> </span><br><span class="line">    at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">362</span>)</span><br><span class="line"> </span><br><span class="line">    at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line"> </span><br><span class="line">    at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">361</span>)</span><br><span class="line"> </span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line"> </span><br><span class="line">    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">335</span>)</span><br><span class="line"> </span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line"> </span><br><span class="line">    at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:<span class="number">495</span>)</span><br></pre></td></tr></table></figure>

<p>注意红色部分的内容。由堆栈异常信息可知道，当应用程序类加载器类（AppClassLoader）尝试加载MyMath类时，ClassLoader.java的662行抛出了SecurityException</p>
<p>禁止使用包名：java.lang。</p>
<p>直接查看抽象类java.lang.ClassLoader的preDefineClass方法代码，摘抄如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private ProtectionDomain preDefineClass(String name,</span><br><span class="line">ProtectionDomain pd)</span><br><span class="line"> &#123;</span><br><span class="line"> if (!checkName(name))</span><br><span class="line"> thrownew NoClassDefFoundError(&quot;IllegalName: &quot; + name);</span><br><span class="line"> if ((name !&#x3D; null) &amp;&amp; name.startsWith(&quot;java.&quot;)) &#123;</span><br><span class="line"> thrownew SecurityException</span><br><span class="line"> (&quot;Prohibited package name: &quot; +</span><br><span class="line">name.substring(0, name.lastIndexOf(&#39;.&#39;)));</span><br><span class="line"> &#125;</span><br><span class="line"> if (pd &#x3D;&#x3D; null) &#123;</span><br><span class="line"> pd &#x3D; defaultDomain;</span><br><span class="line"> &#125;</span><br><span class="line"> if (name !&#x3D; null) checkCerts(name, pd.getCodeSource());</span><br><span class="line">returnpd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到如果加载的类全名称以”java.”开头时，将会抛出SecurityException，这也是为什么直接执行MyMath类会出现SecurityException。</p>
<p>照这样，我们自定义的类加载器必须继承自ClassLoader，其loadClass()方法里调用了父类的defineClass()方法，并最终调到preDefineClass()方法，因此我们自定义的类加载器也是不能加载以”java.”开头的java类的。</p>
<h2 id="继续运行下ClassLoaderTest"><a href="#继续运行下ClassLoaderTest" class="headerlink" title="继续运行下ClassLoaderTest"></a>继续运行下<strong>ClassLoaderTest</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/java/lang/Math.class</span><br><span class="line"> </span><br><span class="line">sun.net.www.protocol.jar.JarURLConnection$JarURLInputStream@<span class="number">4e25154f</span></span><br><span class="line"> </span><br><span class="line">java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br><span class="line">    at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="number">662</span>)</span><br><span class="line"> </span><br><span class="line">    at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">761</span>)</span><br><span class="line"> </span><br><span class="line">    at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">642</span>)</span><br><span class="line"> </span><br><span class="line">    at com.xyq.maventest.classloader.MyClassLoader.loadClass(MyClassLoader.java:<span class="number">37</span>)</span><br><span class="line"> </span><br><span class="line">    at com.xyq.maventest.classloader.ClassLoaderTest.main(ClassLoaderTest.java:<span class="number">7</span>)</span><br><span class="line"> </span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassNotFoundException</span><br><span class="line"> </span><br><span class="line">    at com.xyq.maventest.classloader.MyClassLoader.loadClass(MyClassLoader.java:<span class="number">40</span>)</span><br><span class="line"> </span><br><span class="line">    at com.xyq.maventest.classloader.ClassLoaderTest.main(ClassLoaderTest.java:<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p>备注：第一个at部分清楚表明，也是在preDefineClass方法中抛出的SecurityException。</p>
<p>通过代码实例及源码分析可以看到，对于自定义的类加载器，强行用defineClass()方法去加载一个以”java.”开头的类也是会抛出异常的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不能自己写以”java.”开头的类，其要么不能加载进内存，要么即使你用自定义的类加载器去强行加载，也会收到一个SecurityException。</p>
]]></content>
      <categories>
        <category>Java面试准备</category>
        <category>JVM</category>
        <category>类加载机制</category>
      </categories>
      <tags>
        <tag>类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是HotSpot虚拟机</title>
    <url>/2020/11/19/1-JVM/%E4%BB%80%E4%B9%88%E6%98%AFHotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="什么是HotSpot虚拟机"><a href="#什么是HotSpot虚拟机" class="headerlink" title="什么是HotSpot虚拟机"></a>什么是HotSpot虚拟机</h1><p>提起HotSpot VM，相信所有Java程序员都知道，它是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。</p>
<p>但不一定所有人都知道的是，这个目前看起来“血统纯正”的虚拟机在最初并非由Sun公司开发，而是由一家名为“Longview Technologies”的小公司设计的；</p>
<p>甚至这个虚拟机最初并非是为Java语言而开发的，它来源于Strongtalk VM，</p>
<p>而这款虚拟机中相当多的技术又是来源于一款支持Self语言实现“达到C语言50%以上的执行效率”的目标而设计的虚拟机，</p>
<p>Sun公司注意到了这款虚拟机在JIT编译上有许多优秀的理念和实际效果，在1997年收购了Longview Technologies公司，从而获得了HotSpot VM。</p>
<p>HotSpot VM既继承了Sun之前两款商用虚拟机的优点（如前面提到的准确式内存管理），也有许多自己新的技术优势，</p>
<p>如它名称中的HotSpot指的就是它的热点代码探测技术（其实两个VM基本上是同时期的独立产品，HotSpot还稍早一些，HotSpot一开始就是准确式GC，</p>
<p>而Exact VM之中也有与HotSpot几乎一样的热点探测。</p>
<p>为了Exact VM和HotSpot VM哪个成为Sun主要支持的VM产品，在Sun公司内部还有过争论，HotSpot打败Exact并不能算技术上的胜利），</p>
<p>HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以方法为单位进行编译。</p>
<p>如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。</p>
<p>通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，</p>
<p>即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。</p>
<p><strong>在2006年的JavaOne大会上，Sun公司宣布最终会把Java开源</strong>，并在随后的一年，陆续将JDK的各个部分（其中当然也包括了HotSpot VM）在GPL协议下公开了源码，</p>
<p>并在此基础上建立了OpenJDK。这样，HotSpot VM便成为了Sun JDK和OpenJDK两个实现极度接近的JDK项目的共同虚拟机。</p>
<p>在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，这样Oracle就同时拥有了两款优秀的Java虚拟机：JRockit VM和HotSpot VM。</p>
<p>Oracle公司宣布在不久的将来（大约应在发布JDK 8的时候）会完成这两款虚拟机的整合工作，使之优势互补。</p>
<p>整合的方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务，</p>
<p>使用HotSpot的JIT编译器与混合的运行时系统。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>GC</tag>
        <tag>HotSpot虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>理解ClassNotFoundException与NoClassDefFoundError的区别</title>
    <url>/2020/11/19/1-JVM/%E7%90%86%E8%A7%A3ClassNotFoundException%E4%B8%8ENoClassDefFoundError%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="理解ClassNotFoundException与NoClassDefFoundError的区别"><a href="#理解ClassNotFoundException与NoClassDefFoundError的区别" class="headerlink" title="理解ClassNotFoundException与NoClassDefFoundError的区别"></a>理解ClassNotFoundException与NoClassDefFoundError的区别</h1><p>上篇文章已经介绍过Java的类加载机制，在类加载的过程中我们最常遇到的异常就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassNotFoundException</span><br><span class="line">NoClassDefFoundError</span><br></pre></td></tr></table></figure>

<p>但是你知道他们的区别吗？以及什么情况下发生上面的异常？ 如果你还不清楚，那么不着急，我们来仔细分析一下：</p>
<p>先来说说第一个异常提示名字已经非常友好了，就是告诉我们使用类加载器就加载某个类的时候，发现所有的path下面都没有找到，从引导类路径，扩展类路径到当前的classpath下全部没有找到，就会抛出上面的异常，最常见的例子就是加载JDBC驱动包的时候，它的依赖jar并不在classpath里面，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class_loader.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就会抛出异常ClassNotFoundException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassNotFoundException: oracle.jdbc.driver.OracleDriver</span><br><span class="line">    at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">381</span>)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line">    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">331</span>)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">    at java.lang.Class.forName0(Native Method)</span><br><span class="line">    at java.lang.Class.forName(Class.java:<span class="number">264</span>)</span><br><span class="line">    at class_loader.exception.ExceptionTest.main(ExceptionTest.java:<span class="number">8</span>)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">147</span>)</span><br></pre></td></tr></table></figure>

<p>这种情况下，其实就是类找不到，通常在执行下面的方法时容易抛出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(),</span><br><span class="line">ClassLoader.loadClass()  </span><br><span class="line">ClassLoader.findSystemClass()</span><br></pre></td></tr></table></figure>

<p>接着我们看NoClassDefFoundError这个异常，严格来说不能叫异常，这种级别属于JVM的ERROR错误了，其严重级别要更高。</p>
<p>这个错误，主要有两种情况：</p>
<p>（1）编译时存在某个类，但是运行时却找不到，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;A hello&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         A a=<span class="keyword">new</span> A();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的Java类编译后会生成两个类文件，一个A.class,一个B.class，现在我在编译后，删掉了A的class文件，然后直接执行B的main方法，就会抛出 NoClassDefFoundError错误，因为当执行到 A a=new  A();这一步的时候，jvm认为这个类肯定在当前的classpath里面的，要不然编译都不会通过，更不用提执行了。既然它存在，那么在jvm里面一定能找到，如果不能找到，那就说明出大事了，因为编译和运行不一致，所以直接抛出这个ERROR，代表问题很严重。</p>
<p>（2）第二种情况，类根本就没有初始化成功，结果你还把它当做正常类使用，所以这事也不小，必须抛出ERROR告诉你不能再使用了。</p>
<p>看下面的一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Loading</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> i=<span class="number">1</span>/<span class="number">0</span>;<span class="comment">//故意使得类初始化失败.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> i=Loading.i;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">        <span class="comment">//此处，必须用Throwable，用Exception会直接退出.</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//继续使用.</span></span><br><span class="line">        Loading.print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: Could not initialize class class_loader.exception.Loading</span><br><span class="line">java.lang.ExceptionInInitializerError</span><br><span class="line">    at class_loader.exception.NoClassFoundErrorTest.main(NoClassFoundErrorTest.java:18)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">   at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)</span><br></pre></td></tr></table></figure>

<p>注意这种情况比较特殊，并不是因为编译时和运行时环境不一致导致的，而是对于一个类如果初始化失败后，你还继续使用，那么JVM会认为是不正常的，由于它第一次调用已经失败，JVM就会假设后面继续调用肯定仍然会失败，所以直接抛ERROR给客户端。</p>
<p>这里需要注意，类初始化失败的异常是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.ExceptionInInitializerError</span><br></pre></td></tr></table></figure>

<p>也是一个严重级别的错误。</p>
<p>总结：</p>
<p>本文主要对比介绍了ClassNotFoundException与NoClassDefFoundError的区别和发生条件，从上面的测试我们可以分析出，直接采用反射或者类加载器的loadClass方法去动态加载一个所有classpath里面的都不存在的类，类加载器在运行时的load阶段就会直接抛出ClassNotFoundException异常。此外jvm认为这个异常是可以被预知的需要提前被check。对于另一种请情况，如果在编译时候正常，但在运行时执行new关键词的时候，发现依赖类找不到，或者是对于初始化失败的一个类，再次访问其静态成员或者方法，那么会直接抛出NoClassDefFoundError错误。这两种异常本质上的侧重点还是不一样的，前者侧重在类加载器加载阶段找不到类信息，后者则侧重在使用阶段时却出现了问题比如实例化依赖类找不到或者类本身就初始化失败了。</p>
]]></content>
      <categories>
        <category>Java面试准备</category>
        <category>JVM</category>
        <category>类加载机制</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基本数据类型及其关系</title>
    <url>/2021/11/09/0-C%20%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="./123.pdf" width="100%" height="550" type="application/pdf">
	</div>




]]></content>
      <categories>
        <category>0-C基础</category>
      </categories>
  </entry>
  <entry>
    <title>对象在内存中的状态</title>
    <url>/2020/11/22/1-JVM/%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h1 id="对象在内存中的状态"><a href="#对象在内存中的状态" class="headerlink" title="对象在内存中的状态"></a>对象在内存中的状态</h1><p> 当一个对象在堆内存中运行时，根据它被引用变量所引用的状态，可以所它所处的状态分成三种</p>
<h2 id="激活状态："><a href="#激活状态：" class="headerlink" title="激活状态："></a>激活状态：</h2><p>当一个对象被创建后，有一个或一个以上的引用变量引用它，则这个对象在程序中处于激活状态，程序</p>
<p> 可以通过引用变量来调用该对象的方法和属性。</p>
<h2 id="去活状态："><a href="#去活状态：" class="headerlink" title="去活状态："></a>去活状态：</h2><p>如果程序中某个对象不再有任何引用变量引用它，它就进入了去活状态，在这个状态下，系统的垃圾回收机制准备</p>
<p> 回收该对象所占用的内存空间，在回收该对象之前，系统会调用所有对象的finalize方法进行资源的清理，如果系统在调用finalize方法重新让一个引用变量引用该对象，则这个对象会再次变为激活状态，否则该 对象状进入死亡状态。</p>
<h2 id="死亡状态："><a href="#死亡状态：" class="headerlink" title="死亡状态："></a>死亡状态：</h2><p>当对象与所有引用变量的关联都被切继，且系统已经调用所有对象的finalize方法依然没有该对象变成激活状态，那这个对象将永久性地失去引用，</p>
<p> 最后变成死亡状态，只有当一个对象处于死亡状态时统才会真正回收该对象所占有的资源。</p>
<p><img src="/2020/11/22/1-JVM/%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81/1.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>Java面试准备</category>
        <category>JVM</category>
        <category>Java内存模型</category>
      </categories>
      <tags>
        <tag>Java内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>技术问题-零碎汇总</title>
    <url>/2021/11/09/0-C%20%E5%9F%BA%E7%A1%80/%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98-%E9%9B%B6%E7%A2%8E%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="编译不报错，连接或执行报错"><a href="#编译不报错，连接或执行报错" class="headerlink" title="编译不报错，连接或执行报错"></a><strong>编译不报错，连接或执行报错</strong></h3><p>报这个：fatal error LNK1120: 1 unresolved externals报的是 库函数没有链接成功 我的错误是 main 拼错了。还有就是看一下进程，是不是那个exe进程后台运行着，结束它。</p>
<h3 id="空格-空值-null-0-‘0’‘-0’”-0”的关系"><a href="#空格-空值-null-0-‘0’‘-0’”-0”的关系" class="headerlink" title="空格 空值 null 0 ‘0’‘\0’”\0”的关系"></a><strong>空格 空值 null 0 ‘0’‘\0’”\0”的关系</strong></h3><p>空格不是空值！在ASCII码中 空格是00100000B（B代表二进制数）表示的！NUL(null)空字符 是00000000表示的如果是一个空杯子（里面有空气）那么把它理解为空格！有一个杯子里面什么都没有（真空）那么把它理解为空值！如果连杯子都没有！那就是null</p>
<p><strong>0</strong>  数字0<br><strong>空格</strong>（space） ASCII码数值32<br><strong>null</strong> 用以赋给指针的值 ASCII码数值0 ;表示空 作用基本上是用以赋给一个指针变量或常量的值为0，以便通过if或while之类的判断语句来决定采取某种操作。；<br>**’0’** <strong>字符0；</strong> ASCII码数值48；<br>**’\0’** 非可见字符，字符串结尾符，本质上就是字符； ASCII码数值0；<br>**”\0”** 是字符串，里面有一个写入的字符串结尾符，还有一个默认的字符串结尾符。是空字符串。 长度是0， 占内存 2 字节。<br>‘\0’ == 0 != ‘0’<br>若要用%c输出‘\0’ 会报错，若a=‘\0’ 用%c输出a，结果就是a。</p>
<h3 id="编程小技巧"><a href="#编程小技巧" class="headerlink" title="编程小技巧"></a><strong>编程小技巧</strong></h3><p>学着用条件表达式代替长的 if else 代码只要是从键盘输入的不是回车，则重新输入。即不进行任何操作 重新执行代码。while(getchar()!=’\n’){    ;}scanf时 %<em>d 这个</em> 就代表输入的时候不赋予相应的变量 跳过该字符。</p>
]]></content>
      <categories>
        <category>0-C基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java-Object类中的方法详解</title>
    <url>/2020/11/22/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E5%9F%BA%E7%A1%8000-Object%E5%9F%BA%E7%B1%BB%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Object根类中的方法"><a href="#Object根类中的方法" class="headerlink" title="Object根类中的方法"></a>Object根类中的方法</h1><h2 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives()"></a>registerNatives()</h2><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我对这个方法暂时还不太理解，后面我补回来！这个跟JNI有关，而我工作中会用到JNI，虽然现在还不会用，哈哈哈！！</p>
<h2 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h2><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>

<p>首先，这个方法是被<code>final</code> 修饰的，你平时写一个类，可以通过那个类的对象调用Object的这个方法，<strong>所以说，被<code>final</code>修饰的方法，是可以被继承的，但是不能被重写。</strong></p>
<p>方法注释是这么说的：<br> <img src="/2020/11/22/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E5%9F%BA%E7%A1%8000-Object%E5%9F%BA%E7%B1%BB%E6%96%B9%E6%B3%95/1" alt="返回此object的运行时类。返回的类对象是被表示类的static synchronized方法锁定的对象。"></p>
<p>什么是运行时类？</p>
<p>我们通过eclipse写一段代码，不调试和运行，把它保存起来，会变成一个后缀为 .java 的文件，我们把它叫做源文件，里面的东西就我们自己写的能看懂的代码。这个类就是<strong>编译时类</strong>。</p>
<p>我们都知道C语言的源文件，要经过编译，才可以生成一个后缀为 .exe  的可执行文件。Java和C的道理是一样的，只不过Java的源文件经过编译后，会生成一个后缀为 .class 的文件，这些  .class文件很明显是不能直接运行的，它不像C语言(编译cpp后生成exe文件直接运行)，这些 .class文件是交由JVM来解析运行。这个  .class 文件，就是<strong>运行时类</strong>。</p>
<p>当我们调用getClass()方法的时候，返回的正是这个类的 .class 文件。<strong>这个方法，是我们反射的三种方式之一</strong>。</p>
<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>首先这个方法的返回值是<code>int</code>类型，所以hashcode算出来的hash值都是<code>int</code>范围内的值：-2^31 ~ 2^31 - 1</p>
<p><strong>默认的hashCode是将内存地址转换为hash值，重写过后才会是自定义的计算方式</strong>；你也可以通过调用<code>System.identityHashCode(Object)</code>来返回原本的hashCode。所以说这个方法如果不在子类重写，就失去了他本身存在的作用与意义。</p>
<p>方法注释是这么说的：<br> <img src="/2020/11/22/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E5%9F%BA%E7%A1%8000-Object%E5%9F%BA%E7%B1%BB%E6%96%B9%E6%B3%95/2" alt="在这里插入图片描述"><br> 现在我们来看这样一个问题（我秋招时被问到过，嗯嗯，问我的这个人现在是我领导，哈哈哈）：<br> 有一个Student类，里面就一个构造方法和一个String属性，你现在一顿操作写了下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Object, String&gt; map = <span class="keyword">new</span> HashMap&lt;Object, String&gt;();</span><br><span class="line">map.put(<span class="keyword">new</span> Student(<span class="string">&quot;学生&quot;</span>), <span class="string">&quot;学生&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>过了一会你想把它取出来，于是你就<code>map.get(new Student(&quot;学生&quot;))</code>这样又来一顿操作。那么问题来了，你能不能得到预期的结果？为什么？</p>
<p>答案是否定的，当你将一个对象作为hashmap的键值的时候，虚拟机会调用该对象的hashcode方法，返回一个hash值，以此来作为映射中的唯一标识。但是Student类并没有重写Object类中的hashcode方法，所以他的对象调用的还是默认的hashcode，默认的hashcode方法是将内存地址转换为hash值，所以上面那个问题，<code>map.put(new Student(&quot;学生&quot;), &quot;学生&quot;);</code>时<code>new</code>了一个对象，<code>map.get(new Student(&quot;学生&quot;))</code>时又new了一个对象，这两个对象看似一样，实际上他们在堆内存中被分配在不同的内存块上，所以通过默认的hashcode返回的两个hash值是不一样，也就不能得到预期的结果。</p>
<p>那我们应该怎么操作，才能得到呢？</p>
<p>重写hashcode方法就能做到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Object[] a = Stream.of(s).toArray();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (Object element : a) &#123;</span><br><span class="line">		result = <span class="number">31</span> * result + (element == <span class="keyword">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面我们重写时为什么要用<code>result = 31 * result + (element == null ? 0 : element.hashCode());</code>呢？<br> 因为你阅读源码就会发现，String类、Arrays类等很多类都是这么写的。<br> 那为什么他们要这么写呢？<br> 比较靠谱的解释是：<code>result * 31 = (result&lt;&lt;5) - result</code>，JVM底层可以自动做优化为位运算，效率很高；还有因为31计算的hashCode冲突较少，利于hash桶位的分布。</p>
<h2 id="equals-Object-obj"><a href="#equals-Object-obj" class="headerlink" title="equals(Object obj)"></a>equals(Object obj)</h2><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法注释：<br> <img src="/2020/11/22/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E5%9F%BA%E7%A1%8000-Object%E5%9F%BA%E7%B1%BB%E6%96%B9%E6%B3%95/3" alt="在这里插入图片描述"></p>
<p>这个方法就没有那么多的五五六六七七了，看源码就知道，如果不重写，默认的<code>equals</code>方法和<code>==</code>的功能是一样的，<code>==</code>比较的是两个对象的地址是否相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student c1 = <span class="keyword">new</span> Student(<span class="string">&quot;学生&quot;</span>);</span><br><span class="line">Student c2 = <span class="keyword">new</span> Student(<span class="string">&quot;学生&quot;</span>);</span><br><span class="line"><span class="comment">//没重写equals方法时</span></span><br><span class="line">System.out.println(c1.equals(c2));<span class="comment">// false</span></span><br><span class="line">System.out.println(c1 == c2);<span class="comment">// false</span></span><br><span class="line"><span class="comment">//重写了equals方法时：</span></span><br><span class="line">System.out.println(c1.equals(c2));<span class="comment">// true</span></span><br><span class="line">System.out.println(c1 == c2);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>那应该如何重写equals方法？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先判断是否为同一对象</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 再判断目标对象是否为当前类或者当前类的子类的实例对象</span></span><br><span class="line">	<span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Student)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这一步强转是必须的</span></span><br><span class="line">	Student o = (Student) obj;</span><br><span class="line">	<span class="keyword">return</span> o.s.equals(<span class="keyword">this</span>.s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要重写呢？<br>  因为如果不重写equals方法，当将自定义对象放到map或者set中时；如果这时两个对象的hashCode相同，就会调用equals方法进行比较，这个时候会调用Object中默认的equals方法，而默认的equals方法只是比较了两个对象的引用是否指向了同一个地址，显然大多数时候都不会指向，这样就会将重复对象存入map或者set中。这就破坏了map与set不能存储重复对象的特性，会造成内存溢出。</p>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>

<p>方法注释：<br> <img src="/2020/11/22/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E5%9F%BA%E7%A1%8000-Object%E5%9F%BA%E7%B1%BB%E6%96%B9%E6%B3%95/clone" alt="在这里插入图片描述"><br> 此方法返回当前对象的一个副本，但需要实现Cloneable接口，如果没有实现，虽可以重写，但是当调用<code>object.clone()</code>方法，会抛出<code>CloneNotSupportedException</code>；如果没有重写，则无法调用。<strong>Cloneable接口只是一个标记接口，里面啥都没有，所以虽然实现了Cloneable接口，但是重写的方法依旧是Object中的方法。</strong></p>
<p>克隆（复制），他有<strong>浅克隆</strong>和<strong>深克隆</strong>，如果一个类的属性只有基本类型，那深克隆和浅克隆是一样的，如果有引用类型，就能体现出他们的不同，看着下面代码理解深克隆和浅克隆的概念：</p>
<ul>
<li>浅克隆：拷贝的是引用。</li>
<li>深克隆：新开辟内存空间，进行值拷贝。</li>
</ul>
<p>Student类有两个属性，age是基本类型，stu是引用类型。对于基本类型，深浅克隆都是值拷贝，基本类型就没有引用拷贝这么一说！对于引用类型，浅克隆是引用拷贝，深克隆是值拷贝。</p>
<p>浅克隆拷贝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Student c = <span class="keyword">new</span> Student(<span class="number">18</span>);</span><br><span class="line">		Student c1 = <span class="keyword">new</span> Student(<span class="number">18</span>, c);</span><br><span class="line">		Student c2 = (Student) c1.clone();</span><br><span class="line"></span><br><span class="line">		System.out.println(c1 == c2);<span class="comment">// false</span></span><br><span class="line">		System.out.println(c1.toString());<span class="comment">// [age = 18,stu.age = 18]</span></span><br><span class="line">		System.out.println(c2.toString());<span class="comment">// [age = 18,stu.age = 18]</span></span><br><span class="line"></span><br><span class="line">		c.age = <span class="number">20</span>;<span class="comment">// 重点在这里，注意理解下面的stu.age</span></span><br><span class="line">		System.out.println(c1.toString());<span class="comment">// [age = 18,stu.age = 20]</span></span><br><span class="line">		System.out.println(c2.toString());<span class="comment">// [age = 18,stu.age = 20]</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> Student stu;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.age = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, Student student)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.stu = student;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;[age = &quot;</span> + age + <span class="string">&quot;,stu.age = &quot;</span> + stu.age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>深克隆拷贝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Student c = <span class="keyword">new</span> Student(<span class="number">18</span>);<span class="comment">// false</span></span><br><span class="line">		Student c1 = <span class="keyword">new</span> Student(<span class="number">18</span>, c);</span><br><span class="line">		Student c2 = (Student) c1.clone();</span><br><span class="line"></span><br><span class="line">		System.out.println(c1 == c2);</span><br><span class="line">		System.out.println(c1.toString());<span class="comment">// [age = 18,stu.age = 18]</span></span><br><span class="line">		System.out.println(c2.toString());<span class="comment">// [age = 18,stu.age = 18]</span></span><br><span class="line"></span><br><span class="line">		c.age = <span class="number">20</span>;</span><br><span class="line">		System.out.println(c1.toString());<span class="comment">// [age = 18,stu.age = 20]</span></span><br><span class="line">		System.out.println(c2.toString());<span class="comment">// [age = 18,stu.age = 18]</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		Student clone = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">		clone.stu = <span class="keyword">new</span> Student(age);</span><br><span class="line">		<span class="keyword">return</span> clone;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法注释：<br> <img src="/2020/11/22/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E5%9F%BA%E7%A1%8000-Object%E5%9F%BA%E7%B1%BB%E6%96%B9%E6%B3%95/String" alt="在这里插入图片描述"><br> 从源码上就可以直接看出来，默认的toString方法，只是将当前类的全限定性类名+@+十六进制的hashCode值。一般情况下，我们都是要重写这个方法的，不然返回的那玩意没啥用，那怎么写呢？肯定是写一些对我们来说有用的东西，打印当前对象的类属性值什么的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;[s = &quot;</span> + s + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="notify-、notifyAll"><a href="#notify-、notifyAll" class="headerlink" title="notify()、notifyAll()"></a>notify()、notifyAll()</h2><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法注释：<br> <img src="/2020/11/22/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E5%9F%BA%E7%A1%8000-Object%E5%9F%BA%E7%B1%BB%E6%96%B9%E6%B3%95/notify" alt="在这里插入图片描述"><br> <img src="/2020/11/22/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E5%9F%BA%E7%A1%8000-Object%E5%9F%BA%E7%B1%BB%E6%96%B9%E6%B3%95/notifyAll" alt="在这里插入图片描述"></p>
<h2 id="wait-long-timeout-、wait-long-timeout-int-nanos-、wait"><a href="#wait-long-timeout-、wait-long-timeout-int-nanos-、wait" class="headerlink" title="wait(long timeout)、wait(long timeout, int nanos)、wait()"></a>wait(long timeout)、wait(long timeout, int nanos)、wait()</h2><p>这部分主要和多线程的操作有关，包括上面的notify方法</p>
<p>本站搜索： Java多线程同步机制</p>
<h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h2><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>方法注释：<br> <img src="/2020/11/22/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E5%9F%BA%E7%A1%8000-Object%E5%9F%BA%E7%B1%BB%E6%96%B9%E6%B3%95/finalize" alt="在这里插入图片描述"><br> 这个方法理解的过程曾让我觉得我的中文理解能力有问题，Java编程思想第四版，感觉这个书翻译过来后读起来好拗人啊！哎，我太难了！最后还是从网上零七八碎的看懂了些。</p>
<p><strong>finalize()方法总结起来具有下面4个特点，编程思想上面基本都说到了：</strong></p>
<ul>
<li>永远不要主动调用某个对象的finalize()方法，该方法由垃圾回收机制自己调用；</li>
<li>finalize()何时被调用，是否被调用具有不确定性；</li>
<li>当JVM执行可恢复对象的finalize()可能会将此对象重新变为可达状态；</li>
<li>当JVM执行finalize()方法时出现异常，垃圾回收机制不会报告异常，程序继续执行。</li>
</ul>
<p> <strong>我们先看一个对象在内存中的状态有哪些情况吧！</strong> 当一个对象在堆内存中运行时，根据它被引用变量所引用的状态，可以所它所处的状态分成三种：</p>
<ul>
<li><strong>激活状态</strong>：当一个对象被创建后，有一个或一个以上的引用变量引用它，则这个对象在程序中处于激活状态，程序可以通过引用变量来调用该对象的方法和属性。</li>
<li><strong>去活状态</strong>：如果程序中某个对象不再有任何引用变量引用它，它就进入了去活状态，在这个状态下，系统的垃圾回收机制准备  回收该对象所占用的内存空间，在回收该对象之前，系统会调用所有对象的finalize方法进行资源的清理，如果系统在调用finalize方法重新让一个引用变量引用该对象，则这个对象会再次变为激活状态，否则该 对象状进入死亡状态。</li>
<li><strong>死亡状态</strong>：当对象与所有引用变量的关联都被切继，且系统已经调用所有对象的finalize方法依然没有该对象变成激活状态，那这个对象将永久性地失去引用，最后变成死亡状态，只有当一个对象处于死亡状态时统才会真正回收该对象所占有的资源。</li>
</ul>
]]></content>
      <categories>
        <category>1-JavaSE基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Object类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础03-String类相关</title>
    <url>/2021/11/10/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E5%9F%BA%E7%A1%8003-String%E7%B1%BB%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>123<img src="/2021/11/10/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E5%9F%BA%E7%A1%8003-String%E7%B1%BB%E7%9B%B8%E5%85%B3/Java77.jpg" alt="Java"></p>
]]></content>
      <categories>
        <category>1-JavaSE基础巩固</category>
      </categories>
  </entry>
  <entry>
    <title>Java基础01-数据类型与访问权限</title>
    <url>/2021/11/09/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E5%9F%BA%E7%A1%8001-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h2 id="为什么Java代码可以实现一次编写、到处运行？"><a href="#为什么Java代码可以实现一次编写、到处运行？" class="headerlink" title="为什么Java代码可以实现一次编写、到处运行？"></a>为什么Java代码可以实现一次编写、到处运行？</h2><p>JVM（Java虚拟机）是Java跨平台的关键。在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。同一份Java源代码在不同的平台上运行，它不需要做任何的改变，并且只需要编译一次。而编译好的字节码，是通过JVM这个中间的“桥梁”实现跨平台的，JVM是与平台相关的软件，它能将统一的字节码翻译成该平台的机器码。注意事项</p>
<ol>
<li>编译的结果是生成字节码、不是机器码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行；</li>
<li>跨平台的是Java程序、而不是JVM，JVM是用C/C++开发的软件，不同平台下需要安装不同版本的JVM。</li>
</ol>
<h2 id="一个Java文件里可以有多个类吗（不含内部类）？"><a href="#一个Java文件里可以有多个类吗（不含内部类）？" class="headerlink" title="一个Java文件里可以有多个类吗（不含内部类）？"></a>一个Java文件里可以有多个类吗（不含内部类）？</h2><ol>
<li>一个java文件里可以有多个类，但最多只能有一个被public修饰的类；</li>
<li>如果这个java文件中包含public修饰的类，则这个类的名称必须和java文件名一致。</li>
</ol>
<h2 id="说一说你对Java访问权限的了解"><a href="#说一说你对Java访问权限的了解" class="headerlink" title="说一说你对Java访问权限的了解"></a>说一说你对Java访问权限的了解</h2><p>Java语言为我们提供了三种访问修饰符，即private、protected、public，在使用这些修饰符修饰目标时，一共可以形成四种访问权限，即private、defalut、protected、public，注意在不加任何修饰符时为defalut访问权限。在修饰成员变量/成员方法时，该成员的四种访问权限的含义如下：</p>
<ul>
<li>private：该成员可以被该类内部成员访问；</li>
<li>defalut：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问；</li>
<li>protected：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问，还可以被它的子类访问；</li>
<li>public：该成员可以被任意包下，任意类的成员进行访问。</li>
</ul>
<p>在修饰类时，该类只有两种访问权限，对应的访问权限的含义如下：</p>
<ul>
<li>defalut：该类可以被同一包下其他的类访问；</li>
<li>public：该类可以被任意包下，任意的类所访问。</li>
</ul>
<h2 id="介绍一下Java的数据类型"><a href="#介绍一下Java的数据类型" class="headerlink" title="介绍一下Java的数据类型"></a>介绍一下Java的数据类型</h2><p>Java数据类型包括基本数据类型和引用数据类型两大类。</p>
<p>基本数据类型有8个，可以分为4个小类，分别是整数类型（byte/short/int/long）、浮点类型（float/double）、字符类型（char）、布尔类型（boolean）。其中，4个整数类型中，int类型最为常用。2个浮点类型中，double最为常用。另外，在这8个基本类型当中，除了布尔类型之外的其他7个类型，都可以看做是数字类型，它们相互之间可以进行类型转换。</p>
<p>引用类型就是对一个对象的引用，根据引用对象类型的不同，可以将引用类型分为3类，即数组、类、接口类型。引用类型本质上就是通过指针，指向堆中对象所持有的内存空间，只是Java语言不再沿用指针这个说法而已。</p>
<p><strong>扩展阅读</strong><br>对于基本数据类型，你需要了解每种类型所占据的内存空间，面试官可能会追问这类问题：<br>byte：1字节（8位），数据范围是 -2^7 ~ 2^7-1。<br>short：2字节（16位），数据范围是 -2^15 ~ 2^15-1。<br>int：4字节（32位），数据范围是 -2^31 ~ 2^31-1。<br>long：8字节（64位），数据范围是 -2^63 ~ 2^63-1。<br>float：4字节（32位），数据范围大约是 -3.4<em>10^38 ~ 3.4</em>10^38。<br>double：8字节（64位），数据范围大约是 -1.8<em>10^308 ~ 1.8</em>10^308。<br>char：2字节（16位），数据范围是 \u0000 ~ \uffff。<br>boolean：Java规范没有明确的规定，不同的JVM有不同的实现机制。<br>对于引用数据类型，你需要了解JVM的内存分布情况，知道引用以及引用对象存放的位置，详见JVM部分的题目。</p>
<h2 id="int类型的数据范围是多少？"><a href="#int类型的数据范围是多少？" class="headerlink" title="int类型的数据范围是多少？"></a>int类型的数据范围是多少？</h2><p>int类型占4字节（32位），数据范围是 -2^31 ~ 2^31-1。</p>
<h2 id="请介绍全局变量和局部变量的区别"><a href="#请介绍全局变量和局部变量的区别" class="headerlink" title="请介绍全局变量和局部变量的区别"></a>请介绍全局变量和局部变量的区别</h2><p>Java中的变量分为成员变量和局部变量，它们的区别如下：<br>成员变量：<br>    1. 成员变量是在类的范围里定义的变量；<br>    2. 成员变量有默认初始值；<br>    3. 未被static修饰的成员变量也叫实例变量，它存储于对象所在的堆内存中，生命周期与对象相同；<br>    4. 被static修饰的成员变量也叫类变量，它存储于方法区中，生命周期与当前类相同。<br>    局部变量：<br>    1. 局部变量是在方法里定义的变量；<br>    2. 局部变量没有默认初始值；<br>    3. 局部变量存储于栈内存中，作用的范围结束，变量空间会自动的释放。<br>    注意事项<br>    Java中没有真正的全局变量，面试官应该是出于其他语言的习惯说全局变量的，他的本意应该是指成员变量。</p>
<h2 id="请介绍一下实例变量的默认值"><a href="#请介绍一下实例变量的默认值" class="headerlink" title="请介绍一下实例变量的默认值"></a>请介绍一下实例变量的默认值</h2><p>实例变量若为引用数据类型，其默认值一律为null。若为基本数据类型，其默认值如下：<br>byte：0<br>short：0<br>int：0<br>long：0L<br>float：0.0F<br>double：0.0<br>char：’\u0000’<br>boolean：false<br><strong>注意事项</strong><br>上述默认值规则适用于所有的成员变量，所以对于类变量也是适用的。</p>
]]></content>
      <categories>
        <category>1-JavaSE基础巩固</category>
      </categories>
  </entry>
  <entry>
    <title>Java基础02-面向对象</title>
    <url>/2021/11/09/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E5%9F%BA%E7%A1%8002-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="为啥要有包装类？"><a href="#为啥要有包装类？" class="headerlink" title="为啥要有包装类？"></a>为啥要有包装类？</h2><p>Java语言是面向对象的语言，其设计理念是“一切皆对象”。但8种基本数据类型却出现了例外，它们不具备对象的特性。正是为了解决这个问题，Java为每个基本数据类型都定义了一个对应的引用类型，这就是包装类。<br><strong>扩展阅读</strong><br>Java之所以提供8种基本数据类型，主要是为了照顾程序员的传统习惯。这8种基本数据类型的确带来了一定的方便性，但在某些时候也会受到一些制约。比如，所有的引用类型的变量都继承于Object类，都可以当做Object类型的变量使用，但基本数据类型却不可以。如果某个方法需要Object类型的参数，但实际传入的值却是数字的话，就需要做特殊的处理了。有了包装类，这种问题就可以得以简化。</p>
<h2 id="说一说自动装箱、自动拆箱的应用场景"><a href="#说一说自动装箱、自动拆箱的应用场景" class="headerlink" title="说一说自动装箱、自动拆箱的应用场景"></a>说一说自动装箱、自动拆箱的应用场景</h2><p>自动装箱、自动拆箱是JDK1.5提供的功能。<br>自动装箱：可以把一个基本类型的数据直接赋值给对应的包装类型；<br>自动拆箱：可以把一个包装类型的对象直接赋值给对应的基本类型；</p>
<p>通过自动装箱、自动拆箱功能，可以大大简化基本类型变量和包装类对象之间的转换过程。比如，某个方法的参数类型为包装类型，调用时我们所持有的数据却是基本类型的值，则可以不做任何特殊的处理，直接将这个基本类型的值传入给方法即可。</p>
<h2 id="如何对Integer和Double类型判断相等？"><a href="#如何对Integer和Double类型判断相等？" class="headerlink" title="如何对Integer和Double类型判断相等？"></a>如何对Integer和Double类型判断相等？</h2><p>Integer、Double不能直接进行比较，这包括：</p>
<ul>
<li>不能用==进行直接比较，因为它们是不同的数据类型；</li>
<li>不能转为字符串进行比较，因为转为字符串后，浮点值带小数点，整数值不带，这样它们永远都不相等；</li>
<li>不能使用compareTo方法进行比较，虽然它们都有compareTo方法，但该方法只能对相同类型进行比较。</li>
</ul>
<p>整数、浮点类型的包装类，都继承于Number类型，而Number类型分别定义了将数字转换为byte、short、int、long、float、double的方法。所以，可以将Integer、Double先转为转换为相同的基本数据类型（如double），然后使用==进行比较。<br>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">100</span>;</span><br><span class="line">Double d = <span class="number">100.00</span>;</span><br><span class="line">System.out.println(i.doubleValue() == d.doubleValue());</span><br></pre></td></tr></table></figure>
<h2 id="int和Integer有什么区别，二者在做-运算时会得到什么结果？"><a href="#int和Integer有什么区别，二者在做-运算时会得到什么结果？" class="headerlink" title="int和Integer有什么区别，二者在做==运算时会得到什么结果？"></a>int和Integer有什么区别，二者在做==运算时会得到什么结果？</h2><p>int是基本数据类型，Integer是int的包装类。二者在做==运算时，Integer会自动拆箱为int类型，然后再进行比较。届时，如果两个int值相等则返回true，否则就返回false。</p>
<h2 id="说一说你对面向对象的理解"><a href="#说一说你对面向对象的理解" class="headerlink" title="说一说你对面向对象的理解"></a>说一说你对面向对象的理解</h2><p>面向对象是一种更优秀的程序设计方法，它的基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式，强调直接以现实世界中的事物为中心来思考，认识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映像到客观世界，并保持客观世界中事物及其相互关系的本来面貌。</p>
<p><strong>扩展阅读</strong><br>结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为自顶向下、逐步求精、模块化等。结构化程序设计首先采用结构化分析方法对系统进行需求分析，然后使用结构化设计方法对系统进行概要设计、详细设计，最后采用结构化编程方法来实现系统。</p>
<p>因为结构化程序设计方法主张按功能把软件系统逐步细分，因此这种方法也被称为面向功能的程序设计方法；结构化程序设计的每个功能都负责对数据进行一次处理，每个功能都接受一些数据，处理完后输出一些数据，这种处理方式也被称为面向数据流的处理方式。结构化程序设计里最小的程序单元是函数，每个函数都负责完成一个功能，用以接收一些输入数据，函数对这些输入数据进行处理，处理结束后输出一些数据。整个软件系统由一个个函数组成，其中作为程序入口的函数被称为主函数，主函数依次调用其他普通函数，普通函数之间依次调用，从而完成整个软件系统的功能。</p>
<p>每个函数都是具有输入、输出的子系统，函数的输入数据包括函数形参、全局变量和常量等，函数的输出数据包括函数返回值以及传出参数等。结构化程序设计方式有如下两个局限性：</p>
<ul>
<li>设计不够直观，与人类习惯思维不一致。采用结构化程序分析、设计时，开发者需要将客观世界模型分解成一个个功能，每个功能用以完成一定的数据处理。</li>
<li>适应性差，可扩展性不强。由于结构化设计采用自顶向下的设计方式，所以当用户的需求发生改变，或需要修改现有的实现方式时，都需要自顶向下地修改模块结构，这种方式的维护成本相当高。</li>
</ul>
<h2 id="面向对象的三大特征是什么？"><a href="#面向对象的三大特征是什么？" class="headerlink" title="面向对象的三大特征是什么？"></a>面向对象的三大特征是什么？</h2><p>面向对象的程序设计方法具有三个基本特征：封装、继承、多态。其中，封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能；继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法；多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。<br><strong>扩展阅读</strong><br>抽象也是面向对象的重要部分，抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是考虑部分问题。例如，需要考察Person对象时，不可能在程序中把Person的所有细节都定义出来，通常只能定义Person的部分数据、部分行为特征，而这些数据、行为特征是软件系统所关心的部分。1.14 封装的目的是什么，为什么要有封装？封装是面向对象编程语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。对一个类或对象实现良好的封装，可以实现以下目的：</p>
<pre><code>* 隐藏类的实现细节；
* 让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；
* 可进行数据检查，从而有利于保证对象信息的完整性；
* 便于修改，提高代码的可维护性。</code></pre>
<p>扩展阅读为了实现良好的封装，需要从两个方面考虑：<br>    * 将对象的成员变量和实现细节隐藏起来，不允许外部直接访问；<br>    * 把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。</p>
<p>封装实际上有两个方面的含义：把该隐藏的隐藏起来，把该暴露的暴露出来。这两个方面都需要通过使用Java提供的访问控制符来实现。</p>
<h2 id="说一说你对多态的理解"><a href="#说一说你对多态的理解" class="headerlink" title="说一说你对多态的理解"></a>说一说你对多态的理解</h2><p>因为子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为向上转型，向上转型由系统自动完成。</p>
<p>当把一个子类对象直接赋给父类引用变量时，例如 BaseClass obj = new SubClass();，这个obj引用变量的编译时类型是BaseClass，而运行时类型是SubClass，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。</p>
<p><strong>扩展阅读</strong><br>多态可以提高程序的可扩展性，在设计程序时让代码更加简洁而优雅。例如我要设计一个司机类，他可以开轿车、巴士、卡车等等，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">(Car car)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">(Bus bus)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">(Truck truck)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在设计上述代码时，我已采用了重载机制，将方法名进行了统一。这样在进行调用时，无论要开什么交通工具，都是通过 driver.drive(obj) 这样的方式来调用，对调用者足够的友好。</p>
<p>但对于程序的开发者来说，这显得繁琐，因为实际上这个司机可以驾驶更多的交通工具。当系统需要为这个司机增加车型时，开发者就需要相应的增加driver方法，类似的代码会堆积的越来越多，显得臃肿。</p>
<p>采用多态的方式来设计上述程序，就会变得简洁很多。我们可以为所有的交通工具定义一个父类Vehicle，然后按照如下的方式设计drive方法。调用时，我们可以传入Vehicle类型的实例，也可以传入任意的Vechile子类型的实例，对于调用者来说一样的方便，但对于开发者来说，代码却变得十分的简洁了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">(Vehicle vehicle)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java中的多态是怎么实现的？"><a href="#Java中的多态是怎么实现的？" class="headerlink" title="Java中的多态是怎么实现的？"></a>Java中的多态是怎么实现的？</h2><p>多态的实现离不开继承，在设计程序时，我们可以将参数的类型定义为父类型。在调用程序时，则可以根据实际情况，传入该父类型的某个子类型的实例，这样就实现了多态。对于父类型，可以有三种形式，即普通的类、抽象类、接口。对于子类型，则要根据它自身的特征，重写父类的某些方法，或实现抽象类/接口的某些抽象方法。</p>
<h2 id="Java为什么是单继承，为什么不能多继承？"><a href="#Java为什么是单继承，为什么不能多继承？" class="headerlink" title="Java为什么是单继承，为什么不能多继承？"></a>Java为什么是单继承，为什么不能多继承？</h2><p>首先，Java是单继承的，指的是Java中一个类只能有一个直接的父类。Java不能多继承，则是说Java中一个类不能直接继承多个父类。</p>
<p>其次，Java在设计时借鉴了C++的语法，而C++是支持多继承的。Java语言之所以摒弃了多继承的这项特征，是因为多继承容易产生混淆。比如，两个父类中包含相同的方法时，子类在调用该方法或重写该方法时就会迷惑。</p>
<p>准确来说，Java是可以实现”多继承”的。因为尽管一个类只能有一个直接父类，但是却可以有任意多个间接的父类。这样的设计方式，避免了多继承时所产生的混淆。</p>
<h2 id="说一说重写与重载的区别"><a href="#说一说重写与重载的区别" class="headerlink" title="说一说重写与重载的区别"></a>说一说重写与重载的区别</h2><p>重载发生在同一个类中，若多个方法之间方法名相同、参数列表不同，则它们构成重载的关系。重载与方法的返回值以及访问修饰符无关，即重载的方法不能根据返回类型进行区分。</p>
<p>重写发生在父类子类中，若子类方法想要和父类方法构成重写关系，则它的方法名、参数列表必须与父类方法相同。另外，返回值要小于等于父类方法，抛出的异常要小于等于父类方法，访问修饰符则要大于等于父类方法。还有，若父类方法的访问修饰符为private，则子类不能对其重写。</p>
<h2 id="构造方法能不能重写？"><a href="#构造方法能不能重写？" class="headerlink" title="构造方法能不能重写？"></a>构造方法能不能重写？</h2><p>构造方法不能重写。因为构造方法需要和类保持同名，而重写的要求是子类方法要和父类方法保持同名。如果允许重写构造方法的话，那么子类中将会存在与类名不同的构造方法，这与构造方法的要求是矛盾的。</p>
<h2 id="介绍一下Object类中的方法"><a href="#介绍一下Object类中的方法" class="headerlink" title="介绍一下Object类中的方法"></a>介绍一下Object类中的方法</h2><p>Object类提供了如下几个常用方法：</p>
<ul>
<li>Class&lt;?&gt; getClass()：返回该对象的运行时类。</li>
<li>boolean equals(Object obj)：判断指定对象与该对象是否相等。</li>
<li>int hashCode()：返回该对象的hashCode值。在默认情况下，Object类的hashCode()方法根据该对象的地址来计算。但很多类都重写了Object类的hashCode()方法，不再根据地址来计算其hashCode()方法值。</li>
<li>String toString()：返回该对象的字符串表示，当程序使用System.out.println()方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的toString()方法返回该对象的字符串表示。Object类的toString()方法返回 运行时类名@十六进制hashCode值 格式的字符串，但很多类都重写了Object类的toString()方法，用于返回可以表述该对象信息的字符串。</li>
</ul>
<p>另外，Object类还提供了wait()、notify()、notifyAll()这几个方法，通过这几个方法可以控制线程的暂停和运行。Object类还提供了一个clone()方法，该方法用于帮助其他对象来实现“自我克隆”，所谓“自我克隆”就是得到一个当前对象的副本，而且二者之间完全隔离。由于该方法使用了protected修饰，因此它只能被子类重写或调用。<br><strong>扩展阅读</strong><br>Object类还提供了一个finalize()方法，当系统中没有引用变量引用到该对象时，垃圾回收器调用此方法来清理该对象的资源。并且，针对某一个对象，垃圾回收器最多只会调用它的finalize()方法一次。</p>
<p>注意，finalize()方法何时调用、是否调用都是不确定的，我们也不要主动调用finalize()方法。从JDK9开始，这个方法被标记为不推荐使用的方法。</p>
<h2 id="说一说hashCode-和equals-的关系"><a href="#说一说hashCode-和equals-的关系" class="headerlink" title="说一说hashCode()和equals()的关系"></a>说一说hashCode()和equals()的关系</h2><p>hashCode()用于获取哈希码（散列码），eauqls()用于比较两个对象是否相等，它们应遵守如下规定：</p>
<ul>
<li>如果两个对象相等，则它们必须有相同的哈希码。</li>
<li>如果两个对象有相同的哈希码，则它们未必相等。</li>
</ul>
<p><strong>扩展阅读</strong><br>在Java中，Set接口代表无序的、元素不可重复的集合，HashSet则是Set接口的典型实现。</p>
<p>当向HashSet中加入一个元素时，它需要判断集合中是否已经包含了这个元素，从而避免重复存储。由于这个判断十分的频繁，所以要讲求效率，绝不能采用遍历集合逐个元素进行比较的方式。实际上，HashSet是通过获取对象的哈希码，以及调用对象的equals()方法来解决这个判断问题的。</p>
<p>HashSet首先会调用对象的hashCode()方法获取其哈希码，并通过哈希码确定该对象在集合中存放的位置。假设这个位置之前已经存了一个对象，则HashSet会调用equals()对两个对象进行比较。若相等则说明对象重复，此时不会保存新加的对象。若不等说明对象不重复，但是它们存储的位置发生了碰撞，此时HashSet会采用链式结构在同一位置保存多个对象，即将新加对象链接到原来对象的之后。之后，再有新添加对象也映射到这个位置时，就需要与这个位置中所有的对象进行equals()比较，若均不相等则将其链到最后一个对象之后。</p>
<h2 id="为什么要重写hashCode-和equals-？"><a href="#为什么要重写hashCode-和equals-？" class="headerlink" title="为什么要重写hashCode()和equals()？"></a>为什么要重写hashCode()和equals()？</h2><p>Object类提供的equals()方法默认是用==来进行比较的，也就是说只有两个对象是同一个对象时，才能返回相等的结果。而实际的业务中，我们通常的需求是，若两个不同的对象它们的内容是相同的，就认为它们相等。鉴于这种情况，Object类中equals()方法的默认实现是没有实用价值的，所以通常都要重写。<br>由于hashCode()与equals()具有联动关系（参考“说一说hashCode()和equals()的关系”一题），所以equals()方法重写时，通常也要将hashCode()进行重写，使得这两个方法始终满足相关的约定。</p>
<h2 id="和equals-有什么区别？"><a href="#和equals-有什么区别？" class="headerlink" title="==和equals()有什么区别？"></a>==和equals()有什么区别？</h2><p>== 运算符：</p>
<ul>
<li>作用于基本数据类型时，是比较两个数值是否相等；</li>
<li>作用于引用数据类型时，是比较两个对象的内存地址是否相同，即判断它们是否为同一个对象；</li>
</ul>
<p>equals()方法：</p>
<ul>
<li>没有重写时，Object默认以 == 来实现，即比较两个对象的内存地址是否相同；</li>
<li>进行重写后，一般会按照对象的内容来进行比较，若两个对象内容相同则认为对象相等，否则认为对象不等。</li>
</ul>
]]></content>
      <categories>
        <category>1-JavaSE基础巩固</category>
      </categories>
  </entry>
  <entry>
    <title>Java环境变量，真的还有必要配吗？</title>
    <url>/2020/10/15/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%E7%9C%9F%E7%9A%84%E8%BF%98%E6%9C%89%E5%BF%85%E8%A6%81%E9%85%8D%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="Java环境变量，真的有必要配吗？"><a href="#Java环境变量，真的有必要配吗？" class="headerlink" title="Java环境变量，真的有必要配吗？"></a>Java环境变量，真的有必要配吗？</h2><p>　　作为年龄上堪称老鸟而技术上却是菜鸟的老菜鸟，为了祖国的编程事业，不惜拿出一个月工资，淘了一台配置稍高的二手笔记本，打算与老笔记本中的撸啊撸片彻底说再见，誓要在新机种开启一番撸啊撸的新事业。当然，撸代码离不开基本的环境搭建，每次新机上手都要百度一堆杂乱的似是而非的环境搭建教程，才勉强把开发环境搭建起来，时间耗费不少，但终是拾人牙慧，生搬硬套，从未能理解深层原理，将其内化吸收形成自己的技术积累；而环境搭建虽然基础，但编程界多少前辈大牛都是从此开始的，千万行代码的撸出也都依赖于此，所以，花时间总结一下，思考一番，确有必要。今天先来讲讲最最基本的<strong>环境变量</strong>，博主度娘无数，收获不小，现分两个方面来探究<strong>环境变量</strong>的问题：一是为什么要配置，二是如何配置。</p>
<h2 id="配置环境变量-Why"><a href="#配置环境变量-Why" class="headerlink" title="配置环境变量:Why?"></a>配置环境变量:Why?</h2><p>　　为了回答为什么的问题，还是先将JDK下载好，然后布衣博主先一步步的试错完毕，然后再跟大家分享正确的姿势。安装JDK首先肯定是去<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle官网</a>下载适合自己的开发版本啦，或许是沉浸在JDK1.7的开发环境中太久了，不看官网不知道，一看尼玛JDK1.9都发布了，可怜布衣博主连JDK1.8长啥样都还没见过呢。伤心三秒，果断下载JDK1.8的版本来尝尝。下面是下载主页的重点内容，相信大家都知道具体操作：</p>
<p>　 <img src="/2020/10/15/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%E7%9C%9F%E7%9A%84%E8%BF%98%E6%9C%89%E5%BF%85%E8%A6%81%E9%85%8D%E5%90%97%EF%BC%9F/1" alt="img"></p>
<p>　<img src="/2020/10/15/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%E7%9C%9F%E7%9A%84%E8%BF%98%E6%9C%89%E5%BF%85%E8%A6%81%E9%85%8D%E5%90%97%EF%BC%9F/1231169-20180317214916299-1964189242.png" alt="img"></p>
<p>　　安装JDK也很简单，先是JDK，然后是JRE,如果要自定义路径，注意两者不要安装在同一个包下面。然后，作为Java开发者，就会按基本套路开始配置起环境变量。如果仅仅是作为一个代码搬运工，百度有一堆环境变量的配置方式，傻瓜也会配置，但要想成为一个高阶一些的码农，在进行一个操作之前，总该知道你干这件事的缘由——为什么要配置环境变量，如果不配置又会怎样？平时看起来只是开发入门的基础操作，深究起来其实并不简单。有人会呵呵一笑很倾城——不配环境变量，我们怎么开发？欸，这样的问题，我只能说，编程这玩意儿，很多时候不动脑子是可以的，但是不动手却不行。布衣博主以前的固有思想也是觉得，配置环境变量是Java开发的固定姿势，可是今天为了深究环境变量这个问题，下载JDK1.8来折腾一番后发现，仅仅是安装好JDK和JRE，<strong>根本用不着配置什么环境变量就可以开发和跑项目了</strong>，这是怎么回事？到环境变量配置页查看，会发现在path的值中有个C:\ProgramData\Oracle\Java\javapath路径值生成，如以下图中展示（注：图例一为Win10系统的环境变量配置界面，和Win7有很大不同）</p>
<p><img src="/2020/10/15/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%E7%9C%9F%E7%9A%84%E8%BF%98%E6%9C%89%E5%BF%85%E8%A6%81%E9%85%8D%E5%90%97%EF%BC%9F/1231169-20180318121337115-1327749370.png" alt="img"></p>
<p><img src="/2020/10/15/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%E7%9C%9F%E7%9A%84%E8%BF%98%E6%9C%89%E5%BF%85%E8%A6%81%E9%85%8D%E5%90%97%EF%BC%9F/1231169-20180318121921514-508139080.png" alt="img"></p>
<p>　　而在映射的路径文件夹中已经存在了可执行的java.exe,这似乎是说明新版JDK（1.8）在安装的时候就已经自动为我们添加好了环境配置。当博主删除该path映射的路径值C:\ProgramData\Oracle\Java\javapath的时候，集成开发环境中的Eclipse/MyEclipse就无法正常打开了，提示需要JDK或JRE,但是IDEA依然能正常使用，恢复之后Eclipse/MyEclipse能够正常使用。接着将JDK1.8卸载，仅保留运行环境JRE，这个时候IDEA少了JDK的支持就无法正常开发使用了，而Eclipse/MyEclipse却依然可以正常使用，这是因为Eclipse/MyEclipse比较例外的是它自己内嵌了Java编译器，对javac没有任何依赖关系,所以Eclipse/Myeclipse其实只需要依赖JRE就可以做开发并编译运行Java文件的，有了JDK只是为了方便查询源码——其实我们不用安装JDK同样可以查看源码，你只要我们的源码包放在任意路径，然后在设置中绑定源码包就可以了，如下图——</p>
<p><img src="/2020/10/15/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%E7%9C%9F%E7%9A%84%E8%BF%98%E6%9C%89%E5%BF%85%E8%A6%81%E9%85%8D%E5%90%97%EF%BC%9F/1231169-20180409112312315-306384893.png" alt="img"></p>
<p>　　接着卸载JRE,这个时候开发工具肯定是没法使用了，关键是在环境变量的Path值C:\ProgramData\Oracle\Java\javapath也消失了，对应路径下的文件也被删除了，这就说明在安装JRE的时候，是会为我们自动配置好环境变量的。环境变量都没配置就成功的布衣博主实在不甘心，卸载了JDK1.8之后又单独安装了JDK1.7继续尝试，安装完成后Path值并没有自动添加，博主也没有主动的去配置任何环境变量，但是打开Eclipse或者Idea等IDE，依然可以正常开发跑项目。尝试至此，似乎证明了长久以来大家配置环境变量只是思维和行为固化后的自以为是，纯粹是多此一举，对日常开发调试并没有卵用。难道，这么多程序员都在信奉了一个错误的认知而且丝毫不觉得有异？</p>
<p>　　要搞解开这个疑惑，还是得搞清楚环境变量到底是干什么的，为什么要配置它。所谓环境变量，其实就是操作系统中用来指定操作系统运行环境的一些参数，比如临时文件夹位置和系统文件夹位置等。当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到环境变量的PATH中指定的路径值去找。也就是说当执行可执行文件找不到位置的时候，就会去PATH中配置的路径去找。这里你可以做个小测试，就是任意位置新建一个哪怕普通文本文件，将其路径配置成环境变量，然后通过cmd命令行输入文件名，都能打开那个文件，这就环境变量的功劳。因此可以设想如果直接在可执行文件所在文件夹取执行，那不就是找得到吗？为了证明，博主先打开cmd执行编译命令javac，返回不是内部或外部命令，当我们切换到JDK的bin目录C:\Program Files\Java\jdk1.8.0_162\bin路径去执行javac命令的时候，就能够成功执行，好像配置了环境变量一样——<img src="/2020/10/15/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%E7%9C%9F%E7%9A%84%E8%BF%98%E6%9C%89%E5%BF%85%E8%A6%81%E9%85%8D%E5%90%97%EF%BC%9F/1231169-20180318133207556-1396963808.png" alt="img"></p>
<p>　　既然可以执行javac，那么我们就在该目录下测试编译一个Java文件。先用记事本编写测试代码 public class Test { public static void main(String[] args) { System.out.println(“博客园 陈本布衣”); } } ，文件名必须和类名保持一致Test.java,然后我们执行编译命令并运行文件——</p>
<p><img src="/2020/10/15/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%E7%9C%9F%E7%9A%84%E8%BF%98%E6%9C%89%E5%BF%85%E8%A6%81%E9%85%8D%E5%90%97%EF%BC%9F/1231169-20180318134335060-1793339583.png" alt="img"></p>
<p>　　可是正常情况下我的Java文件是不可能放在bin目录下的，所以我们接着配置好环境变量，使我们能够在任意目录编译Java文件——</p>
<p><img src="/2020/10/15/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%E7%9C%9F%E7%9A%84%E8%BF%98%E6%9C%89%E5%BF%85%E8%A6%81%E9%85%8D%E5%90%97%EF%BC%9F/1231169-20180318135110770-2087106493.png" alt="img"></p>
<p><img src="/2020/10/15/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%E7%9C%9F%E7%9A%84%E8%BF%98%E6%9C%89%E5%BF%85%E8%A6%81%E9%85%8D%E5%90%97%EF%BC%9F/1231169-20180318140334495-42043158.png" alt="img"></p>
<p>　　配置环境变量的目的似乎达到了，仅仅是为了不用切换到JDK的bin目录就能执行编译命令的方便，可是，现在都是用集成开发环境如idea或eclipse等开发并编译Java程序，如果不是使用命令行javac的方式来编译Java程序，那么，广大的程序员们，你在搭建开发环境的时候，配置环境变量到底是因为什么？</p>
<h2 id="配置环境变量-How"><a href="#配置环境变量-How" class="headerlink" title="配置环境变量:How?"></a>配置环境变量:How?</h2><p>　　欸，本来前文阐述了环境变量的原理后，这里计划该写如何配置了，但是布衣博主在不断尝试之后发现环境变量在Java的开发环境中根本不是必须的配置，所以，这里的How就只能戛然而止了，实在不想多叨叨如何配置那不必要的玩意儿了。当然，或许我前文的尝试和总结很有问题，因为配置了多年环境变量的博主自己一直都还在怀疑上文的尝试是否正确，也<strong>诚心希望各路大神指出阐述中的问题</strong>，共同来探讨环境变量配置的必要性和可用之处，以免误导他人；</p>
<p>作者：<a href="http://grenet.cnblogs.com/">陈本布衣</a></p>
<p>出处：<a href="http://www.cnblogs.com/chenbenbuyi">http://www.cnblogs.com/chenbenbuyi</a></p>
]]></content>
      <categories>
        <category>1-JavaSE基础巩固</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈Java的引用</title>
    <url>/2020/11/18/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E7%9A%84%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="谈Java中的引用"><a href="#谈Java中的引用" class="headerlink" title="谈Java中的引用"></a>谈Java中的引用</h2><p>先上两个面试中经常遇见的问题：</p>
<p>1.给出以下代码执行后的打印输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lll</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        i=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">changeReturn</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(User u)</span></span>&#123;</span><br><span class="line">        u.setAge(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> User <span class="title">changeReturn</span><span class="params">(User u)</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setAge(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">return</span> u=user;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        u.setAge(<span class="number">1</span>);</span><br><span class="line">        change(i);</span><br><span class="line">        change(u);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(u.getAge());</span><br><span class="line">        System.out.println(changeReturn(i));</span><br><span class="line">        System.out.println(changeReturn(u).getAge());</span><br><span class="line">        System.out.println(u.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.说出以下代码执行后的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lll2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            i=<span class="number">3</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            i=<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> User <span class="title">printUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            u.setAge(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            u.setAge(<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            u.setAge(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(print());</span><br><span class="line">        System.out.println(printUser().getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这两种类型的题，乍一看跟标题没什么关系。一个考察java的参数传递，一个考察java的异常。但其实这两个问题的本质，包括标题要讲的==和equals的区别，都与java中的引用息息相关。</p>
<h1 id="一、java中的引用"><a href="#一、java中的引用" class="headerlink" title="一、java中的引用"></a>一、java中的引用</h1><p>引用，是java中一个极其普通，但其实又最容易被人忽略的知识点。我们都知道java中没有指针的概念，取而代之的是封装好的引用。引用的本质，是一个指向对象存储内存地址的数据结构。我们知道java分两种数据类型，基本数据类型和引用数据类型，对于基本数据类型，其赋值一般都是在栈中直接分配，对于下面的语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p> 我们在程序中访问变量i，会直接访问10所在的内存空间。而对于下面的语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>

<p>首先我们要知道，这条语句并不是一个原子操作，其实这里分了三步：</p>
<ol>
<li><p>新建一个引用user</p>
</li>
<li><p>内存中分配空间存储new出来的User对象实例</p>
</li>
<li><p>将引用user指向User对象实例的内存空间</p>
</li>
</ol>
<p>不仅如此，java中new对象的操作还可能遇见指令重排序现象，对于虚拟机而言，1,2,3的执行顺序并不能保证，可以存在1,3,2现象，也就是新建引用后，直接指向要分配给User对象的内存空间，然后再执行User对象的实例化操作。这也是单例模式双重锁无法保证线程安全的原因。</p>
<p>java为何要多此一举，设计一个如此复杂的引用指向对象模式？java在设计之初便规定了8种基本数据类型，对于每种数据类型，其大小有固定的上下范围，便于jvm控制。<strong>而对于引用类型，由于在运行期会不断变化，很难在编译期去判定一个对象的大小。这也是java中数组分配在堆而不是栈的原因</strong>。引用本身只存储对象的内存地址，大小可控。基于此，jvm巧妙的设计出了堆内存区域，<strong>将基本数据类型和引用类型存放于栈中</strong>，<strong>无法预测的数组与对象存放于堆中</strong>。所以针对以上两个变量，i，user。我们在访问i的时候，是直接访问分配在栈中的10的内存空间，而访问user，是访问user所指向的，存储在堆中的User对象实例的内存地址。</p>
<h1 id="二、java方法传递参数的方式"><a href="#二、java方法传递参数的方式" class="headerlink" title="二、java方法传递参数的方式"></a>二、java方法传递参数的方式</h1><p>上面啰里啰嗦说的这些，可能或多或少每个java程序员都接触过。但是深入理解引用和基本数据类型的区别，非常重要。基于此，我们先解决一个java面试中的老大难问题，也就是题目一，java传递参数的方式。</p>
<p>编程语言传递参数通常有两种方式，值传递和引用传递。java采用的是值传递可能很多人都知道，但是如何理解这个值传递？如何解释change(int i)方法跟changeReturn(int i)方法对i变量的操作？</p>
<p>首先记住一点，所谓的值传递，就是把当前变量的值复制一份，传入到一个方法中。如果当前变量是一个基本变量，那么复制变量i的操作等价于复制10这个数字，然后传入复制出的10。对于引用类型也是一样，复制变量user的操作就是在内存中开辟一块空间，将user所指向的内存的地址复制一遍，然后传入复制后的引用。</p>
<p>所以对于方法change(int i)而言，传入的i，与之前main方法中的i，完全是在两块内存中，我们在change(int i)方法中对i进行操作后，改变的是当前i的值，与之前main方法中i的值毫无关系：</p>
<p><img src="/2020/11/18/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E7%9A%84%E5%BC%95%E7%94%A8/1" alt="img"></p>
<p>当然实际栈中执行方法的顺序不是这样的，这里只是简单的描述了一下两块内存中不同的i，这里的复制i也就是change(int i)中的参数i，可以看到两个操作完全是在不同的内存区域操作，所以change(int i)方法并不能改变main方法中i的值。</p>
<p>那么对于引用类型，情况有什么不同呢？与i的操作类似，都是要先复制然后操作：</p>
<p><img src="/2020/11/18/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E7%9A%84%E5%BC%95%E7%94%A8/2" alt="img"></p>
<p>区别非常明显，因为引用中只存储了对象的内存地址，所以change(User  u)和main方法中的user，指向的是一个对象，对这两个引用的任何操作最终都是在一块内存区域中完成的，所以change(User  u)方法可以改变main方法中user的age值。</p>
<p>回过头来，我们继续分析changeReturn(int i)方法，我们已经知道，由于java的采用值传递的传参方式，change(int  i)方法无法改变main方法中的i值，那为何加一个返回值以后，i的值就可以被改变了呢？大家很容易想到，带有返回值后，原先i的值被覆盖掉了。这个覆盖操作是如何完成的？最终的答案，交给编译后的字节码输出解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  descriptor: (I)V</span><br><span class="line">  flags: ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">2</span>: istore_0</span><br><span class="line">       <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">7</span>: <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">changeReturn</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  descriptor: (I)I</span><br><span class="line">  flags: ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">2</span>: istore_0</span><br><span class="line">       <span class="number">3</span>: iload_0</span><br><span class="line">       <span class="number">4</span>: ireturn</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">10</span>: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>通过javap命令输出后的字节码指令，我们可以清晰的看到，changeReturn比change方法多出的iload_0这个指令，以及最终的返回指令，return与ireturn。iload_0用来将当前局部变量表的0位置元素入栈，也就是i，ireturn弹出栈顶元素也就是复制后的i，之后main方法再对i进行操作时，拿到的是新的pop出的内存区域，也就是数据1存放的内存区域：</p>
<p><img src="/2020/11/18/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E7%9A%84%E5%BC%95%E7%94%A8/3" alt="img"></p>
<p>讲到这里大家可以思考一下最后一个方法，changeReturn(User  u)，其实原理是一致的，changeReturn方法中新new出了一个User，那么直接调用changeReturn方法返回的user引用，会使用新的User，但是即便我们在方法中将参数u的引用更新为新地址，由于这个参数u与main方法中的u引用并不是一个引用，所以main方法中的u引用指向的依旧是以前的User对象：</p>
<p><img src="/2020/11/18/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/Java%E7%9A%84%E5%BC%95%E7%94%A8/4" alt="img"></p>
<p>可以看到最终方法执行结束后，main方法中指向的User对象依旧是之前的User对象。</p>
<p>这里插一句题外话，很多面试者不喜欢一些java基础的题目考察，尤其是笔试题。但通过这道题可以充分考察出一个程序员对java内存模型的熟悉程度。很多题目并不是面经能够给你解决的，只有深入了解其背后的原理，才能真的融会贯通。</p>
<h1 id="三、java中的返回与异常"><a href="#三、java中的返回与异常" class="headerlink" title="三、java中的返回与异常"></a>三、java中的返回与异常</h1><p>继续看第二道题，看起来考察的是java中的异常机制，但其实要真的理解发生异常后的返回值，只需要理解两点：</p>
<p>1.java中方法的退出机制。</p>
<p>2.java中引用和基本类型的区别。</p>
<p>首先我们要明白java中对方法的执行，归根结底是jvm对字节码的执行，我们手写的代码，与最终编译后的字节码往往差异很大，所以很多方法执行顺序问题只要我们去看一眼字节码便一目了然。针对第一点，java中方法的退出机制，其实这也是异常体系中一个核心知识点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span><span class="comment">//操作数栈深度只有1，局部变量表长度为3,</span></span><br><span class="line">         <span class="number">0</span>: iconst_1 <span class="comment">//</span></span><br><span class="line">         <span class="number">1</span>: istore_0 <span class="comment">//执行i=1，此时i保存在局部变量表下标为0的位置</span></span><br><span class="line">         <span class="number">2</span>: iconst_2 <span class="comment">//</span></span><br><span class="line">         <span class="number">3</span>: istore_0 <span class="comment">//执行i=2</span></span><br><span class="line">         <span class="number">4</span>: iload_0  <span class="comment">//复制i的值入栈</span></span><br><span class="line">         <span class="number">5</span>: istore_1 <span class="comment">//复制并且保存给当前返回值，注意这里是istore_1而不是istore_0</span></span><br><span class="line">         <span class="number">6</span>: iconst_4 <span class="comment">//</span></span><br><span class="line">         <span class="number">7</span>: istore_0 <span class="comment">//i=4</span></span><br><span class="line">         <span class="number">8</span>: iload_1  <span class="comment">//复制当前位置1的值入栈，也就是上面istore_1保存的值2</span></span><br><span class="line">         <span class="number">9</span>: ireturn  <span class="comment">//返回2</span></span><br><span class="line">        <span class="number">10</span>: astore_1 <span class="comment">//保存一个异常对象到局部变量表1，下面是catch逻辑</span></span><br><span class="line">        <span class="number">11</span>: iconst_3 <span class="comment">//</span></span><br><span class="line">        <span class="number">12</span>: istore_0 <span class="comment">// i=3</span></span><br><span class="line">        <span class="number">13</span>: iconst_4 <span class="comment">//</span></span><br><span class="line">        <span class="number">14</span>: istore_0 <span class="comment">// i=4</span></span><br><span class="line">        <span class="number">15</span>: goto          <span class="number">23</span></span><br><span class="line">        <span class="number">18</span>: astore_2 <span class="comment">//保存一个异常对象局部变量表2，下面执行的是如果catch中无法捕获的异常发生</span></span><br><span class="line">        <span class="number">19</span>: iconst_4 <span class="comment">//</span></span><br><span class="line">        <span class="number">20</span>: istore_0 <span class="comment">//i=4</span></span><br><span class="line">        <span class="number">21</span>: aload_2  <span class="comment">//</span></span><br><span class="line">        <span class="number">22</span>: athrow   <span class="comment">//抛出</span></span><br><span class="line">        <span class="number">23</span>: iload_0 <span class="comment">//此时再加载0位置的值，最后一条istore的值是4</span></span><br><span class="line">        <span class="number">24</span>: ireturn <span class="comment">//返回4</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">2</span>     <span class="number">6</span>    <span class="number">10</span>   Class java/lang/Exception</span><br><span class="line">             <span class="number">2</span>     <span class="number">6</span>    <span class="number">18</span>   any</span><br><span class="line">            <span class="number">10</span>    <span class="number">13</span>    <span class="number">18</span>   any</span><br></pre></td></tr></table></figure>

<p>关于字节码如何阅读，这里暂时不展开讲，可以翻看我之前转载的另一篇博文。通过字节码可以清晰的看到，遇见java中的return语句，jvm会先复制一份当前的返回值，然后进行finally中的操作。由于i代表的是int基本数据类型，这里复制操作复制的是真实的数值，所以finally中对i的操作不会影响当前方法的返回值。</p>
<p>如果这里不是很好理解，大家可以继续去想一下返回值是对象的情况，也就是printUser的字节码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> com.guttv.bms.dao.<span class="function">lll2$User <span class="title">printUser</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()Lcom/guttv/bms/dao/lll2$User;</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: new           #3                  // class com/guttv/bms/dao/lll2$User</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #4                  // Method com/guttv/bms/dao/lll2$User.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">7</span>: astore_0</span><br><span class="line">         <span class="number">8</span>: aload_0</span><br><span class="line">         <span class="number">9</span>: iconst_1</span><br><span class="line">        10: invokevirtual #5                  // Method com/guttv/bms/dao/lll2$User.setAge:(I)V</span><br><span class="line">        <span class="number">13</span>: aload_0</span><br><span class="line">        <span class="number">14</span>: astore_1</span><br><span class="line">        <span class="number">15</span>: aload_0</span><br><span class="line">        <span class="number">16</span>: iconst_3</span><br><span class="line">        17: invokevirtual #5                  // Method com/guttv/bms/dao/lll2$User.setAge:(I)V</span><br><span class="line">        <span class="number">20</span>: aload_1</span><br><span class="line">        <span class="number">21</span>: areturn</span><br><span class="line">        <span class="number">22</span>: astore_1</span><br><span class="line">        <span class="number">23</span>: aload_0</span><br><span class="line">        <span class="number">24</span>: iconst_2</span><br><span class="line">        25: invokevirtual #5                  // Method com/guttv/bms/dao/lll2$User.setAge:(I)V</span><br><span class="line">        <span class="number">28</span>: aload_0</span><br><span class="line">        <span class="number">29</span>: iconst_3</span><br><span class="line">        30: invokevirtual #5                  // Method com/guttv/bms/dao/lll2$User.setAge:(I)V</span><br><span class="line">        <span class="number">33</span>: goto          <span class="number">44</span></span><br><span class="line">        <span class="number">36</span>: astore_2</span><br><span class="line">        <span class="number">37</span>: aload_0</span><br><span class="line">        <span class="number">38</span>: iconst_3</span><br><span class="line">        39: invokevirtual #5                  // Method com/guttv/bms/dao/lll2$User.setAge:(I)V</span><br><span class="line">        <span class="number">42</span>: aload_2</span><br><span class="line">        <span class="number">43</span>: athrow</span><br><span class="line">        <span class="number">44</span>: aload_0</span><br><span class="line">        <span class="number">45</span>: areturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">8</span>    <span class="number">15</span>    <span class="number">22</span>   Class java/lang/Exception</span><br><span class="line">             <span class="number">8</span>    <span class="number">15</span>    <span class="number">36</span>   any</span><br><span class="line">            <span class="number">22</span>    <span class="number">28</span>    <span class="number">36</span>   any</span><br></pre></td></tr></table></figure>

<p>整体流程与print方法类似，遇见return语句时，jvm同样是复制了当前的返回值，但注意这里的返回值是一个引用，jvm进行复制的时候，只是复制了引用的值，也就是对象的内存地址。复制前后的引用都指向一个对象，所以在finally中对user进行操作，依然会修改复制前的user对象，导致最终返回值的变化。</p>
<p>这里做一个简单总结：</p>
<p>1.java中return语句会触发程序复制当前的返回值</p>
<p>2.引用存储的永远都是对象的内存地址，对引用的复制只是对内存地址的复制，并不能复制一个新的对象产生。</p>
<h1 id="四、java中的-与equals"><a href="#四、java中的-与equals" class="headerlink" title="四、java中的==与equals"></a>四、java中的==与equals</h1><p>java中判断两个对象是否相等常用的两个方法就是==与equals，注意hashcode方法由于碰撞冲突的存在，不是一个特别的好的判定方案。equals方法比较简单，他是Object类的一个方法，默认由==实现。java中自带的包装类以及String类等一般都重写了该方法的具体实现。</p>
<p>==比较的是值，如果是基本类型，比较的就是具体的数值。如果是引用类型，比较的是引用的值。由于引用中保存的是对象的内存地址，所以==对两个引用的比较，实际上比较的就是两个引用是否指向同一个对象。</p>
<p>值得注意的是，在重写equals方法的实现时，如果涉及类型比较，要注意getClass方法与instanceof关键字的区别。简单来说，instanceof用来比较类型，getClass用来比较类。假设有如下类关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Son与Girl调用getClass比较返回false，调用instanceof返回true。</p>
<h1 id="五、浅拷贝与深拷贝"><a href="#五、浅拷贝与深拷贝" class="headerlink" title="五、浅拷贝与深拷贝"></a>五、浅拷贝与深拷贝</h1><p>涉及对象引用还有一个常见的问题就是浅拷贝与深拷贝，所谓的浅拷贝，其实就是只拷贝了对象引用，拷贝前后的引用还是指向了同一个内存对象。深拷贝与之对应，是重新开辟了新的内存空间，所以如果想要实现深拷贝，就必须要手动执行new对象的过程。java中Object类的clone方法是一个浅拷贝方法，深拷贝需要自己实现。需要深拷贝的地方必须自行实现对象的创建复制过程。</p>
]]></content>
      <categories>
        <category>1-JavaSE基础巩固</category>
      </categories>
  </entry>
  <entry>
    <title>String s = new String(&quot;abc&quot;);创建了几个字符串对象?</title>
    <url>/2020/11/19/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/String-s-new-String-xyz-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="String-s-new-String（“abc”）创建了几个对象"><a href="#String-s-new-String（“abc”）创建了几个对象" class="headerlink" title="String s=new String（“abc”）创建了几个对象"></a>String s=new String（“abc”）创建了几个对象</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String  s= <span class="string">&quot;Hello &quot;</span>; </span><br><span class="line">s= <span class="string">&quot;Java &quot;</span>; </span><br><span class="line">String  s1= <span class="string">&quot;Hello &quot;</span>; </span><br><span class="line">String  s2=<span class="keyword">new</span>  String( <span class="string">&quot;Hello &quot;</span>); </span><br></pre></td></tr></table></figure>

<p>啊，s所引用的string对象不是被修改了吗？之前所说的不变性，去那里了啊？ </p>
<p>你别着急，让我告诉你说发生了什么事情：<br>在jvm的工作过程中，会创建一片的内存空间专门存入string对象。我们把这片内存空间叫做string池。 </p>
<p>String  s= “Hello “;当jvm看到 “Hello “，在string池创建string对象存储它，并将他的引用返回给s。<br>s= “Java “，当jvm看到 “Java “，在string池创建新的string对象存储它，再把新建的string对象的引用返回给s。而原先的 “Hello “仍然在string池内。没有消失，他是不能被修改的。 </p>
<p>所以我们仅仅是改变了s的引用，而没有改变他所引用的对象，因为string对象的值是不能被修改的。 </p>
<p>String  s1= “Hello “;jvm首先在string池内里面看找不找到字符串 “Hello “,找到,返回他的引用给s1，否则,创建新的string对象，放到string池里。这里由于s= “Hello “了,对象已经被引用，所以依据规则s和s1都是引用同一个对象。所以  s==s1将返回true。(==,对于非基本类型，是比较两引用是否引用内存中的同一个对象) </p>
<p>String  s2=String( “Hello “);jvm首先在string池内里面看找不找到字符串 “Hello “,找到,不做任何事情，否则,创建新的string对象，放到string池里面。由于遇到了new，还会在内存上（不是string池里面）创建string对象存储 “Hello “，并将内存上的（不是string池内的）string对象返回给s2。所以s==s2将返回false，不是引用同一个对象。 </p>
<p>好现在我们看题目：<br>String  s  =  new  String( “abc “);<br>首先在string池内找，找到？不创建string对象，否则创建，  这样就创建了第一个string对象<br>遇到new运算符号了，在内存上创建string对象，并将其返回给s，第二个对象 </p>
<p>所以总共是2个对象 </p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>String s=new String（”abc”）创建了几个对象，有两种情况</p>
<p>  <strong>1.如果常量池中有字符串abc，那么只会在内存中创建一个对象</strong></p>
<p> <strong>2.如果常量池中没有字符串abc，那么在常量池中创建一个内容为abc的对象， 但是遇到了new关键字，</strong></p>
<p> <strong>则还是 会在内存（不是常量池）中创建一个对象，然后将对象返回给引用s， 特别注意s不是一个对象</strong></p>
<p>常量池中内容为abc的对象 + 内存中的new出来的对象，s只是一个引用不是对象</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>要理解这个，就要知道string类的工作原理。下面来慢慢分析一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        String s1&#x3D;&quot;Hello&quot;;</span><br><span class="line"> </span><br><span class="line">        String s2&#x3D;&quot;Hello&quot;;</span><br><span class="line"> </span><br><span class="line">        String s3&#x3D;new String(&quot;Hello&quot;);</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;s1和s2 引用地址是否相同：&quot;+(s1 &#x3D;&#x3D; s2));</span><br><span class="line">        System.out.println(&quot;s1和s2 值是否相同：&quot;+s1.equals(s2));</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;s1和s3 引用地址是否相同：&quot;+(s1 &#x3D;&#x3D; s3));</span><br><span class="line">        System.out.println(&quot;s1和s3 值是否相同：&quot;+s1.equals(s3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p>s1和s2 引用地址是否相同：true<br>s1和s2 值是否相同：true<br>s1和s3 引用地址是否相同：false<br>s1和s3 值是否相同：true</p>
</blockquote>
<p>上面程序中的”==”是判断两个对象引用的地址是否相同，也就是判断是否为同一个对象，s1与s2 返回为true，s1与s3返回则是false。说明s1与s2 引用的同一个对象的地址，s3则与其它两个引用不是同一个对象地址。</p>
<p>原因是Java为了避免产生大量的String对象，设计了一个字符串常量池。工作原理是这样的，创建一个字符串时，JVM首先为检查字符串常量池 中是否有值相等的字符串，如果有，则不再创建，直接返回该字符串的引用地址，若没有，则创建，然后放到字符串常量池中，并返回新创建的字符串的引用地址。 所以上面s1与s2引用地址相同。那为什么s3与s1、s2引用的不是同一个字符串地址呢？ String s3=new String(“Hello”); JVM首先是在字符串常量池中找”Hello” 字符串，如果没有创建字符串常量，然后放到常量池中，若已存在，则不需要创建；当遇到 new 时，还会在内存（不是字符串常量池中）上创建一个新的String对象，存储”Hello”，并将内存上的String对象引用地址返回，所以s3与 s1、s2引用的不是同一个字符串地址。</p>
<p>说到这里，可能有同学会问，放在常量池中会不会存在线程安全的问题？Java的工程师们早就考虑到了，String类是一个不可变对象，其它有两层 意思：一是String类是一个final类，不能产生一个String的子类；二是在String类中提供的所有方法中，如果有String返回值就会 创建一个String对象，不对原对象进行修改，这就保证了原对象不可改变。</p>
<p>了解了String类的工作原理，回归问题本身。</p>
<p>在String的工作原理中，已经提到了，new 一个String对象，是需要先在字符串常量中查找相同值或创建一个字符串常量，然后再在内存中创建一个String对象，所以 String str = new String(“xyz”); 会创建两个对象。</p>
]]></content>
      <categories>
        <category>Java面试准备</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>StringBuffer 和 StringBuilder 的区别</title>
    <url>/2020/11/19/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="StringBuffer-和-StringBuilder-的区别"><a href="#StringBuffer-和-StringBuilder-的区别" class="headerlink" title="StringBuffer 和 StringBuilder 的区别"></a>StringBuffer 和 StringBuilder 的区别</h1><h2 id="StringBuffer-和-StringBuilder-的类结构："><a href="#StringBuffer-和-StringBuilder-的类结构：" class="headerlink" title="StringBuffer 和 StringBuilder 的类结构："></a>StringBuffer 和 StringBuilder 的类结构：</h2><p><img src="/2020/11/19/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB/1" alt="在这里插入图片描述"></p>
<h2 id="区别1：线程安全"><a href="#区别1：线程安全" class="headerlink" title="区别1：线程安全"></a>区别1：线程安全</h2><p>StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 synchronized 修饰。</p>
<p>StringBuffer 代码片段：<br> <img src="/2020/11/19/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB/2" alt="在这里插入图片描述"></p>
<p>StringBuilder 代码片段：<br> <img src="/2020/11/19/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB/3" alt="在这里插入图片描述"></p>
<h2 id="区别2：缓冲区"><a href="#区别2：缓冲区" class="headerlink" title="区别2：缓冲区"></a>区别2：缓冲区</h2><p>StringBuffer 代码片段：<br> <img src="/2020/11/19/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB/4" alt="在这里插入图片描述"></p>
<p>StringBuilder 代码片段：<br> <img src="/2020/11/19/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB/5" alt="在这里插入图片描述"><br> StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。</p>
<p>StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。</p>
<p>所以， StringBuffer 对缓存区优化，不过 StringBuffer 的这个toString 方法仍然是同步的。</p>
<h2 id="区别3：性能"><a href="#区别3：性能" class="headerlink" title="区别3：性能"></a>区别3：性能</h2><p>既然 StringBuffer 是线程安全的，它的所有公开方法都是同步的，StringBuilder 是没有对方法加锁同步的，所以毫无疑问，StringBuilder 的性能要远大于 StringBuffer。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合。</p>
]]></content>
      <categories>
        <category>Java面试准备</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>重写equals(),重写hashcode()</title>
    <url>/2020/11/25/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/%E9%87%8D%E5%86%99equals-%E9%87%8D%E5%86%99hashcode/</url>
    <content><![CDATA[<h1 id="equals与hashcode"><a href="#equals与hashcode" class="headerlink" title="equals与hashcode"></a>equals与hashcode</h1><h2 id="对象存入Hash集合的流程"><a href="#对象存入Hash集合的流程" class="headerlink" title="对象存入Hash集合的流程"></a>对象存入Hash集合的流程</h2><p>为了提高效率，采取重写hashcode方法，先进行hashcode比较，如果不同，那么就没必要在进行equals的比较了，这样就大大减少了equals比较的次数，这对比需要比较的数量很大的效率提高是很明显的，一个很好的例子就是在集合中的使用；</p>
<p>为了理解这个问题，我特意写了一个对象存入Hash集合流程的伪代码 。</p>
<p>这里提前说明一点，hash集合要求存入对象不等，而不是对象的属性不等！  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象存入HashSet，HashMap等hash集合  &#123;</span><br><span class="line">    <span class="comment">//比较 Hashcode()  </span></span><br><span class="line">    <span class="keyword">if</span>（哈希值相等）&#123;</span><br><span class="line">   		 <span class="comment">//比较equals()</span></span><br><span class="line">   		 <span class="keyword">if</span>（equals返回<span class="keyword">true</span>）&#123;</span><br><span class="line">   		 	说明待插入的对象和集合中的一个对象重复了。</span><br><span class="line">   		 	<span class="keyword">return</span> 失败</span><br><span class="line">   		 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   		 	在哈希值对应的索引位置，新建一个链表节点，放入对象。</span><br><span class="line">            <span class="keyword">return</span> 成功</span><br><span class="line">   		 &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    	将对象保存在哈希值对应的索引位置</span><br><span class="line">    	<span class="keyword">return</span> 成功</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h2><p>我们都知道java中的List集合是有序的，因此是可以重复的，而set集合是无序的，因此是不能重复的，那么怎么能保证不能被放入重复的元素呢，但靠equals方法一样比较的话，如果原来集合中以后又10000个元素了，那么放入10001个元素，难道要将前面的所有元素都进行比较，看看是否有重复，欧码噶的，这个效率可想而知，因此hashcode就应遇而生了，java就采用了hash表，利用哈希算法（也叫散列算法），就是将对象数据根据该对象的特征使用特定的算法将其定义到一个地址上，那么在后面定义进来的数据只要看对应的hashcode地址上是否有值，那么就用equals比较，如果没有则直接插入，只要就大大减少了equals的使用次数，执行效率就大大提高了。</p>
<h1 id="object对象重写equals方法时为什么需要重写hashCode方法"><a href="#object对象重写equals方法时为什么需要重写hashCode方法" class="headerlink" title="object对象重写equals方法时为什么需要重写hashCode方法"></a>object对象重写equals方法时为什么需要重写hashCode方法</h1><p>在人的脑海里，两个对象相等，便是equals返回true。</p>
<p>但又因为hash集合的存储结构，会先比较hashCode，默认的hashCode是根据对象的地址。所以两个对象不管是不是equals，他们的hashCode都不同。所以就会在Hash集合中存入重复的元素。（并不是存入同一个对象两次，而是存入了人们觉得equals的两个对象）</p>
<p>在Java语言中，<strong>equals方法在使用时</strong>：</p>
<p>  针对包装对象，比较的是对象的值（包括 boolean，byte，char，short，int，long，float，double）</p>
<p>  针对String对象，比较的也是String的值（因为String内部重写了equals方法和hashCode方法）</p>
<p>  针对其他object对象，比较的是两个对象的引用是否指向同一个内存地址</p>
<p>而当我们重写object对象的equals方法时，同时也要重写hashCode方法，为什么呢？ 首先来看几个定义</p>
<p><strong>hash哈希又称之为散列，用于以常数平均时间执行插入、删除和查找的技术。（对排序不能得到有效的支持）</strong></p>
<p><strong>在对象存储的散列表里面，hashCode用来指定对象存储的内存地址。而equals用来判断对象的引用是否指向同一个地址，也就是判断两个对象的hashCode值是否一致</strong></p>
<p>一般有约定</p>
<blockquote>
<p>hashCode相同时，equals方法一定返回true。</p>
<p>equals方法返回true时，hashCode一定相同。</p>
</blockquote>
<p>举个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Str A = <span class="keyword">new</span> Str(<span class="number">1</span>);</span><br><span class="line">		Str B = <span class="keyword">new</span> Str(<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;对比equals：&quot;</span> + A.equals(B));  <span class="comment">//true</span></span><br><span class="line">		System.out.println(<span class="string">&quot;对比hashCode值&quot;</span> + (A.hashCode() == B.hashCode()));  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">		Set&lt;Str&gt; temp = <span class="keyword">new</span> HashSet&lt;Str&gt;();</span><br><span class="line">		System.out.println(<span class="string">&quot;添加A到HashSet中：&quot;</span> + temp.add(A));  <span class="comment">//true</span></span><br><span class="line">		System.out.println(<span class="string">&quot;添加B到HashSet中：&quot;</span> + temp.add(B));  <span class="comment">//true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Str</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Str</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.val = val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Str str)</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> val == str.val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 如上，重写了Str类的equals方法，却没有重写它的hashCode方法，这就造成了混乱。 </p>
<p>对象A和B的equals方法返回true</p>
<p>但是A和B的hashCode方法返回false</p>
<p>将两个对象添加到HashSet中的时候，由于HashSet默认对比的是hashCode值是否一致，A和B的hashCode值不一致，所以同时添加成功了，这样看，HashSet中就添加进去了两个equals返回true的对象，这和set的设计理念有误差，这就使得系统混乱了。</p>
<p>这也就是说，明明这两个对象是相等的，但是hashCode值不一样，所以当把A添加到HashSet中，而将B作为key去HashSet中查找时，根本查不到A。而A和B明明又是相等的，从而出现错误。给人的直观印象就是：“我要找的明明就是那个相等的对象，它的确也在集合里，但就是查不到”</p>
<p><strong>关于String的hashCode方法</strong></p>
<p>要注意的是，String重写了hashCode方法。这是因为散列表（hash表）操作中费时多的部分就是计算hashCode方法，所以在String类中的hashCode方法包含一个重要的优化：每个String对象内部都存储了它的hashCode值，该值初始为0，但如果hashCode方法被调用，那么这个值就将会被记住，下一次使用的时候可以直接调用出来，而不用再计算一次。之所以能这样实现，是由于String类是不可改变的。所以hashCode值被计算之后也并不会发生变化。</p>
<p>String类的hashCode的实现，简要摘录如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(hash != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> hash;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length(); i++)&#123;</span><br><span class="line">			hash = hash * <span class="number">31</span> + (<span class="keyword">int</span>) charAt(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> hash;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1.使用hashcode方法提前校验，可以避免每一次比对都调用equals方法，提高效率</strong></p>
<p><strong>2.保证是同一个对象，如果重写了equals方法，而没有重写hashcode方法，会出现equals相等的对象，hashcode不相等的情况，重写hashcode方法就是为了避免这种情况的出现。</strong></p>
<p>结合上面可以类推，hash类存储结构（HashSet、HashMap等等）添加元素会有重复性校验，校验的方式就是先取hashCode判断是否相等（找到对应的位置，该位置可能存在多个元素），然后再取equals方法比较（极大缩小比较范围，高效判断），最终判定该存储结构中是否有重复元素。</p>
<p><strong>小总结：</strong></p>
<ul>
<li>hashCode主要用于提升查询效率，来确定在散列结构中对象的存储地址；</li>
<li>重写equals()必须重写hashCode()，二者参与计算的自身属性字段应该相同；</li>
<li>hash类型的存储结构，添加元素重复性校验的标准就是先取hashCode值，后判断equals()；</li>
<li>equals()相等的两个对象，hashcode()一定相等；</li>
<li>反过来：hashcode()不等，一定能推出equals()也不等；</li>
<li>hashcode()相等，equals()可能相等，也可能不等。</li>
</ul>
]]></content>
      <categories>
        <category>Java面试准备</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 使用注意事项</title>
    <url>/2019/11/07/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><p>最好是用命令行来新建文章，否则会报一些奇奇怪怪的错误<br>也就是说，每个文章的开头，都要把标题，时间 等等信息填充好。</p>
<h3 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h3><p>每次 hexo d  之后，并不能立刻在网页中看到 ， 需要等个一两分钟才行。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Gitee</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>网关-ip-内网-外网</title>
    <url>/2020/11/18/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E5%85%B3-ip-%E5%86%85%E7%BD%91-%E5%A4%96%E7%BD%91/</url>
    <content><![CDATA[<p><img src="/2020/11/18/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E5%85%B3-ip-%E5%86%85%E7%BD%91-%E5%A4%96%E7%BD%91/1.png"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>ip</tag>
        <tag>网关</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO插入图片（详细版）</title>
    <url>/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/HEXO%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%EF%BC%88%E8%AF%A6%E7%BB%86%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h1 id="HEXO插入图片（详细版）"><a href="#HEXO插入图片（详细版）" class="headerlink" title="HEXO插入图片（详细版）"></a>HEXO插入图片（详细版）</h1><p>菜鸟一枚，插入图片的时候走了不少弯路，写篇blog记录一下。</p>
<h2 id="第一步：安装插件，在hexo根目录打开Git-Bash-执行"><a href="#第一步：安装插件，在hexo根目录打开Git-Bash-执行" class="headerlink" title="第一步：安装插件，在hexo根目录打开Git Bash,执行"></a>第一步：安装插件，在hexo根目录打开Git Bash,执行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<h2 id="第二步：打开hexo的配置文件-config-yml"><a href="#第二步：打开hexo的配置文件-config-yml" class="headerlink" title="第二步：打开hexo的配置文件_config.yml"></a>第二步：打开hexo的配置文件_config.yml</h2><p>找到 post_asset_folder，把这个选项从false改成true</p>
<h2 id="第三步：修改Js"><a href="#第三步：修改Js" class="headerlink" title="第三步：修改Js"></a>第三步：修改Js</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;node_modules&#x2F;hexo-asset-image&#x2F;index.js</span><br></pre></td></tr></table></figure>

<p>将内容更换为下面的代码<br> （在此感谢Ericam_ 大神：<a href="https://links.jianshu.com/go?to=https://blog.csdn.net/xjm850552586">https://blog.csdn.net/xjm850552586</a>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">var cheerio = require(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="line"><span class="keyword">function</span> getPosition(str, m, i) &#123;</span><br><span class="line">  <span class="built_in">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var version = String(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="keyword">function</span>(data)&#123;</span><br><span class="line">  var config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        var link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)</span><br><span class="line">       var beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, 1) + 1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       var beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, 3) + 1;</span><br><span class="line">    // In hexo 3.1.1, the permalink of <span class="string">&quot;about&quot;</span> page is like <span class="string">&quot;.../about/index.html&quot;</span>.</span><br><span class="line">    var endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + 1;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    var toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(var i = 0; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      var key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      var $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(this).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            // For windows style path, we replace <span class="string">&#x27;\&#x27;</span> to <span class="string">&#x27;/&#x27;</span>.</span><br><span class="line">            var src = $(this).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!/http[s]*.*|\/\/.*/.<span class="built_in">test</span>(src) &amp;&amp;</span><br><span class="line">               !/^\s*\//.<span class="built_in">test</span>(src)) &#123;</span><br><span class="line">              // For <span class="string">&quot;about&quot;</span> page, the first part of <span class="string">&quot;src&quot;</span> can<span class="string">&#x27;t be removed.</span></span><br><span class="line"><span class="string">              // In addition, to support multi-level local directory.</span></span><br><span class="line"><span class="string">              var linkArray = link.split(&#x27;</span>/<span class="string">&#x27;).filter(function(elem)&#123;</span></span><br><span class="line"><span class="string">                return elem != &#x27;</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string">              &#125;);</span></span><br><span class="line"><span class="string">              var srcArray = src.split(&#x27;</span>/<span class="string">&#x27;).filter(function(elem)&#123;</span></span><br><span class="line"><span class="string">                return elem != &#x27;</span><span class="string">&#x27; &amp;&amp; elem != &#x27;</span>.<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">              &#125;);</span></span><br><span class="line"><span class="string">              if(srcArray.length &gt; 1)</span></span><br><span class="line"><span class="string">                srcArray.shift();</span></span><br><span class="line"><span class="string">              src = srcArray.join(&#x27;</span>/<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">              $(this).attr(&#x27;</span>src<span class="string">&#x27;, config.root + link + src);</span></span><br><span class="line"><span class="string">              console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;else&#123;</span></span><br><span class="line"><span class="string">            console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span></span><br><span class="line"><span class="string">            console.info&amp;&amp;console.info($(this));</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;);</span></span><br><span class="line"><span class="string">      data[key] = $.html();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>

<h2 id="第四步：插入图片"><a href="#第四步：插入图片" class="headerlink" title="第四步：插入图片"></a>第四步：插入图片</h2><p>比如hexo new post photo之后<br> 就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，<br> 在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">![这是代替图片的文字，随便写](HEXO插入图片（详细版）/16864484-0ab72eb5148a5cb6.jpeg)</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/HEXO%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%EF%BC%88%E8%AF%A6%E7%BB%86%E7%89%88%EF%BC%89/16864484-0ab72eb5148a5cb6.jpeg" alt="img"></p>
<p>然后就……完事了。</p>
<h2 id="小小的遗憾"><a href="#小小的遗憾" class="headerlink" title="小小的遗憾"></a>小小的遗憾</h2><p>因为Hexo的缘故吧，md文档如果用了上面的方式来插入图片，部署起来是可行的，但是在本地用md编辑器 如Typora 编辑查看的时候，所有的图片都没了，因为这个图片的位置是错的。<br>希望以后可以找到方法来解决这个问题。</p>
<p>解决： 之所以读不到是因为路径没引用对嘛，路径引用对了就行了。直接用Typora编辑，拖入图片的时候，将图片设置为某个特定路径即可。这样Typora本地也是可以读的，部署到服务上时，也是可以看的。Hexo可以自动寻找到合适的图片连接。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-创建相册图库以及相册</title>
    <url>/2020/11/16/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo-%E5%88%9B%E5%BB%BA%E7%9B%B8%E5%86%8C%E5%9B%BE%E5%BA%93%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%86%8C/</url>
    <content><![CDATA[<h1 id="Hexo-创建相册图库以及相册"><a href="#Hexo-创建相册图库以及相册" class="headerlink" title="Hexo-创建相册图库以及相册"></a>Hexo-创建相册图库以及相册</h1><p><img src="/2020/11/16/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo-%E5%88%9B%E5%BB%BA%E7%9B%B8%E5%86%8C%E5%9B%BE%E5%BA%93%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%86%8C/1.png"></p>
<p>一个好的博客，需要音乐，图库和电影等播放的功能，这样才足够有趣！</p>
<ul>
<li>以下设置基于Buttfly主题</li>
</ul>
<h3 id="相册图库"><a href="#相册图库" class="headerlink" title="相册图库"></a>相册图库</h3><p><img src="/2020/11/16/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo-%E5%88%9B%E5%BB%BA%E7%9B%B8%E5%86%8C%E5%9B%BE%E5%BA%93%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%86%8C/%E7%9B%B8%E5%86%8C%E5%9B%BE%E5%BA%93.png"></p>
<p>Gallery相册图库——一个图库集合。</p>
<p>图库页面只是普通的页面，只需要<code>hexo n page xxx</code> 创建我的页面就行</p>
<p>创建完之后，会在根目录/source 下创建以xxx为名的文件夹，里面有一个index.md文件，title为xxx</p>
<p>这个index.md 就是我的图库页面。 这个xxx文件夹就可以放这个页面用到的前端资源。 </p>
<h4 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;gallery-group-main&quot;&gt;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>name：图库名字<br>description：图库描述<br>link：连接到对应相册的地址<br>img-url：图库封面的地址</p>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;gallery-group-main&quot;&gt;</span><br><span class="line">&#123;% galleryGroup &#39;壁纸&#39; &#39;收藏的一些壁纸&#39; &#39;&#x2F;Gallery&#x2F;wallpaper&#39; https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;10&#x2F;T7Mu8Aod3egmC4Q.png %&#125;</span><br><span class="line">&#123;% galleryGroup &#39;漫威&#39; &#39;关于漫威的图片&#39; &#39;&#x2F;Gallery&#x2F;marvel&#39; https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;8t97aVlp4hgyBGu.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup &#39;七七&#39; &#39;超可爱的妹子 Dubess的图集&#39; &#39;&#x2F;Gallery&#x2F;七七&#39;  </span><br><span class="line">Gallery&#x2F;123.jpg %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意图片索引的写法</strong></p>
<p>如果是外链，直接写网址；如果是内链，写图片的路径。  </p>
<p>这里路径需要提一下，Hexo的路径是基于_post 文件夹下的路径的，所以我放在那一层文件子目录，部署之后的url就是相应的路径。</p>
<p><img src="/2020/11/16/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo-%E5%88%9B%E5%BB%BA%E7%9B%B8%E5%86%8C%E5%9B%BE%E5%BA%93%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%86%8C/%E8%B7%AF%E5%BE%84.jpg"></p>
<p>所以若想在index下调用到123.jpg， 需要写的路径为 Gallery/123.jpg</p>
<p>相册的地址是   /Gallery/七七   说明我把七七相册文件夹放在了Gallery文件夹中之中，七七文件夹有一个index.md 是七七相册页面的配置。 七七文件夹放相关的资源。 下文就不重复这个知识了。</p>
<h3 id="Gallery相册（图库的子页面）"><a href="#Gallery相册（图库的子页面）" class="headerlink" title="Gallery相册（图库的子页面）"></a>Gallery相册（图库的子页面）</h3><p><img src="/2020/11/16/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo-%E5%88%9B%E5%BB%BA%E7%9B%B8%E5%86%8C%E5%9B%BE%E5%BA%93%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%86%8C/%E7%9B%B8%E5%86%8C.png" alt="相册"></p>
<p>Gallery相册会自动根据图片长度进行排版，书写方便，与markdown格式一样。可根据需要插入到相应的md。</p>
<p>子页面也是普通的页面，只需要<code>hexo n page xxxxx</code> 创建页面就行，然后将xxxxx文件夹放在合适的目录即可。</p>
<h4 id="写法-1"><a href="#写法-1" class="headerlink" title="写法:"></a>写法:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;Fze9jchtnyJXMHN.jpg)</span><br><span class="line">![](https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;ryLVePaqkYm4TEK.jpg)</span><br><span class="line">![](https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;gEy5Zc1Ai6VuO4N.jpg)</span><br><span class="line">![](234.jpg)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure>
<p>234.jpg 就放在xxxxx文件夹里面即可，可以调用的到。无需像博客那样另外建立文件夹。</p>
<h1 id="Hexo文件索引原理-URL规则"><a href="#Hexo文件索引原理-URL规则" class="headerlink" title="Hexo文件索引原理,URL规则"></a>Hexo文件索引原理,URL规则</h1><ol>
<li><p>Hexo的url路径是基于_post 文件夹下的路径的，所以我放在那一层文件子目录，部署之后的url就是相应的路径。</p>
<p><img src="/2020/11/16/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo-%E5%88%9B%E5%BB%BA%E7%9B%B8%E5%86%8C%E5%9B%BE%E5%BA%93%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%86%8C/%E8%B7%AF%E5%BE%84.jpg"></p>
<p>所以若想在index下调用到123.jpg， 需要写的路径为 Gallery/123.jpg</p>
</li>
<li><p>相册的地址是   /Gallery/七七   说明我把七七相册文件夹放在了Gallery文件夹中之中，七七文件夹有一个index.md 是七七相册页面的配置。 七七文件夹放相关的资源。 比如15.jpg 就放在七七文件夹里面，直接在七七的index中<code>![](15.jpg)</code>可以调用的到。无需像博客那样另外建立文件夹。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客-搜索功能实现</title>
    <url>/2020/11/16/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo%E5%8D%9A%E5%AE%A2-%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="实现Hexo博客的搜索功能"><a href="#实现Hexo博客的搜索功能" class="headerlink" title="实现Hexo博客的搜索功能"></a>实现Hexo博客的搜索功能</h1><p>随着我的博客越来越多，仅仅依靠标签和分类已经难以满足自己和他人快速查看博文的需求，所以今天实现了Hexo博客的搜索功能。</p>
<p>使用这个方法，可以无脑进行配置，最终的博客上方标题栏会自动出现 搜索按钮， 很是完美。</p>
<p><img src="/2020/11/16/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo%E5%8D%9A%E5%AE%A2-%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/11111.png"></p>
<p>需要注意的一点是，只有在GitHub上部署的博客可以正常使用，在Gitee上部署的这种本地搜索功能会有Bug。</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>在自己博客根目录下（如：D:\workspace\hexo），执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<h2 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h2><p>修改根目录下Hexo的_config.yml，在最底部添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<h2 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h2><p>修改主题的配置文件，搜索local_search，修改enable为true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<h2 id="预览效果"><a href="#预览效果" class="headerlink" title="预览效果"></a>预览效果</h2><p>开启本地server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>访问 ：<a href="http://localhost:4000/">http://localhost:4000</a> 即可看到想要的搜索功能</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>安装并配置admin插件</title>
    <url>/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEadmin%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="【hexo】安装并配置admin插件"><a href="#【hexo】安装并配置admin插件" class="headerlink" title="【hexo】安装并配置admin插件"></a>【hexo】安装并配置admin插件</h1><h3 id="1-编写目的"><a href="#1-编写目的" class="headerlink" title="1. 编写目的"></a>1. 编写目的</h3><p>使用hexo-admin插件，方便后台登录管理hexo博客，编写文章。</p>
<h3 id="2-新建项目"><a href="#2-新建项目" class="headerlink" title="2. 新建项目"></a>2. 新建项目</h3><p>为了方便，我们直接使用之前一篇文章介绍新建的项目，当然也可以自己新建一个新的项目，这个并不碍事。</p>
<h3 id="3-安装插件"><a href="#3-安装插件" class="headerlink" title="3. 安装插件"></a>3. 安装插件</h3><ul>
<li>插件地址：<a href="https://github.com/jaredly/hexo-admin">https://github.com/jaredly/hexo-admin</a></li>
<li>安装步骤与github介绍一样，但是对我们而言只有一步。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> npm install --save hexo-admin</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="4-启动项目"><a href="#4-启动项目" class="headerlink" title="4. 启动项目"></a>4. 启动项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> hexo s</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>浏览器访问localhost:4000/admin。<br> 效果如下：<br> <img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEadmin%E6%8F%92%E4%BB%B6/1" alt="在这里插入图片描述"></p>
<h3 id="5-配置admin"><a href="#5-配置admin" class="headerlink" title="5. 配置admin"></a>5. 配置admin</h3><p>为了安全，不能让所有人访问这个地址都能够有admin的权限，我们需要添加用户名与密码，在localhost:4000/admin/网站中点击右上角的settings，然后点击下面的 Setup authentification here 。<br> <img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEadmin%E6%8F%92%E4%BB%B6/2" alt="在这里插入图片描述"><br> 效果如图所示：<br> <img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEadmin%E6%8F%92%E4%BB%B6/3" alt="在这里插入图片描述"><br> 填写好用户名与密码，还有secret。<br> <img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEadmin%E6%8F%92%E4%BB%B6/4" alt="在这里插入图片描述"><br> 然后我们可以看到后面加密后的信息，我们需要复制粘贴到配置文件中去。<br> 如图所示：<br> <img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEadmin%E6%8F%92%E4%BB%B6/5" alt="在这里插入图片描述"><br> 把这些信息全部都复制粘贴到项目的核心配置文件test/_config.yml中，粘贴到最后面即可。<br> 如图：<br> <img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEadmin%E6%8F%92%E4%BB%B6/6" alt="在这里插入图片描述"><br> 保存后重新运行hexo，查看localhost:4000/admin，即可看到效果。<br> <img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEadmin%E6%8F%92%E4%BB%B6/7" alt="在这里插入图片描述"><br> 即跳转到登录界面，需要登录才能拥有admin权限，用户名和密码即我们设定好的，那个看起来像是乱码的密码是加密后的密码。</p>
<h3 id="大功告成！"><a href="#大功告成！" class="headerlink" title="大功告成！"></a>大功告成！</h3>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo生成的页面中嵌入PDF</title>
    <url>/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo%E7%94%9F%E6%88%90%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%B5%8C%E5%85%A5PDF/</url>
    <content><![CDATA[<h2 id="hexo-博客添加pdf-插件"><a href="#hexo-博客添加pdf-插件" class="headerlink" title="hexo 博客添加pdf 插件"></a>hexo 博客添加pdf 插件</h2><p>一、安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-pdf</span><br></pre></td></tr></table></figure>

<p>二、配置</p>
<p>创建 123 页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page 123 </span><br></pre></td></tr></table></figure>


<p>三、编写</p>
<p>在生成的md文件中添加pdf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">外部链接：</span><br><span class="line">&#123;% pdf http:&#x2F;&#x2F;7xov2f.com1.z0.glb.clouddn.com&#x2F;bash_freshman.pdf %&#125;</span><br><span class="line">本地连接：</span><br><span class="line">&#123;% pdf .&#x2F;pdf名字.pdf %&#125;</span><br></pre></td></tr></table></figure>



	<div class="row">
    <embed src="./123.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo页面的属性设置</title>
    <url>/2020/07/27/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="hexo创建各种页面问题"><a href="#hexo创建各种页面问题" class="headerlink" title="hexo创建各种页面问题"></a>hexo创建各种页面问题</h1><p>1，创建一般的文章：hexo new “文章名称”<br> 2，创建”关于我”等页面：hexo new page “about”这里的about要和在主题的_config.yml文件中的menu中进行匹配<br> 如：menu:<br> Home: /<br> Archives: /archives<br> About: /about<br> 那创建关于我的页面：hexo new page “about” 在编辑创建出来的md文件，然后部署就能看到<br> 3，创建友情链接：在主题的配置中：<br> links_title: 友情链接<br> links:<br> CSDN: <a href="https://link.jianshu.com/?t=http://blog.csdn.net/u012900536">http://blog.csdn.net/u012900536</a><br> 4，打赏链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打赏</span><br><span class="line"># reward_comment: 您的支持将鼓励我继续创作！</span><br><span class="line"># wechatpay: &#x2F;images&#x2F;wechat-reward-image.JPG</span><br></pre></td></tr></table></figure>

<p>5，设置网站信息：<br> title: 标题<br> subtitle: 副标题<br> description: 描述<br> author: 作者<br> avatar: /images/图标<br> language: zh-Hans（中文）</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-admin插件windows系统插入图片失败问题解决</title>
    <url>/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo-admin%E6%8F%92%E4%BB%B6windows%E7%B3%BB%E7%BB%9F%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="hexo-admin插件windows系统插入图片失败问题解决，hexo-admin汉化，通过修改源码完美解决，以及插件的一点点优化"><a href="#hexo-admin插件windows系统插入图片失败问题解决，hexo-admin汉化，通过修改源码完美解决，以及插件的一点点优化" class="headerlink" title="hexo-admin插件windows系统插入图片失败问题解决，hexo-admin汉化，通过修改源码完美解决，以及插件的一点点优化"></a>hexo-admin插件windows系统插入图片失败问题解决，hexo-admin汉化，通过修改源码完美解决，以及插件的一点点优化</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本人win10系统，在使用插件时插入图片遇到了图片插入裂图的问题，在网上找了一下教程都无法解决，只有说手动改路径，但是我觉得手动改太麻烦，于是开始翻源码，被我找到了问题所在，顺便根据个人喜好做了一点点修改。文章可能还有很多不足，请大家谅解，欢迎大佬提意见。</p>
<p>附带插件GitHub地址：<a href="https://github.com/jaredly/hexo-admin">hexo-admin</a></p>
<p>文章可能有点长，这代表着我写的详细，时间并没有多少内容，每一步我都写的很详细，简单易懂。</p>
<h2 id="本文使用到的东西"><a href="#本文使用到的东西" class="headerlink" title="本文使用到的东西"></a>本文使用到的东西</h2><ol>
<li>win10电脑</li>
<li>hexo 3.1.0</li>
<li>hexo-admin 2.3.0</li>
</ol>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h2><p>在使用hexo插入图片的时候，我发现插入的 图片显示错误，而且链接有问题，不应该是“’！[upload successful] (\images\pasted-1.png)’”<br> 应该是“’！[upload successful] (/images/pasted-1.png)’”<br> <img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo-admin%E6%8F%92%E4%BB%B6windows%E7%B3%BB%E7%BB%9F%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmV5YV9jb20=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2.问题分析"></a>2.问题分析</h2><p>既然图片链接格式有错，我就手动改了一下链接，发现图片成功显示了，发布之后都可以正常使用。但是不能每次都怎么自己改代码，太麻烦了。后来我赵找到了问题所在。</p>
<h2 id="3-问题解决第一步"><a href="#3-问题解决第一步" class="headerlink" title="3.问题解决第一步"></a>3.问题解决第一步</h2><p>1.打开我们博客的目录的“<code>node_modules</code>”子目录，找到“<code>hexo-admin</code>”快捷方式。<br> <img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo-admin%E6%8F%92%E4%BB%B6windows%E7%B3%BB%E7%BB%9F%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/20191204123835452.png" alt="在这里插入图片描述"><br> 2.双击进入该文件夹，打开“<code>api.js</code>”文件，通过搜索“<code>imagePath</code>”字符找到下图的代码片段，红框内就是我们要改的代码。<br> <img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo-admin%E6%8F%92%E4%BB%B6windows%E7%B3%BB%E7%BB%9F%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/2" alt="在这里插入图片描述"><br> 3.将代码修改为</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">filename = imagePath+<span class="string">&quot;/&quot;</span>+ filename	<span class="comment">//修改点</span></span><br><span class="line"><span class="keyword">var</span> outpath = path.<span class="built_in">join</span>(hexo.source_dir, filename)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dataURI = req.body.data.slice(&#x27;data:image/png;base64,&#x27;.length)</span><br><span class="line"><span class="keyword">var</span> buf = new <span class="type">Buffer</span>(dataURI, &#x27;base64&#x27;)</span><br><span class="line">hexo.log.d(`saving image to $&#123;outpath&#125;`)</span><br><span class="line">fs.writeFile(outpath, buf, function (err) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">  hexo.source.process().then(function () &#123;</span><br><span class="line">    res.done(&#123;</span><br><span class="line">      src: filename,	<span class="comment">//修改点</span></span><br><span class="line">      msg: msg</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-问题解决第二步"><a href="#4-问题解决第二步" class="headerlink" title="4.问题解决第二步"></a>4.问题解决第二步</h2><p>修改代码之后，我们可以看到，生成的已经是正确的图片路径了，但是图片还是加载失败了，我发现是因为图片刚上传上前去，hexo还没来得及让图片链接生效，重新刷新一下界面就可以显示了。</p>
<p>但是不能让我们插入一张图片就刷新一次，我们可以让图片上传后暂停一分钟再显示，所以要修改第二处代码。</p>
<p>1.打开hexo-admin目录下的子目录，找到“bundle.js文件”，并打开它。<br> <img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo-admin%E6%8F%92%E4%BB%B6windows%E7%B3%BB%E7%BB%9F%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/3" alt="在这里插入图片描述"><br> 2.搜索“‘upload’”找到以下代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">uploadImage: function(data, filename)  &#123;<span class="keyword">return</span> post(&#x27;/images/upload&#x27;, &#123;data: data, filename: filename&#125;);&#125;,</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   uploadImage: function(data, filename)  &#123;</span><br><span class="line">	<span class="keyword">var</span> imgJson=post(&#x27;/images/upload&#x27;, &#123;data: data, filename: filename&#125;);</span><br><span class="line">	<span class="keyword">var</span> start = (new <span class="type">Date</span>()).getTime();</span><br><span class="line">	<span class="keyword">while</span>((new <span class="type">Date</span>()).getTime() - start &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> imgJson;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>到这里，图片无法显示的问题完美解决。</p>
<h2 id="5-插件修复-优化（附补丁下载地址）"><a href="#5-插件修复-优化（附补丁下载地址）" class="headerlink" title="5.插件修复+优化（附补丁下载地址）"></a>5.插件修复+优化（附补丁下载地址）</h2><h3 id="5-1优化1：修复了插图失败"><a href="#5-1优化1：修复了插图失败" class="headerlink" title="5.1优化1：修复了插图失败"></a>5.1优化1：修复了插图失败</h3><p>就是如上1-4步骤、修改源码，修复了插图失败bug。</p>
<h3 id="5-2优化2：汉化"><a href="#5-2优化2：汉化" class="headerlink" title="5.2优化2：汉化"></a>5.2优化2：汉化</h3><p>虽然hexo-admin使用起来非常简单，但是作为一个英语学渣，看着英文界面就是不舒服，所以汉化了该插件，爽。<br> <img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo-admin%E6%8F%92%E4%BB%B6windows%E7%B3%BB%E7%BB%9F%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/4" alt="在这里插入图片描述"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo-admin%E6%8F%92%E4%BB%B6windows%E7%B3%BB%E7%BB%9F%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/5" alt="在这里插入图片描述"></p>
<h3 id="5-3优化3：添加按文章存储图片功能（方便管理）"><a href="#5-3优化3：添加按文章存储图片功能（方便管理）" class="headerlink" title="5.3优化3：添加按文章存储图片功能（方便管理）"></a>5.3优化3：添加按文章存储图片功能（方便管理）</h3><p>原本系统默认将图片统一存储在“<code>images</code>”目录下，文章一多，图片数量疯涨，就不容易维护，所以我添加了按文章存储图片的功能，图片将存储在与文章同目录的同名文件夹下。<br> <img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo-admin%E6%8F%92%E4%BB%B6windows%E7%B3%BB%E7%BB%9F%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/6" alt="在这里插入图片描述"><br> 只需要在设置界面，勾选“图片存储在资源目录下”选项即可，取消勾选则将图片存放在hexo-admin定义的存储目录下。<img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo-admin%E6%8F%92%E4%BB%B6windows%E7%B3%BB%E7%BB%9F%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/7" alt="在这里插入图片描述"></p>
<h3 id="5-4优化4：修复了编辑界面预览链接错误bug"><a href="#5-4优化4：修复了编辑界面预览链接错误bug" class="headerlink" title="5.4优化4：修复了编辑界面预览链接错误bug"></a>5.4优化4：修复了编辑界面预览链接错误bug</h3><p>原本“分页”的编辑界面的预览链接是错误的，跳转的页面不正确，这里也修复了一下。<br> <img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo-admin%E6%8F%92%E4%BB%B6windows%E7%B3%BB%E7%BB%9F%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/8" alt="在这里插入图片描述"></p>
<h3 id="5-5优化5：修复了新建分页失败bug"><a href="#5-5优化5：修复了新建分页失败bug" class="headerlink" title="5.5优化5：修复了新建分页失败bug"></a>5.5优化5：修复了新建分页失败bug</h3><p>最初新建分页无法点击确定时会提示如下错误，并且界面没有反应。但是刷新之后可以看到分页是新建成功的，就是有点麻烦，要刷新。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Unhandled</span> rejection <span class="type">TypeError</span>: <span class="type">Cannot</span> read property &#x27;source&#x27; of undefined</span><br><span class="line">    at addIsDraft (<span class="type">G</span>:\blog\node_modules\_hexo-admin@<span class="number">2.3</span>.<span class="number">0</span>@hexo-admin\api.js:<span class="number">14</span>:<span class="number">25</span>)</span><br><span class="line">    at <span class="type">G</span>:\blog\node_modules\_hexo-admin@<span class="number">2.3</span>.<span class="number">0</span>@hexo-admin\api.js:<span class="number">218</span>:<span class="number">18</span></span><br><span class="line">    at tryCatcher (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\util.js:<span class="number">16</span>:<span class="number">23</span>)</span><br><span class="line">    at <span class="type">Promise</span>._settlePromiseFromHandler (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">547</span>:<span class="number">31</span>)</span><br><span class="line">    at <span class="type">Promise</span>._settlePromise (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">604</span>:<span class="number">18</span>)</span><br><span class="line">    at <span class="type">Promise</span>._settlePromise0 (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">649</span>:<span class="number">10</span>)</span><br><span class="line">    at <span class="type">Promise</span>._settlePromises (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">729</span>:<span class="number">18</span>)</span><br><span class="line">    at <span class="type">Promise</span>._fulfill (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">673</span>:<span class="number">18</span>)</span><br><span class="line">    at <span class="type">Promise</span>._resolveCallback (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">466</span>:<span class="number">57</span>)</span><br><span class="line">    at <span class="type">Promise</span>._settlePromiseFromHandler (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">559</span>:<span class="number">17</span>)</span><br><span class="line">    at <span class="type">Promise</span>._settlePromise (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">604</span>:<span class="number">18</span>)</span><br><span class="line">    at <span class="type">Promise</span>._settlePromise0 (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">649</span>:<span class="number">10</span>)</span><br><span class="line">    at <span class="type">Promise</span>._settlePromises (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">725</span>:<span class="number">18</span>)</span><br><span class="line">    at _drainQueueStep (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\async.js:<span class="number">93</span>:<span class="number">12</span>)</span><br><span class="line">    at _drainQueue (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\async.js:<span class="number">86</span>:<span class="number">9</span>)</span><br><span class="line">    at <span class="type">Async</span>._drainQueues (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\async.js:<span class="number">102</span>:<span class="number">5</span>)</span><br><span class="line">    at <span class="type">Immediate</span>.<span class="type">Async</span>.drainQueues [<span class="keyword">as</span> _onImmediate] (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\async.js:<span class="number">15</span>:<span class="number">14</span>)</span><br><span class="line">    at processImmediate (<span class="keyword">internal</span>/timers.js:<span class="number">439</span>:<span class="number">21</span>)</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>

<p>修复之后该功能可以正常使用，但是还是会提示另一个错误，我弄了好久，没办法解决，等待懂的大佬教教我。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Unhandled</span> rejection <span class="type">WarehouseError</span>: <span class="type">ID</span> `source/<span class="number">444444</span>/index.md` has been used</span><br><span class="line">    at new <span class="type">WarehouseError</span> (<span class="type">G</span>:\blog\node_modules\warehouse\lib\error.js:<span class="number">14</span>:<span class="number">11</span>)</span><br><span class="line">    at _Model._insertOne (<span class="type">G</span>:\blog\node_modules\warehouse\lib\model.js:<span class="number">153</span>:<span class="number">29</span>)</span><br><span class="line">    at <span class="type">G</span>:\blog\node_modules\warehouse\lib\model.js:<span class="number">179</span>:<span class="number">63</span></span><br><span class="line">    at tryCatcher (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\util.js:<span class="number">16</span>:<span class="number">23</span>)</span><br><span class="line">    at <span class="type">G</span>:\blog\node_modules\bluebird\js\release\using.js:<span class="number">185</span>:<span class="number">26</span></span><br><span class="line">    at tryCatcher (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\util.js:<span class="number">16</span>:<span class="number">23</span>)</span><br><span class="line">    at <span class="type">Promise</span>._settlePromiseFromHandler (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">547</span>:<span class="number">31</span>)</span><br><span class="line">    at <span class="type">Promise</span>._settlePromise (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">604</span>:<span class="number">18</span>)</span><br><span class="line">    at <span class="type">Promise</span>._settlePromise0 (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">649</span>:<span class="number">10</span>)</span><br><span class="line">    at <span class="type">Promise</span>._settlePromises (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">729</span>:<span class="number">18</span>)</span><br><span class="line">    at <span class="type">Promise</span>._fulfill (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">673</span>:<span class="number">18</span>)</span><br><span class="line">    at <span class="type">PromiseArray</span>._resolve (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise_array.js:<span class="number">127</span>:<span class="number">19</span>)</span><br><span class="line">    at <span class="type">PromiseArray</span>._promiseFulfilled (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise_array.js:<span class="number">145</span>:<span class="number">14</span>)</span><br><span class="line">    at <span class="type">Promise</span>._settlePromise (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">609</span>:<span class="number">26</span>)</span><br><span class="line">    at <span class="type">Promise</span>._settlePromise0 (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">649</span>:<span class="number">10</span>)</span><br><span class="line">    at <span class="type">Promise</span>._settlePromises (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\promise.js:<span class="number">729</span>:<span class="number">18</span>)</span><br><span class="line">    at _drainQueueStep (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\async.js:<span class="number">93</span>:<span class="number">12</span>)</span><br><span class="line">    at _drainQueue (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\async.js:<span class="number">86</span>:<span class="number">9</span>)</span><br><span class="line">    at <span class="type">Async</span>._drainQueues (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\async.js:<span class="number">102</span>:<span class="number">5</span>)</span><br><span class="line">    at <span class="type">Immediate</span>.<span class="type">Async</span>.drainQueues [<span class="keyword">as</span> _onImmediate] (<span class="type">G</span>:\blog\node_modules\bluebird\js\release\async.js:<span class="number">15</span>:<span class="number">14</span>)</span><br><span class="line">    at processImmediate (<span class="keyword">internal</span>/timers.js:<span class="number">439</span>:<span class="number">21</span>)</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>

<h3 id="5-6补丁下载地址"><a href="#5-6补丁下载地址" class="headerlink" title="5.6补丁下载地址"></a>5.6补丁下载地址</h3><p><strong>使用方法</strong><br> 打开博客目录下的“<code>\node_modules\hexo-admin</code>”目录，全选复制所有补丁覆盖原文件即可。</p>
<p><strong>注意</strong><br> 我使用的是<code>hexo-admin 2.3.0</code>版本，其他版本补丁覆盖之后可能会有问题，可能会有问题，没有测试。</p>
<p>如果使用的和我不是同一个版本，建议先卸载插件，然后再重新添加和我同个版本的hexo-admin，这样就不会有问题。</p>
<p>卸载hexo-admin：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-admin –save</span><br></pre></td></tr></table></figure>

<p>重新安装2.3.0版本</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">npm install hexo-admin@<span class="number">2.3</span>.<span class="number">0</span> –save</span><br></pre></td></tr></table></figure>

<p>然后覆盖插件。</p>
<p><strong>下载链接</strong>：链接：<a href="https://pan.baidu.com/s/19nJyISHiUEWc4KgrmrXyuw">https://pan.baidu.com/s/19nJyISHiUEWc4KgrmrXyuw</a><br> 提取码：t3r0</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>弄这个插件耗费我一整天时间，做了一些些优化，目前本人用着还好，没有发现什么问题。有不清楚的地方欢迎评论留言，看到的我都会回复的。本文到此结束，有什么不足的地方请大家不吝指正。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 GitHub Pages + Hexo 來架設個人部落格</title>
    <url>/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="教學-使用-GitHub-Pages-Hexo-來架設個人部落格"><a href="#教學-使用-GitHub-Pages-Hexo-來架設個人部落格" class="headerlink" title="[教學] 使用 GitHub Pages + Hexo 來架設個人部落格"></a>[教學] 使用 GitHub Pages + Hexo 來架設個人部落格</h1><p>​               </p>
<p><a href="https://cdn0-t17.techbang.com/system/attached_images/2019/07/261667/original/f83071ffb726a0af8c3470cea40cde57.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/f83071ffb726a0af8c3470cea40cde57.png" alt="img"></a></p>
<p>如果想要架設自己專屬的部落格該怎麼做呢？大部分的人會利用網路上現有的服務，例如：Blogger、痞客邦、udn部落格等平台上發文；而這類的部落格平台，最大優點就是擁有文章搜尋、文章分類、留言…等一般使用者可能會用到的功能，通通都幫你準備好了，非常方便。</p>
<p>至於缺點呢，就是始終如一或看起來都大同小異的主題介面。另外，有些部落格為了要營利，可能在部落格邊欄和文章內安插廣告；因此接下來就要來介紹如何不靠網路上現有的 Blog 平台，自己架設一個能客製化界面的專屬部落格。</p>
<h1 id="為何使用-GitHub-Pages-來架設-Hexo-部落格？"><a href="#為何使用-GitHub-Pages-來架設-Hexo-部落格？" class="headerlink" title="為何使用 GitHub Pages 來架設 Hexo 部落格？"></a>為何使用 GitHub Pages 來架設 Hexo 部落格？</h1><p>在架設自己的部落格之前，首先必須要先有一個可以放網站的空間！總共有三種方法，第一種是去尋找網路上提供的主機空間，大多數要付費（月費/年費），只有極少數是免費的（但免費的限制都很多）。第二種是自己用 NAS 來架設，這裡也不多贅述；而第三種就是透過 GitHub Pages 來架站，它是完全免費的且架設方法很簡單，不過還是有<a href="https://help.github.com/articles/what-is-github-pages/">以下幾點限制</a>：</p>
<blockquote>
<p>GitHub Pages source repositories have a recommended limit of 1GB . </p>
</blockquote>
<blockquote>
<p>Published GitHub Pages sites may be no larger than 1 GB.</p>
</blockquote>
<blockquote>
<p>GitHub Pages sites have a soft bandwidth limit of 100GB per month.</p>
</blockquote>
<blockquote>
<p>GitHub Pages sites have a soft limit of 10 builds per hour.</p>
</blockquote>
<p>總結上述限制，就是<strong>網站大小不能超過 1 GB</strong>、<strong>網站每月流量不能超過 100 GB</strong>、還有<strong>一小時內的網站更新不得超過 10 次</strong>；這些限制除非是把 GitHub Pages 當圖床、丟影片，或是每天超過幾千幾萬人會瀏覽您的網站，否則對於大部分的人一定來說都夠用。況且 GitHub 是非常著名的軟體原始碼代管服務，網站基本是不會有掛掉、連不上等問題的。</p>
<p>既然這麼方便又免費，那多數的個人網站應該都架在 GitHub Pages 了呀？因此筆者還是要說它唯一的缺點，也就是 <strong>GitHub Pages 只能架設「靜態網站」</strong>。舉例來說，需要連接資料庫的網站（像是要輸入帳號密碼登入的那種頁面），還有也是很受歡迎的個人部落格服務 - Wordpress，也是需要資料庫才能運作，所以上述這些都不適合。</p>
<p>說到使用靜態網站架設部落格的方式，就非 HEXO 莫屬了！HEXO 使用 Node.js 建置，擁有許多免費主題供大家使用；且如果有程式底子的人，透過修改主題框架、加入套件等，就能讓部落格看起來與眾不同。</p>
<h1 id="架設-Hexo-部落格之超簡易教學"><a href="#架設-Hexo-部落格之超簡易教學" class="headerlink" title="架設 Hexo 部落格之超簡易教學"></a>架設 Hexo 部落格之超簡易教學</h1><h2 id="建立-GitHub-Pages-環境"><a href="#建立-GitHub-Pages-環境" class="headerlink" title="建立 GitHub Pages 環境"></a>建立 GitHub Pages 環境</h2><h3 id="gt-註冊-Github-帳號"><a href="#gt-註冊-Github-帳號" class="headerlink" title="-&gt; 註冊 Github 帳號"></a>-&gt; 註冊 Github 帳號</h3><p>GitHub官網：<a href="https://github.com/">https://github.com/</a></p>
<h3 id="gt-建立-Github-Pages"><a href="#gt-建立-Github-Pages" class="headerlink" title="-&gt; 建立 Github Pages"></a>-&gt; 建立 Github Pages</h3><p>靜態網頁的好夥伴：Github Pages，它可以給我們託管在 GitHub 上的靜態網頁。在申請完 Github 帳號之後，點一下畫面中間的 Start a Project。</p>
<p><a href="https://cdn1-t17.techbang.com/system/attached_images/2019/07/260720/original/61e62ab04f869e34bd1395b82731e19b.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/61e62ab04f869e34bd1395b82731e19b.png" alt="img"></a></p>
<p>接著將專案名稱取名為 username.github.io 並按下最下方的 Create repository</p>
<p>註： <strong>username 指的是你的 GitHub 帳號</strong>，在旁邊 Owner 的地方就會顯示你的帳號。例如我的帳號是 xdxd123，那麼專案名稱就取名為 xdxd123.github.io。</p>
<p><a href="https://cdn0-t17.techbang.com/system/attached_images/2019/07/260722/original/6893f5d772893585be564efd54f09583.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/6893f5d772893585be564efd54f09583.png" alt="img"></a></p>
<p>接著進入專案，到 Settings 頁面。</p>
<p><a href="https://cdn2-t17.techbang.com/system/attached_images/2019/07/260723/original/e7da8f0c9e9629465e0f5f4fc3f069c0.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/e7da8f0c9e9629465e0f5f4fc3f069c0.png" alt="img"></a></p>
<p>頁面往下滑，有個 GitHub Pages 設定，點一下 Choose a theme。</p>
<p><a href="https://cdn0-t17.techbang.com/system/attached_images/2019/07/260724/original/c11565101bde07447e8ca2bee0be9582.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/c11565101bde07447e8ca2bee0be9582.png" alt="img"></a></p>
<p>開新分頁後，有好幾個樣板供使用者選擇，這裡直接按下 Select theme。(這時候的樣板只是暫時，之後才會部署自己的 Hexo 部落格上來)</p>
<p><a href="https://cdn1-t17.techbang.com/system/attached_images/2019/07/260725/original/56208f06d870026e9d3837d6b7f382a9.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/56208f06d870026e9d3837d6b7f382a9.png" alt="img"></a></p>
<p>最後在網址列輸入 <a href="https://username.github.io/">https://username.github.io/</a> (username 是自己的 GitHub 帳號)，就能看到自己剛架好的 Github Pages 了唷！</p>
<p><a href="https://cdn1-t17.techbang.com/system/attached_images/2019/07/260726/original/d473d4a00522e4fcf34907b01894a448.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/d473d4a00522e4fcf34907b01894a448.png" alt="img"></a></p>
<h2 id="建立-Hexo-環境"><a href="#建立-Hexo-環境" class="headerlink" title="建立 Hexo 環境"></a>建立 Hexo 環境</h2><h3 id="gt-安裝相關軟體"><a href="#gt-安裝相關軟體" class="headerlink" title="-&gt; 安裝相關軟體"></a>-&gt; 安裝相關軟體</h3><p>目前的樣板只是暫時的，我們的目標是要使用 Hexo 框架來架設部落格，最後才會部署到 GitHub Pages。接下來要建立 Hexo 環境，由於筆者是 Windows 系統，這邊以 Windows 系統來示範安裝和部署，因此需要先安裝以下軟體：</p>
<ol>
<li><a href="https://nodejs.org/en/">Node.js</a></li>
<li><a href="https://git-scm.com/">Git</a></li>
<li><a href="https://notepad-plus-plus.org/download/">Notepad++</a> (文字編輯器，建議安裝；如果使用者有自己習慣使用的文字編輯器則不用裝)</li>
<li><a href="https://apps.apple.com/tw/app/xcode/id497799835?mt=12">Xcode</a> ( Mac 用戶才需要安裝)</li>
</ol>
<h3 id="gt-初始設定"><a href="#gt-初始設定" class="headerlink" title="-&gt; 初始設定"></a>-&gt; 初始設定</h3><p>若都安裝好了，我們可以開啟我們的終端機(命令提示字元)，並輸入以下指令安裝 Hexo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p><a href="https://cdn1-t17.techbang.com/system/attached_images/2019/07/260731/original/9875f1ae9febd27ddee61157dbe719af.png?1562918224"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/1" alt="img"></a></p>
<p>安裝完 Hexo 套件後，我們要在終端機輸入以下指令來初始化 Hexo 部落格 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init name  &#x2F;&#x2F;初始化新的 Hexo，會在當前路徑建立一個叫 name 的資料夾，資料夾名稱可以隨意取，例如「myblog」，那麼指令就是 hexo init myblogcd name  &#x2F;&#x2F;進入您剛剛建立的 name 資料夾當中，cd 是 change directory 的意思npm install  &#x2F;&#x2F;安裝 Hexonpm install hexo-deployer-git --save  &#x2F;&#x2F;安裝 git 部署套件</span><br></pre></td></tr></table></figure>

<p>這樣就完成安裝了唷！</p>
<h3 id="gt-設定部落格相關資訊"><a href="#gt-設定部落格相關資訊" class="headerlink" title="-&gt; 設定部落格相關資訊"></a>-&gt; 設定部落格相關資訊</h3><p>進入剛設定好的 Hexo 資料夾之後(本範例資料夾名稱為 myblog )，先找到 _config.yml 這個檔案，然後對它點右鍵 -&gt; Edit with Notepad++ (或是用自己習慣的文字編輯器打開)。</p>
<p><a href="https://cdn2-t17.techbang.com/system/attached_images/2019/07/260732/original/9fc2d1e17fac835aa3151d70bbd2d997.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/9fc2d1e17fac835aa3151d70bbd2d997.png" alt="img"></a></p>
<p>打開 _config.yml 後，修改第 6~12 行資訊，輸入完記得按下 Ctrl+S 存檔：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 我的部落格  &#x2F;&#x2F;輸入部落格標題subtitle: 一個抒發本人心情的地方  &#x2F;&#x2F;輸入副標題description:  &#x2F;&#x2F;輸入網站描述 keywords:  &#x2F;&#x2F;輸入網站關鍵字(以逗號隔開)，方便 SEO author: 王小明  &#x2F;&#x2F;輸入姓名或暱稱language: zh-TW  &#x2F;&#x2F;輸入您所使用的語言timezone:  &#x2F;&#x2F;留空以使用系統時間</span><br></pre></td></tr></table></figure>

<p><a href="https://cdn2-t17.techbang.com/system/attached_images/2019/07/260733/original/a4bf28579048e804d781b1d25dda37c8.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/a4bf28579048e804d781b1d25dda37c8.png" alt="img"></a></p>
<p>接著第 16 行的地方，url 請換成自己網站的連結 <a href="https://username.github.io/">https://username.github.io/</a> ，username是自己的 GitHub 帳號。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: https:&#x2F;&#x2F;username.github.io&#x2F;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdn0-t17.techbang.com/system/attached_images/2019/07/260742/original/5f656992529e8245a79e6725385cc9f7.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/5f656992529e8245a79e6725385cc9f7.png" alt="img"></a></p>
<p>這樣就初步完成部落格的個人化設定了！</p>
<h3 id="gt-設定部署至-GitHub-的資訊"><a href="#gt-設定部署至-GitHub-的資訊" class="headerlink" title="-&gt; 設定部署至 GitHub 的資訊"></a>-&gt; 設定部署至 GitHub 的資訊</h3><p>接著一樣在 _config.yml，要找到部署至 github 的設定：deploy (在文件的底部)，請輸入以下設定，<strong>repo 的 username 改成自己的 GitHub 帳號</strong>，所以 repo 的連結架構長這樣： <a href="https://github.com/%E8%87%AA%E5%B7%B1%E5%B8%B3%E8%99%9F/%E5%B0%88%E6%A1%88%E5%90%8D%E7%A8%B1.git">https://github.com/自己帳號/專案名稱.git</a> ，輸入完一樣記得按下 Ctrl+S 存檔。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:  type: git  repo: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io.git  branch: master</span><br></pre></td></tr></table></figure>

<p><a href="https://cdn2-t17.techbang.com/system/attached_images/2019/07/260734/original/ffc47200c885d05688795451e8e58e27.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/ffc47200c885d05688795451e8e58e27.png" alt="img"></a></p>
<p>註：至於 _config.yml 在 deploy 的地方，為何預設只有 type 一個項目呢？<strong>這是因為 Hexo 可以部署到很多地方，GitHub 只是其中一個選項，而每個網站的設定值皆不同。</strong>使用者也可以一次部署到多個網站，有興趣者可以參照這個文件教學：<a href="https://hexo.io/zh-tw/docs/one-command-deployment.html">Deployment | Hexo</a>。</p>
<h3 id="gt-部署至-GitHub"><a href="#gt-部署至-GitHub" class="headerlink" title="-&gt; 部署至 GitHub"></a>-&gt; 部署至 GitHub</h3><p>回到終端機，<strong>首先確認終端機的路徑在 myblog 資料夾根目錄下</strong>，並依序輸入以下三個指令：(輸入 hexo d 後會要求登入 GitHub 帳號，如圖所示)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo cl  &#x2F;&#x2F;清除之前建立的靜態檔案，也可以輸入 hexo cleanhexo g  &#x2F;&#x2F;建立靜態檔案，也可以輸入 hexo generatehexo d  &#x2F;&#x2F;部署至 Github Pages，也可以輸入 hexo deploy</span><br></pre></td></tr></table></figure>

<p><a href="https://cdn2-t17.techbang.com/system/attached_images/2019/07/260740/original/f5221b90b385f283395b092c5878b204.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/f5221b90b385f283395b092c5878b204.png" alt="img"></a></p>
<p>這三個缺一不可的指令，就是幫我們把網站自動生成並發佈到 <a href="https://username.github.io/">https://username.github.io</a> 上的指令，完成後就可以打開瀏覽器看看自己網站發布成功的樣子摟！</p>
<p><a href="https://cdn0-t17.techbang.com/system/attached_images/2019/07/260741/original/072bfe3ce60b25a6e7cb3f2e8959bdf8.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/072bfe3ce60b25a6e7cb3f2e8959bdf8.png" alt="img"></a></p>
<p>小結：本次介紹如何安裝 Hexo 環境，包含個人資訊和部署設定，而 Hexo 還能自訂主題、套件等等，玩法非常的多！</p>
<h1 id="附錄：實用教學"><a href="#附錄：實用教學" class="headerlink" title="附錄：實用教學"></a>附錄：實用教學</h1><h2 id="直接在指定資料夾路徑開啟終端機"><a href="#直接在指定資料夾路徑開啟終端機" class="headerlink" title="直接在指定資料夾路徑開啟終端機"></a>直接在指定資料夾路徑開啟終端機</h2><p>在部署時，終端機的路徑在 myblog 資料夾根目錄下才可以輸入指令，除了用 cd 指令，有沒有更輕鬆的方式呢？答案是<strong>直接在該資料夾的路徑列輸入 cmd，按下 enter 後，就會在這個路徑打開命令提示字元。</strong></p>
<p><a href="https://cdn2-t17.techbang.com/system/attached_images/2019/07/260743/original/566a2d9f07baed839dacc729414be21a.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/566a2d9f07baed839dacc729414be21a.png" alt="img"></a></p>
<h2 id="專案名稱和部落格網址的關係"><a href="#專案名稱和部落格網址的關係" class="headerlink" title="專案名稱和部落格網址的關係"></a>專案名稱和部落格網址的關係</h2><p>前面有提到，如果你的帳號叫 <strong>xdxd123</strong>，那麼專案名稱就要叫做 <strong>xdxd123.github.io</strong>，這樣子連到該專案的網址才會是 <a href="https://xdxd123.github.io/">https://xdxd123.github.io/</a> 。那如果專案名稱不是這樣取呢？還有辦法連到這個專案的網站嗎？還是一個 GitHub 帳號只能建立一個部落格？</p>
<p><a href="https://cdn0-t17.techbang.com/system/attached_images/2019/07/260722/original/6893f5d772893585be564efd54f09583.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/6893f5d772893585be564efd54f09583.png" alt="img"></a></p>
<p>關於以上問題，一個 GitHub 帳號可以架設很多個網站；名稱的部分，如果我的名稱不是以 <strong>username.github.io</strong> 為命名，例如我取該專案的名稱為 hello，那麼的網址連結就會是 <a href="https://xdxd123.github.io/hello/">https://xdxd123.github.io/hello/</a> ，也就是在網址尾巴附上專案名稱。</p>
<p>以下做簡單的整理(假設使用者名稱為 <strong>xdxd123</strong>)：</p>
<table>
<thead>
<tr>
<th>專案(repository)名稱</th>
<th>該專案的網址連結</th>
</tr>
</thead>
<tbody><tr>
<td>xdxd123.github.io</td>
<td><a href="https://xdxd123.github.io/">https://xdxd123.github.io/</a></td>
</tr>
<tr>
<td>hello.github.io</td>
<td><a href="https://xdxd123.github.io/hello.github.io/">https://xdxd123.github.io/hello.github.io/</a></td>
</tr>
<tr>
<td>hello</td>
<td><a href="https://xdxd123.github.io/hello/">https://xdxd123.github.io/hello/</a></td>
</tr>
<tr>
<td>project</td>
<td><a href="https://xdxd123.github.io/project/">https://xdxd123.github.io/project/</a>　　　　　(…依此類推)</td>
</tr>
</tbody></table>
<p>要注意的是，假設用專案名稱：<strong>hello</strong> 來建立 Hexo 部落格，記得 Hexo 資料夾根目錄下的 _config.yml 要修改第 16 行和第 17 行，如下圖，否則部署至 GitHub Pages 後會無法正確顯示：</p>
<p><a href="https://cdn2-t17.techbang.com/system/attached_images/2019/07/261695/original/06f228fbb59459252395b1d842f05edf.png"><img src="/2019/11/13/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E4%BE%86%E6%9E%B6%E8%A8%AD%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/06f228fbb59459252395b1d842f05edf.png" alt="img"></a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>推送Hexo博客到码云（Gitee）</title>
    <url>/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E7%A0%81%E4%BA%91%EF%BC%88Gitee%EF%BC%89/</url>
    <content><![CDATA[<h1 id="使用Hexo搭建个人博客并部署到Gitee码云"><a href="#使用Hexo搭建个人博客并部署到Gitee码云" class="headerlink" title="使用Hexo搭建个人博客并部署到Gitee码云"></a>使用Hexo搭建个人博客并部署到Gitee码云</h1><h2 id="1-提前准备"><a href="#1-提前准备" class="headerlink" title="1.提前准备"></a>1.提前准备</h2><ol>
<li>下载Git, 地址: <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li>
</ol>
<p><img src="/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E7%A0%81%E4%BA%91%EF%BC%88Gitee%EF%BC%89/1" alt="在这里插入图片描述"><br> 测试是否安装成功:<br> <img src="/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E7%A0%81%E4%BA%91%EF%BC%88Gitee%EF%BC%89/2" alt="在这里插入图片描述"></p>
<ol>
<li>下载Nodejs, 地址: <a href="https://nodejs.org/en/">https://nodejs.org/en/</a><br> <img src="/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E7%A0%81%E4%BA%91%EF%BC%88Gitee%EF%BC%89/3" alt="在这里插入图片描述"><br> 测试是否安装成功:<br> <img src="/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E7%A0%81%E4%BA%91%EF%BC%88Gitee%EF%BC%89/4" alt="在这里插入图片描述"></li>
</ol>
<h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2.安装Hexo"></a>2.安装Hexo</h2><p>在命令行输入:<br> <code>npm install -g hexo-cli</code></p>
<p>之后新建文件夹:<br> 进入文件夹, 右键打开Git bash, 或者直接在命令行中进入该文件夹目录<br> 演示使用命令行进入文件目录:<br> 新建的文件夹为 hexoblog<br> <img src="/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E7%A0%81%E4%BA%91%EF%BC%88Gitee%EF%BC%89/5" alt="在这里插入图片描述"></p>
<p>之后输入一下命令:<br> <code>hexo init</code><br> 稍等一会儿<br> 之后输入<br> <code>npm install</code></p>
<p>开启博客: <code>hexo s</code><br> 之后开启博客<br> <img src="/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E7%A0%81%E4%BA%91%EF%BC%88Gitee%EF%BC%89/20200807214507294.png" alt="在这里插入图片描述"><br> 访问 <a href="http://localhost:4000/">http://localhost:4000/</a>, 之后Ctrl+C 终止</p>
<h2 id="3-创建新的博客文章"><a href="#3-创建新的博客文章" class="headerlink" title="3.创建新的博客文章"></a>3.创建新的博客文章</h2><p>3.1 在博客目录下, 输入一下命令:<br> <code>hexo n &quot;我的第一篇博客&quot;</code></p>
<p>之后会自动创建一篇名为”我的第一篇博客”的博客, 位置在 博客目录\source_posts 目录下</p>
<p>3.2 使用用MarkDown编辑器进行编辑</p>
<p>3.3 编辑结束</p>
<p><code>hexo clean</code> 进行清理</p>
<p><code>hexo g</code> 进行生成</p>
<p>重新启动 <code>hexo s</code></p>
<h2 id="4-将自己的博客部署到Gitee上"><a href="#4-将自己的博客部署到Gitee上" class="headerlink" title="4. 将自己的博客部署到Gitee上"></a>4. 将自己的博客部署到Gitee上</h2><p>4.1 下载插件 <code>npm install --save hexo-deployer-git</code></p>
<p>4.2 在Gitee上创建新的仓库(注意: <strong>仓库名称</strong>应该和<strong>用户名</strong>相同)</p>
<ol>
<li><p>个人首页, 用户名:<br> <img src="/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E7%A0%81%E4%BA%91%EF%BC%88Gitee%EF%BC%89/20200808163314896.png" alt="在这里插入图片描述"></p>
</li>
<li><p>创建仓库:<br> <img src="/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E7%A0%81%E4%BA%91%EF%BC%88Gitee%EF%BC%89/6" alt="在这里插入图片描述"><br> 说明: 即使仓库名称和用户名不同, 路径一定要相同</p>
</li>
<li><p>开启静态博客(网页)支持</p>
<p>到仓库首页-&gt; 服务-&gt; Gitee Pages<br> <img src="/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E7%A0%81%E4%BA%91%EF%BC%88Gitee%EF%BC%89/7" alt="在这里插入图片描述"><br> <img src="/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E7%A0%81%E4%BA%91%EF%BC%88Gitee%EF%BC%89/8" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>4,3 修改 <strong>_config.yml</strong> 文件内容, 最下方的<strong>deploy</strong>(建议使用 Visiual Studio Code进行修改)<br> <img src="/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E7%A0%81%E4%BA%91%EF%BC%88Gitee%EF%BC%89/9" alt="在这里插入图片描述"></p>
<p>4.4 重新进行编译并提交到仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>之后访问生成的静态网页地址: <a href="https://huihuangshijian.gitee.io/">https://huihuangshijian.gitee.io/</a>, 即可查看自己的个人博客</p>
<p>存在的问题: 我的每次进行 <code>hexo d</code> 提交到仓库后, 需要更新一下静态网站地址, 访问的时候才能够显示提交的内容<br> <img src="/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E7%A0%81%E4%BA%91%EF%BC%88Gitee%EF%BC%89/10" alt="在这里插入图片描述"></p>
<p><strong>Gitee 不能自动部署</strong></p>
<p>Github 自动部署，但是慢。Gitee 多个 pages，很快，但是不能自动部署，得加钱。<br><img src="/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E7%A0%81%E4%BA%91%EF%BC%88Gitee%EF%BC%89/11" alt="img"><br>所以 最好是在面试之前将自己的最新版博客部署到Gitee上去。日常使用部署到GitHub上即可。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Gitee</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>在Hexo中对_posts下的md分类</title>
    <url>/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E5%9C%A8Hexo%E4%B8%AD%E5%AF%B9_posts%E4%B8%8B%E7%9A%84md%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="如何在Hexo中对文章md文件分类？"><a href="#如何在Hexo中对文章md文件分类？" class="headerlink" title="如何在Hexo中对文章md文件分类？"></a>如何在Hexo中对文章md文件分类？</h1><p>Hexo是一个快速、简洁且高效的博客框架，常用在Github Page上部署个人博客。</p>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在默认配置下，我们使用<code>hexo new post [title]</code>会在<code>source/_post/</code>目录下生成对应的markdown文件，而使用<code>hexo g</code>生成的html文件路径是<code>:year/:month/:day/:title.html</code>。当我们写的博客越来越多的时候，会发现，所有文章都是在<code>source/_post/</code>下，查找起来会不大方便，而希望对它进行一个分类，但是在生成的文章链接上保持不变。</p>
<p>生成的文章名字及其对应永久链接，可以在<code>_config.yml</code>中配置，分别是<code>new_post_name: :title.md # File name of new posts</code>和<code>permalink: :year/:month/:day/:title/</code>这两项。我们把<code>new_post_name</code>的值改为<code>:year/:title.md</code>，让每次运行<code>hexo new post [title]</code>时新建的文件按年份存放，但是却发现生成的html文件的链接也变了，比如<code>source/_post/2018/test.md</code>对应的博客地址，原本应该是<code>2018/12/22/test/</code>，现在却变成了<code>2018/12/22/2018/test/</code>。也就是，配置中的<code>permalink</code>值里的<code>:title</code>，实际取的不是<strong>文件名称</strong>，而是相对于<code>source/_post</code>的<strong>相对路径</strong>（不含后缀）。<br> 这可能是个Bug，因为在<code>permalink</code>和<code>new_post_name</code>中，用的是同一个变量<code>:title</code>，但是它们的值却是不同的。</p>
<h2 id="按照文件的类型手动分类。"><a href="#按照文件的类型手动分类。" class="headerlink" title="按照文件的类型手动分类。"></a>按照文件的类型手动分类。</h2><p>不是给文章内容内加标签的方式，我希望是可以在source源目录中就对各个文章的分类分别放到不同文件夹</p>
<p>其实md文件存储位置，和最终展现成html是没有关系的，想放到post的哪个目录下面，就可以放到哪个目录下面</p>
<p>可以手动进行文档分类，就是将md文件放到_post文件夹下不同的categories文件夹下，hexo g的时候，还是能够生成的。但是如果使用hexo new命令来创建的话，还是没有找到自动放到对应categories文件夹的方法。</p>
<h2 id="按照年月日进行分类"><a href="#按照年月日进行分类" class="headerlink" title="按照年月日进行分类"></a>按照年月日进行分类</h2><p>如果我们是按年月日归档，而链接保持不变，大可配置为如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:title</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>但是这样的分类太细了，别说一天写不了几篇，一个月我也不会写太多。我只想生成的文章按年份分文件夹，其他保持不变。所以在<code>_config.yml</code>中是要修改配置为如下的：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">new_post_name:</span> <span class="string">:year/:title</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>而文章的链接，一番搜索之后，发现可以在我们文章的markdown文件的<code>Front-matter</code>中添加<code>permalink</code>参数，来指定文章的链接（见 <a href="https://hexo.io/docs/permalinks.html#comment-2657776966">https://hexo.io/docs/permalinks.html#comment-2657776966</a> ）。如果我们在<code>_config.yml</code>中的<code>permalink</code>配置为如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>那最终生成的文章的链接就是<code>:year/:month/:day/:文章中的permalink/</code>。这完全就是我想要的！</p>
<h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>接下来，修改文章模版，增加 <code>permalink</code>一项就好了。文章的模版在<code>scaffolds/post.md</code>，内容修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">permalink: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>

<p>而我们使用<code>hexo new post [title]</code>创建文章的时候，应注意把标题里的空格换为<code>-</code>。</p>
<h2 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h2><p>现在新建文章的路径我们是已经处理好了，那以前创建的文章是不是要一个个手动分类并打开添加<code>permalink</code>参数呢？<br> 当然不用那么麻烦。作为终端控，这种事使用命令行来完成最好了。思路为：</p>
<ol>
<li>找出2018年的文章</li>
<li>移动到<code>2018</code>文件夹下</li>
<li>使用<code>sed</code>命令批量修改文件内容</li>
<li>找出2017年的文章，按1-3步的方式处理……</li>
</ol>
<p>需要注意的是，mac下的<code>sed</code>命令在替换文件上与ubuntu上有所不同。比如我想在<code>title:</code>开头的这一行下面添加内容，ubuntu下的命令为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &quot;/title:.* /a\\xxx&quot; $file</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>在mac下，需要换行，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &quot;&quot; &quot;/title.*/ a\ </span><br><span class="line">xxx</span><br><span class="line">&quot; $file</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>上面的<code>a\</code>，反斜杠后要加一个空格，最后的双引号也是要换一行的。<br> 另外要注意的是，<code>sed</code>会修改文章的创建时间，所以我们需要先分类，再修改。以整理2018年的文章为例，完整命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入_post目录</span></span><br><span class="line">cd source/_post</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一个2018年1月1日的文件，用于过滤出2018年的文章</span></span><br><span class="line">touch -t 201801010000 timestamp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建2018文件夹</span></span><br><span class="line">mkdir 2018</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将2018年的文章移到2018文件夹下</span></span><br><span class="line">for file in `find . -type f -newer timestamp`; do mv $file 2018 ; done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除刚才创建的用于过滤的文件</span></span><br><span class="line">rm timestamp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入2018文件夹</span></span><br><span class="line">cd 2018</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改文章内容，添加permalink</span></span><br><span class="line">for file in `ls`; do link=`echo $file|sed -n &#x27;s/\.md//p&#x27;`; sed -i &quot;&quot; &quot;/title.*/ a\ </span><br><span class="line">permalink: $link</span><br><span class="line">&quot; $file; done;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 回到_post</span></span><br><span class="line">cd ..</span><br><span class="line">123456789101112131415161718</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>上面提到，<code>sed</code>和<code>mv</code>会导致文件的创建时间改变，所以需要先分类再修改。尽管这样，当看到所有文件的创建时间都变成一样了之后，对于有强迫症的我还是觉得看着别扭。好在发现，<code>touch</code>命令也可以用于修改文件的创建时间。所以前面的操作可以优化一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入_post目录</span></span><br><span class="line">cd source/_post</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改文章内容，添加permalink</span></span><br><span class="line">for file in `ls`; do link=`echo $file|sed -n &#x27;s/\.md//p&#x27;`; sed -i &quot;&quot; &quot;/title.*/ a\ </span><br><span class="line">permalink: $link</span><br><span class="line">&quot; $file; done;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改文章的创建时间为Front-matter中的时间</span></span><br><span class="line">for file in `find . -type f`; do d=`head $file|sed -n &#x27;s/^date: //p&#x27; |sed -n &#x27;s/[- :]//pg&#x27; |sed -n &#x27;s/\([0-9]\&#123;2\&#125;\)$/\.\1/p&#x27;`; echo $d ; done;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一个2018年1月1日的文件，用于过滤出2018年的文章</span></span><br><span class="line">touch -t 201801010000 timestamp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建2018文件夹</span></span><br><span class="line">mkdir 2018</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将2018年的文章移到2018文件夹下</span></span><br><span class="line">for file in `find . -type f -newer timestamp`; do mv $file 2018 ; done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将timestamp创建时间修改为2017年1月1日，然后参考2018年文章归类方法，这里略</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 完成归类之后删除刚才创建的用于过滤的文件</span></span><br><span class="line">rm timestamp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后如果想再恢复文章的创建时间，再执行第三步命令</span></span><br><span class="line">for file in `find . -type f`; do d=`head $file|sed -n &#x27;s/^date: //p&#x27; |sed -n &#x27;s/[- :]//pg&#x27; |sed -n &#x27;s/\([0-9]\&#123;2\&#125;\)$/\.\1/p&#x27;`; echo $d ; done;</span><br><span class="line">12345678910111213141516171819202122232425</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Word中Tab的缩进量设置</title>
    <url>/2020/11/16/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/Word%E4%B8%ADTab%E7%9A%84%E7%BC%A9%E8%BF%9B%E9%87%8F%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="有时候我会碰到Tab键不灵的情况，"><a href="#有时候我会碰到Tab键不灵的情况，" class="headerlink" title="有时候我会碰到Tab键不灵的情况，"></a>有时候我会碰到Tab键不灵的情况，</h3><h3 id="实际上是设置了Tab的缩进量为0-设置回2字符即可。"><a href="#实际上是设置了Tab的缩进量为0-设置回2字符即可。" class="headerlink" title="实际上是设置了Tab的缩进量为0. 设置回2字符即可。"></a>实际上是设置了Tab的缩进量为0. 设置回2字符即可。</h3><p><img src="/2020/11/16/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/Word%E4%B8%ADTab%E7%9A%84%E7%BC%A9%E8%BF%9B%E9%87%8F%E8%AE%BE%E7%BD%AE/tab.png"></p>
]]></content>
      <categories>
        <category>Office办公技巧</category>
      </categories>
      <tags>
        <tag>Word</tag>
        <tag>Office</tag>
      </tags>
  </entry>
  <entry>
    <title>更新Hexo时遇到的问题</title>
    <url>/2020/11/07/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/%E6%9B%B4%E6%96%B0Hexo%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>部署Hexo时遇到的问题</p>
<h3 id="每次更新博客之后的推送方式"><a href="#每次更新博客之后的推送方式" class="headerlink" title="每次更新博客之后的推送方式."></a>每次更新博客之后的推送方式.</h3><p>hexo g  生成静态文件,</p>
<p>hexo d  部署到github上.</p>
<p>注意, 如果md文件是手动创建的,则需要在头部添加标题和日期等信息.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 部署Hexo时遇到的问题</span><br><span class="line">date:  2020年4月8日21:58:31</span><br><span class="line">type:  &quot;Hexo教程&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>


<p>英文冒号和值之间要有<strong>空格</strong>, 下面要用<strong>—</strong> 来与正文分隔.</p>
<p>包括_config.yml 中的 属性和值之间也要有空格来分隔. 否则会报错.</p>
<h3 id="使用Github-SSH-Key来避免Hexo部署时输入账户密码"><a href="#使用Github-SSH-Key来避免Hexo部署时输入账户密码" class="headerlink" title="使用Github SSH Key来避免Hexo部署时输入账户密码"></a>使用Github SSH Key来避免Hexo部署时输入账户密码</h3><p>当我用hexo d 时, 总会要在cmd中输入GitHub的账户名和密码,推送较为麻烦, 之前的GitHub项目明明都设置好了ssh 可以免密推送,为什么这里不行呢? 下面是解决方案.</p>
<h5 id="操作-修改-config-yml，将部署方式从https方式修改为ssh方式。注意-repository-属性的值"><a href="#操作-修改-config-yml，将部署方式从https方式修改为ssh方式。注意-repository-属性的值" class="headerlink" title="操作 修改_config.yml，将部署方式从https方式修改为ssh方式。注意 repository 属性的值."></a>操作 修改_config.yml，将部署方式从https方式修改为ssh方式。注意 repository 属性的值.</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;ZhangHao0810&#x2F;ZhangHao0810.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:ZhangHao0810&#x2F;ZhangHao0810.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h2 id="hexo-d命令报错-ERROR-Deployer-not-found-git"><a href="#hexo-d命令报错-ERROR-Deployer-not-found-git" class="headerlink" title="hexo d命令报错 ERROR Deployer not found: git"></a>hexo d命令报错 ERROR Deployer not found: git</h2><p>已经在站点配置文件中写入了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:   # Github pages地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>但是执行，hexo d报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure>

<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>这是因为没安装hexo-deployer-git插件，在站点目录下输入下面的插件安装就好了：</p>
<p>npm install hexo-deployer-git –save</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后在使用Hexo -d命令就可以推送了。</p>
<h2 id="hexo博客搭建时图片无法正常显示的问题"><a href="#hexo博客搭建时图片无法正常显示的问题" class="headerlink" title="hexo博客搭建时图片无法正常显示的问题"></a>hexo博客搭建时图片无法正常显示的问题</h2><p>最近在GitHub Pages中搭建了hexo博客，并且使用了主题，当使用文字博客或者外链图片时没有什么问题，但是使用内置图片却出现了问题，在此记录下来。<br>hexo-asset-image无法在新版本使用</p>
<p>当发布新文章时，我使用了hexo-asset-image这个插件，这个插件需要在_config.yml中设置<code>post_asset_folder=true</code>才能开启，并且需要安装插件，安装方法为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>外网太慢, 使用cnpm来安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>使用该插件后新建文章hexo new  “测试文章”，就会在post文件夹生成同名的文件夹，该文件夹为存放图片的文件夹，然后再在文章里使用markdown的引用图片的方式进行引用，在使用hexo generate后，生成的html文件会自动的加上图片的绝对路径。</p>
<p>但是这中方法在hexo3.0之后貌似无法使用，目前我用的hexo版本为4.2，也是无法使用的，生成的链接类似：</p>
<p>/.ml//logo.jpg</p>
<p>导致在网页上无法显示<br>修改方法</p>
<p>第一种修改方法为通过hexo自带的图片标签，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详见hexo官方对资源文件夹的说明,官方也明确提到了，如果使用markdown的语法，图片可能不会正常显示。</p>
<p>第二种修改方法时是通过修改hexo-asset-image这个插件的源代码来实现的，找到路径node_modules\hexo-asset-image\index.js,替换其中的内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var cheerio &#x3D; require(&#39;cheerio&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;14480345&#x2F;how-to-get-the-nth-occurrence-in-a-string</span><br><span class="line">function getPosition(str, m, i) &#123;</span><br><span class="line">  return str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var version &#x3D; String(hexo.version).split(&#39;.&#39;);</span><br><span class="line">hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;</span><br><span class="line">  var config &#x3D; hexo.config;</span><br><span class="line">  if(config.post_asset_folder)&#123;</span><br><span class="line">    	var link &#x3D; data.permalink;</span><br><span class="line">	if(version.length &gt; 0 &amp;&amp; Number(version[0]) &#x3D;&#x3D; 3)</span><br><span class="line">	   var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 1) + 1;</span><br><span class="line">	else</span><br><span class="line">	   var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 3) + 1;</span><br><span class="line">	&#x2F;&#x2F; In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;...&#x2F;about&#x2F;index.html&quot;.</span><br><span class="line">	var endPos &#x3D; link.lastIndexOf(&#39;&#x2F;&#39;) + 1;</span><br><span class="line">    link &#x3D; link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    var toprocess &#x3D; [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];</span><br><span class="line">    for(var i &#x3D; 0; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      var key &#x3D; toprocess[i];</span><br><span class="line"> </span><br><span class="line">      var $ &#x3D; cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: false,</span><br><span class="line">        xmlMode: false,</span><br><span class="line">        lowerCaseTags: false,</span><br><span class="line">        decodeEntities: false</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(&#39;img&#39;).each(function()&#123;</span><br><span class="line">		if ($(this).attr(&#39;src&#39;))&#123;</span><br><span class="line">			&#x2F;&#x2F; For windows style path, we replace &#39;\&#39; to &#39;&#x2F;&#39;.</span><br><span class="line">			var src &#x3D; $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;&#x2F;&#39;);</span><br><span class="line">			if(!&#x2F;http[s]*.*|\&#x2F;\&#x2F;.*&#x2F;.test(src) &amp;&amp;</span><br><span class="line">			   !&#x2F;^\s*\&#x2F;&#x2F;.test(src)) &#123;</span><br><span class="line">			  &#x2F;&#x2F; For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.</span><br><span class="line">			  &#x2F;&#x2F; In addition, to support multi-level local directory.</span><br><span class="line">			  var linkArray &#x3D; link.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class="line">				return elem !&#x3D; &#39;&#39;;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  var srcArray &#x3D; src.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class="line">				return elem !&#x3D; &#39;&#39; &amp;&amp; elem !&#x3D; &#39;.&#39;;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  if(srcArray.length &gt; 1)</span><br><span class="line">				srcArray.shift();</span><br><span class="line">			  src &#x3D; srcArray.join(&#39;&#x2F;&#39;);</span><br><span class="line">			  $(this).attr(&#39;src&#39;, config.root + link + src);</span><br><span class="line">			  console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span><br><span class="line">			console.info&amp;&amp;console.info($(this));</span><br><span class="line">		&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] &#x3D; $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当我使用插件时,推送到网络之后,图片依然无法显示, 查看图片的链接, 其中出现了child  </p>
<p><a href="https://zhanghao0810.github.io/child/2020/04/11/ceshi/20190410220553413.jpg">https://zhanghao0810.github.io/child/2020/04/11/ceshi/20190410220553413.jpg</a></p>
<p><a href="https://zhanghao0810.github.io/2020/04/11/ceshi/20190410220553413.jpg%E6%89%8D%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%9C%B0%E5%9D%80">https://zhanghao0810.github.io/2020/04/11/ceshi/20190410220553413.jpg才是正确的地址</a>.</p>
<p>所以不能链接到正确的图片地址.</p>
<p>修改方式, 将_config.yml 这里出现了child 尝试将url后面原来带的child去了,url改成自己的url 奇迹般的可以了.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL&#96;</span><br><span class="line">&#96;If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;&#96;</span><br><span class="line">&#96;url: http:&#x2F;&#x2F;ZhangHao.com&#x2F;&#96;</span><br><span class="line">&#96;root: &#x2F;</span><br></pre></td></tr></table></figure>

<p>这样是可以的. 利用了hexo提供的规范. 但是在本地MarkDown看不到图片,不方便. </p>
<h2 id="Hexo启动页面显示extends-includes-layout-pug-block-content-include-includes-recent-posts-pug-include"><a href="#Hexo启动页面显示extends-includes-layout-pug-block-content-include-includes-recent-posts-pug-include" class="headerlink" title="Hexo启动页面显示extends includes/layout.pug block content include includes/recent-posts.pug include"></a>Hexo启动页面显示extends includes/layout.pug block content include includes/recent-posts.pug include</h2><p>Hexo更改主题后启动服务器，界面显如下字符:</p>
<p>extends includes/layout.pug block content include includes/recent-posts.pug include includes/partial</p>
<p>解决方案:</p>
<p>执行如下命令</p>
<blockquote>
<p>npm install –save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive </p>
</blockquote>
<p>清除缓存<br>hexo clean</p>
<p>生成静态文件,推送即可<br>hexo g<br>hexo d </p>
<h3 id="Node-js版本的问题。"><a href="#Node-js版本的问题。" class="headerlink" title="Node.js版本的问题。"></a>Node.js版本的问题。</h3><p>12.14即可。</p>
<h3 id="YAMLException-end-of-the-stream-or-a-document-separator-is-expected-at-line-6-column-1"><a href="#YAMLException-end-of-the-stream-or-a-document-separator-is-expected-at-line-6-column-1" class="headerlink" title="YAMLException: end of the stream or a document separator is expected at line 6, column 1"></a>YAMLException: end of the stream or a document separator is expected at line 6, column 1</h3><p>找找  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------- </span><br></pre></td></tr></table></figure>

<p>的后面有没有 空格， 必须加上一个空格才行。 </p>
<p><strong>还有 生成文件的时候， 最好是用  hexo new “title” 而不要直接拖一个md过来。</strong></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何比较两个word文档的差异？</title>
    <url>/2021/11/13/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAWord%E6%96%87%E6%A1%A3%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<p>在平常的学习或工作中，有时我们需要对同一篇文章进行多次修改，或者不同人对同一篇文章进行修改，修改的次数多了，难免会杂乱。有没有简单的方法进行比较两个word文档的差异呢？其实新版本的（07以上）word都可以进行对比的。</p>
<p><img src="/2021/11/13/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAWord%E6%96%87%E6%A1%A3%E7%9A%84%E5%B7%AE%E5%BC%82/58021a0148fe1e4265975f64c2299a8838130351.jpg" alt="如何比较两个word文档的差异"></p>
<h2 id="工具-原料"><a href="#工具-原料" class="headerlink" title="工具/原料"></a>工具/原料</h2><ul>
<li><p>一台正常运行的电脑<br></p>
</li>
<li><p>安装有Microsoft Office 2007及以上的版本<br></p>

</li>
</ul>
<h2 id="方法-步骤"><a href="#方法-步骤" class="headerlink" title="方法/步骤"></a>方法/步骤</h2><ol>
<li>本文暂以word 2013为例。首先打开Word，切换到“审阅”选项卡下，找到“比较”，如下图所示：</li>
</ol>
<p>   <img src="/2021/11/13/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAWord%E6%96%87%E6%A1%A3%E7%9A%84%E5%B7%AE%E5%BC%82/9bc92713e8e5ecee9240e59acc704618deda7a51.jpg" alt="如何比较两个word文档的差异"></p>
<ol start="2">
<li>点击“比较”，下拉菜单会出现两个选项，分别是“比较（比较文档的两个版本）”和“合并（将多位作者的修订组合到一个文档中）”如图所示，这里我选择的是“比较”；</li>
</ol>
<p>   <img src="/2021/11/13/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAWord%E6%96%87%E6%A1%A3%E7%9A%84%E5%B7%AE%E5%BC%82/4759c1dae43b3b8644dd14e2185653bbf9207551.jpg" alt="如何比较两个word文档的差异"></p>
<ol start="3">
<li>点击“比较文档的两个版本”后，会弹出一个“比较文档”的窗口，分别点击两个打开文件的图标，如下图所示，选择好要进行比较的两个文档；</li>
</ol>
<p>   <img src="/2021/11/13/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAWord%E6%96%87%E6%A1%A3%E7%9A%84%E5%B7%AE%E5%BC%82/52fae62064fb960b7cdd5ed48fa355e982ae6c51.jpg" alt="如何比较两个word文档的差异"></p>
<ol start="4">
<li>选择好文档后，可以点击下方的“更多”，详细选择比较项目，如下图所示；</li>
</ol>
<p>   <img src="/2021/11/13/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAWord%E6%96%87%E6%A1%A3%E7%9A%84%E5%B7%AE%E5%BC%82/05e24be983aee8d70ad6b85a6b781431deb66651.jpg" alt="如何比较两个word文档的差异"></p>
<ol start="5">
<li>选择好以后，点击“确定”，软件就会自动对文档进行对比，对比完成后，就会在一个新的窗口给出详细的对比结果，分四部分显示，分别是“修订”、“比较的文档”、“原文档”和“修订的文档”，如下图所示：</li>
</ol>
<p>   <img src="/2021/11/13/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAWord%E6%96%87%E6%A1%A3%E7%9A%84%E5%B7%AE%E5%BC%82/1570c1b6326c5766c33359e6a4632385e1366151.jpg" alt="如何比较两个word文档的差异"></p>
<ol start="6">
<li>如此，我们就可以轻而易举的看出两个word文档的差异之处了。</li>
</ol>
]]></content>
      <categories>
        <category>Word</category>
      </categories>
      <tags>
        <tag>Word</tag>
      </tags>
  </entry>
  <entry>
    <title>word文章中快速样式-标题2345-等找不到了怎么办</title>
    <url>/2020/11/16/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/word%E6%96%87%E7%AB%A0%E4%B8%AD%E5%BF%AB%E9%80%9F%E6%A0%B7%E5%BC%8F-%E6%A0%87%E9%A2%982345-%E7%AD%89%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<h2 id="word快速样式中的标题2标题3不见了怎么办"><a href="#word快速样式中的标题2标题3不见了怎么办" class="headerlink" title="word快速样式中的标题2标题3不见了怎么办"></a>word快速样式中的标题2标题3不见了怎么办</h2><p>一般情况下word快速样式中默认的有标题1，标题2，标题3和标题4，如果某一天你发现快速样式中的标题2和标题3，或是其他任意格式不见了，应该如何找回呢？请看下文。</p>
<p><img src="/2020/11/16/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/word%E6%96%87%E7%AB%A0%E4%B8%AD%E5%BF%AB%E9%80%9F%E6%A0%B7%E5%BC%8F-%E6%A0%87%E9%A2%982345-%E7%AD%89%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/0.png"></p>
<h2 id="方法-步骤"><a href="#方法-步骤" class="headerlink" title="方法/步骤"></a>方法/步骤</h2><ol>
<li>打开word，在开始菜单下的工具栏中找到样式，然后点击图示的下拉箭头。<br><img src="/2020/11/16/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/word%E6%96%87%E7%AB%A0%E4%B8%AD%E5%BF%AB%E9%80%9F%E6%A0%B7%E5%BC%8F-%E6%A0%87%E9%A2%982345-%E7%AD%89%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/1.png"></li>
</ol>
<ol start="2">
<li><p>展开快速样式以后，在窗口中看到并没有标题2和标题3，但是在word编辑过程中需要使用这两种快速样式，应该怎么办呢？继续看下文。<br><img src="/2020/11/16/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/word%E6%96%87%E7%AB%A0%E4%B8%AD%E5%BF%AB%E9%80%9F%E6%A0%B7%E5%BC%8F-%E6%A0%87%E9%A2%982345-%E7%AD%89%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/2.png"></p>
</li>
<li><p>点击样式栏右下方图示位置的箭头符号。</p>
<p><img src="/2020/11/16/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/word%E6%96%87%E7%AB%A0%E4%B8%AD%E5%BF%AB%E9%80%9F%E6%A0%B7%E5%BC%8F-%E6%A0%87%E9%A2%982345-%E7%AD%89%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/3.png"></p>
</li>
<li><p>点击之后会出现下图的样式窗口，在样式窗口底部点击管理样式图标，如图所示。</p>
<p><img src="/2020/11/16/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/word%E6%96%87%E7%AB%A0%E4%B8%AD%E5%BF%AB%E9%80%9F%E6%A0%B7%E5%BC%8F-%E6%A0%87%E9%A2%982345-%E7%AD%89%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/4.png"></p>
</li>
<li><p>这时，弹出管理样式的设置页面，在该页面上方的菜单中点击【推荐】选项卡，然后在图示位置找到并选中标题2，接着点击下方的【显示】按钮。</p>
<p><img src="/2020/11/16/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/word%E6%96%87%E7%AB%A0%E4%B8%AD%E5%BF%AB%E9%80%9F%E6%A0%B7%E5%BC%8F-%E6%A0%87%E9%A2%982345-%E7%AD%89%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/5.png"></p>
</li>
<li><p>这样标题2的状态就变成了显示了，按同样的方法对标题3进行显示设置操作，设置好之后点击窗口下方的【确定】。</p>
<p><img src="/2020/11/16/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/word%E6%96%87%E7%AB%A0%E4%B8%AD%E5%BF%AB%E9%80%9F%E6%A0%B7%E5%BC%8F-%E6%A0%87%E9%A2%982345-%E7%AD%89%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/6.png"></p>
</li>
<li><p>点击确定后样式管理窗口消失，我们发现在工具栏的样式中标题2和标题3显示出来了，设置成功。</p>
<p><img src="/2020/11/16/Office%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/word%E6%96%87%E7%AB%A0%E4%B8%AD%E5%BF%AB%E9%80%9F%E6%A0%B7%E5%BC%8F-%E6%A0%87%E9%A2%982345-%E7%AD%89%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/7.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Office办公技巧</category>
      </categories>
      <tags>
        <tag>Word</tag>
        <tag>Office</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎 关于双非计算机硕士毕业问题</title>
    <url>/2020/11/19/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/%E7%9F%A5%E4%B9%8E-%E5%85%B3%E4%BA%8E%E5%8F%8C%E9%9D%9E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%95%E5%A3%AB%E6%AF%95%E4%B8%9A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>作者：匿名用户<br> 链接：<a href="https://www.zhihu.com/question/268886169/answer/785486610">https://www.zhihu.com/question/268886169/answer/785486610</a><br> 来源：知乎<br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>说说我吧，一个反例，双非软件工程渣硕，真实状况，大家参考，入坑请谨慎。</p>
<p>20190812</p>
<p>软件工程专业，双非本科，考研调剂双非硕士，19年6月毕业的我已经离开学校2个多月了，现在的我，在一家软件外包公司的银行驻场，今天下午工作时间，没有什么工作内容，也无心学习，在搜知乎搜索“硕士 外包”关键字，发现这个问题，勉强答一下。现在的我慌的一塌糊涂，想改变。</p>
<p>18年夏天没有什么工作经验出来实习，也是比较难找实习工作。最后在一个B轮互联网公司的运营部门实习了不到半年，但我是计算机专业的，很想搞开发，所以没有想到后面找工作的痛苦，就离开公司回学校了。</p>
<p>18年12月回了学校，赶快开始写毕业论文，做实验，想着写完论文就一门心思找工作。19年2月底，过完年到了学校终于基本完成了论文，开始春招。</p>
<p>2月底开始面试，主要在学校所在的城市（北方某二线城市）投简历，互联网公司不多，自己一心想找开发类、机器学习类、数据分析类工作，无奈没有很好的经验，面试准备的也不是很足，所以就基本不是很满意。后来找到了一个半国企性质的公司做机器学习类的工作，但一个组三个人，也是刚孵化的项目，本来很犹豫，不是很想去。</p>
<p>但是这个时候，刚刚写完论文初稿正在找工作的我，收到了相处一年多的女朋友的分手消息。多次挽留无效，就选择开始工作，让自己忙起来忘记她。于是去了学校当地那个半国企的公司，去了那里状态也不是很好，领导也是一个30多的单身老直男。实习干了两个月，里面很多都是当地硕士实习生，问了几个人都不想呆在这个地方，还有几个刚来的也是说春招实在找不到工作了，于是选择了这个公司。公司里干的活有点像做课题然后向国家申请经费的这种感觉，死气沉沉，技术提升可能不是很大。加之上面提到的那位直男领导的折磨（其实就领导两个人；工作需求讲不清，问他具体需求，又让我自己好好想想，发挥我的主观能动性，说他太忙，不要用这些小事烦他；但我自己有时候做出来了，又嫌我做的和他想的不一样，因此我觉得连沟通都沟通不了的领导，可能不是很好的选择。加之他有一天因为需求的事，当众和我大吵，我也跟他怼了一句，事后另一个组的同事都和我说，你们领导也太奇葩了吧。之后没有几天，他说可能之后得给我降薪，我说我考虑考虑，后来我就表明同意了他的要求，但我已经做好了离开的准备。一个写工作邮件还在写此致 敬礼这样的小学生术语的直男领导，是我不可战胜的恐惧），我选择离开了，4月中旬重新投简历，想换个地方工作，离开那座城市，因为回忆太多。</p>
<p>4月底来到帝都，去了软件行业一家有名的外包公司面试，和面试官聊了之后，觉得基本符合预期，说做数据挖掘等数据类相关工作，也用python，而我比较喜欢python开发，我预期薪资13k，面试的时候也基本同意。后来为了等这家公司的offer，后来三天又去了4、5家公司面试，有的不符合期望，有的不符合要求。过了3天，那个外包公司发来了offer，说给月薪10.5k（说到这里，还有一个插曲：在刚刚面试完这家外包公司时，上午面试，下午公司打电话来说，只能给12k，我基本同意了，后来发offer时又打电话说，只能给10.5k，这个时候稍微感觉这个公司有点不靠谱，和网上大家的评价差不多，不过想着面试官描述的工作内容自己基本喜欢，也就同意了），拿了offer就回学校准备毕业论文和答辩了，当时感觉，稍微松了一口气，从18年暑假算起，帝都和学校来回折腾快一年了。</p>
<p>之后就是6月毕业了，还差几天拿毕业证的我，响应公司的号召，赶紧先去公司实习了，是外派银行的项目，实习到7月1号签转正合同。结果来了工作的银行，工作内容是银行数据的ETL，主要写一些sql和存储过程，然后可能写一点perl脚步做跑批任务，根本不是数据挖掘，也不是python工作，和我想的python数据挖掘或者互联网后端工作基本不同，技术方向不同，技术也比较落后（可能好多细节还不是实习这半个月了解的，可能有一些细节是最近一段时间试用期了解到的）。想到如果在这里呆着，之后跳槽可能也不是很容易，因此有一些犹豫。</p>
<p>7月1号，伟大的我党的生日当天，我很犹豫地去了公司总部去签正式劳动合同，毕竟薪资也没有达到预期，工作内容也比较简单重复，提升不大。签合同时，看到劳动合同上写着12k，稍微有一点点意外，就凑合签了。第二天人事打电话过来说，合同签错了，多了1.5k，让我把合同退回去，我这个时候态度稍微强硬了一点，毕竟合同已经生效，所以就半推不就的不是很情愿，后来人事消停了。签合同第三天，中午吃饭时间（我们项目组几个人每天一起吃饭），我的项目经理接到一个微信后，突然问我要不要户口，说可能会解决（而我瞥了一眼，打电话的人是4月份我的面试官，也就是现在我驻场银行的总领导）。我看到这种情况，心里想可能是他们的上面套路吧，就说不需要。过了几天，后来那位面试官来找了我一次，说工资可能是弄错了，应该是10.5k，然后我说了句当时说了12k呀，然后他说可能是我们这边出了一点问题，但我给你找找人事吧，不行就12k吧，但说让我快速成长，多学习工作内容，他会注意我的，意思就是工作不要偷懒。然后后来就没有找我了，7月试用期的工资也是按12k的80%发的。</p>
<p>故事到了八月吧，基本也就是10多天前，我项目经理说，我得换到另一个项目组，因为那个项目组平时需求多，能养得起人。我说可以不换吗，他说*总（当时的面试官）不同意。现在我就被换到另一个项目组了，前几天从一个准备辞职的同事那里交接了一些工作，也是一些sql语句和一些重复的固化的工作流程，没有什么技术含量，就连sql逻辑都不用多想，因为项目组的模型工程师才是做sql逻辑的，ETL工程师也就改成sql语句，测试一下，然后进行数据的抽取和下发给下游系统。今天新的这个项目组的项目经理跟我说，让我明天工位换另一边，明天开始干活。</p>
<p>现在的我吧，毕业这一年经历这么多（可能也不算什么，大家都这么过来的？）心情极其复杂，干着自己不太满意的工作，就怕工作几年没有什么提升，技术老套跟不上互联网发展的步伐，过几年跳槽没有合适的工作机会，想到未来很是担忧。且身边的同事没有见过硕士，很多都不是计算机专业的，不少都是其他专业培训之后来的，感觉自己身边的同事也不牛x，自己也不能有很好的提升（没有歧视的意思哈，大家慎喷，我就单纯说一下事实，因为我也就一个渣硕）。还有一个比较熟的同事，还感觉自己现在的工作挺好的。他是体育大学毕业的，后来it培训后来的现在的公司，我跟他聊：工作就是一些不用想逻辑的sql语句，也不用一门编程语言，但他的意思是，感觉还挺好，天天乐呵呵，因此我就和他感觉灵魂里没有共同话题，其实稍微有一点鄙视他（从未来的发展和工作中的成长来说，他人挺好的，不是贬低他的意思，见谅）</p>
<p>上周五到今天在招聘网站，投了几十个python开发类的简历，现在还没有一个回复。我这一个应届毕业没有什么项目经验的渣硕，还要和20届的实习生竞争，还要和工作两年的有经验的工程师竞争，基本丧失应届生身份的我，感觉现在前途不太明朗。</p>
<p>（刚刚收到一个笔试通知邮件，今天晚上回去撸两道题，求过）</p>
<p>好了，先这样，现在我坐在甲方银行狭窄且不固定不能联外网的工位上，现在我想去男生都需要排队的甲方厕所里去静静，好好想想我这一个渣硕这是什么造型啊，这一年我都经历了什么，各方面不太如意吧。写了这么多，突然发现要下班了，可耻:(</p>
<p>知乎人均985，人均年薪100w，我双非渣硕可耻的匿了吧，严重拉低了贵乎计算机硕士的水平。</p>
<p>更新一下 20190813</p>
<p>昨天晚上做完了一套公司的面试题，可以查资料，但涉及面很广，python高级内容也不少，还有linux相对不是很容易搜索到的题目，到凌晨1:30才做完发了邮件。今天周二，连续两天凌晨两点入睡了，困。今天还是没有什么工作内容，下午还是挺烦，所以来更新一下。</p>
<p>这么多年，不知道是我心高气傲还是能力有限，总感觉自己学习工作的身边没有牛人共事，就是那种自己打心里佩服的人。</p>
<p>高考分数本来可以去一个比自己本科学校好一点的学校，结果因为不懂招生规则，最后补录进了一所当地学生在二本线附近就可以上的学校，这是第一次感觉自己身边没有牛人。</p>
<p>所以在本科学校努力学习，以后遇到一些牛人，本科期间绩点成绩专业第一，但是当时不是很懂保研，有可能是自卑，感觉我们这样的破学校没有什么保研资格，结果保研就被第二名轻松反超。</p>
<p>后来说，想考研，遇到一些优秀的人。所以抓住大四最后的几个月时间，努力复习，目标是一所帝都某211院校的计算机专业。通过笔试无奈面试与帝都这所学校失之交臂，有笔试比我成绩低但成功入学的同届考生的消息也是让我感觉既自卑又自负吧。</p>
<p>随后调剂来到研究生的双非大学，再次感觉到身边没有什么很优秀的人，很多人都是大部分同学都来自二本甚至三本学校，并且很多人都说自己本科学习不好，没有拿过奖学金，就是大四学了一年考的研，还有一些同学根本不是我同专业的，也没有很好的规划，因此再次感觉自己很失败，还是没有遇到什么优秀的人。当然我承认，比起贵乎人均常青藤海龟，我就是个渣硕，就是差到掉渣的那种。</p>
<p>现在从事的工作，也是银行的外包，身边的同事更是哪里的都有，瞬间开始更加怀疑自己了，始终身边没有优秀的人。现在的同事中，有非计算机专业培训来的，有计算机相关专业的本科，咱也不敢问有没有研究生毕业的。像这样的外包公司，除了我这一个渣硕，也没有人会选择来这工作吧。</p>
<p>20多年了，挫败感很强，感觉中考、高考、研究生、工作，从小到大，贯穿始终，没有一件自己很满意，很有成就感的事，也没有好的运气遇到一些共事的牛人以求自勉。现在自己的状态就是，看不上身边的同事，自己又达不到很高的水平，好迷茫吧应该是。</p>
<p>也可能是我这个人性格使然？一直以来，娱乐也不能尽兴，总担心自己如果像别人那么肆无忌惮的玩耍会负罪感太强，常常使自己有一定的压力，但有时候方向不太对，干着急，学习也不能很好的坚持一个方向，所以面试就是涉猎多但不精通。</p>
<p>现在看着一些同事们互相还聊的挺开心，不知道他们有没有我这样类似的烦恼，但我最近基本不想和其他同事交流，既看不上自己又看不上别人，我究竟是一种什么样的存在。</p>
<p>一直体会不到别人在人生某次重大选择过程中，突然感觉好幸运的那种感觉：差一点就进不来了这所学校了，或者差一点就进不来这个公司了，就是那种既满足自己期望又幸运的感觉。</p>
<p>说了这么多，负能量挺高，希望大家以我为戒，不要成为我这样一个被自己嫌弃的人吧。</p>
<p>20190821</p>
<p>看到一句话，供大家欣赏：</p>
<p>什么时候出国读书、什么时候决定做第一份职业、何时选定了对象而恋爱、什么时候结婚，其实都是命运的巨变。只是当时站在三岔路口，眼见风云千樯，你作出抉择的那一日，在日记上，相当沉闷和平凡，当时还以为是生命中普通的一天。</p>
<p>20190826</p>
<p>愿你有好运，如果没有，</p>
<p>希望你在慈悲中学会坚强；</p>
<p>愿有很多人爱你，如果没有，</p>
<p>希望你在寂寞中学会宽容。</p>
<p>《愿你慢慢长大》</p>
]]></content>
      <categories>
        <category>职业规划</category>
      </categories>
      <tags>
        <tag>知乎</tag>
        <tag>职业规划</tag>
      </tags>
  </entry>
  <entry>
    <title>NuoMiShe项目</title>
    <url>/2021/09/19/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/NuoMiShe%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p><img src="/2021/09/19/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/NuoMiShe%E9%A1%B9%E7%9B%AE/0-703-16322076988011.jpg" alt="0-703"></p>
<h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>九月开始不到两周，在秋招如火如荼的刚刚展开时，我就拿到了几家企业的Offer，压力从月初小了许多。</p>
<p>为了强化我的技术能力，不要虚度了这最后的学生时光，故给自己找了这样的一个需求，在日常浏览本机的图片和视频的时候，偶尔会发现Windows自带的资源管理器不够美观和方便，故思考可否做一个BS的文件管理系统，用以漂亮的查看本地的资源。</p>
<p>为了达成这个目标，在2021年9月中旬我便开始行动了。</p>
<h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><p>前端：Bootstrap 4.6 + Thymeleaf 模板引擎</p>
<p>后端：Spring Boot，Spring + Spring MVC + Mybatis</p>
<p>数据库：MySQL 5.7 </p>
<h1 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h1><p>糯米社服务器端不存储静态文件，而是读取本地文件，在浏览器展示，故无需承担任何资源方面的奉献，只是作为一个辅助工具来使用。</p>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><h2 id="用户状态管理（User-Management）"><a href="#用户状态管理（User-Management）" class="headerlink" title="用户状态管理（User Management）"></a>用户状态管理（User Management）</h2><p>【】用户的注册，登录，注销<br>【】用户权限管理（管理员，Vip，游客）<br>【】用户状态管理，拦截器，Session<br>【】统一异常处理，统一返回带参数的404模板页</p>
<h2 id="文件夹管理（Page-Management）"><a href="#文件夹管理（Page-Management）" class="headerlink" title="文件夹管理（Page  Management）"></a>文件夹管理（Page  Management）</h2><p><strong>读一个文件夹 的 逻辑  以页 Page 为主，每页表示一个静态路径下的内容，分类罗列内容</strong> </p>
<p>【】展示一页信息，每页包括：文件夹 ， 图片， 视频 ， 文本<br>【】返回上级页面<br>【】进入下级页面（点击文件夹，进入该文件夹页）<br>【】修改某文件的名称<br>【】删除某页选定的元素（包括文件夹和文件）<br>【】侧栏遍历展示所有文件夹目录<br>【】支持移动选定元素到指定目录</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1>]]></content>
      <categories>
        <category>我的项目</category>
      </categories>
  </entry>
  <entry>
    <title>Quicker 一个极大简化操作的工具</title>
    <url>/2021/03/15/%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7/%E4%B8%80%E4%B8%AA%E6%9E%81%E5%A4%A7%E7%AE%80%E5%8C%96%E6%93%8D%E4%BD%9C%E7%9A%84%E5%B7%A5%E5%85%B7Quicker/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>早上起来登录 英文网站，准备听一下Standard VOA ，突然想到如果可以将每天学习到的英文整理到博客上，那会更利于学习，但是新建一个博客，调整等等操作虽然也不用一分钟，但属实麻烦，达不到想就写的程度，内心便有了一点点的抵触心理。我发现这种懒惰心理会造成未来博客书写的阻碍。为了不就这么放弃我的博客，便有了接下来的探索。</p>
<p>使用Hexo来写博客，操作比较复杂， 每次都要hexo n ，然后去到文件夹里面打开md文件，进行书写，结束之后查看还要hexo g部署，hexo s 手动启动。安装了图片插件之后，图片的上传也比较复杂。我想能不能有一个好的一站式管理方案，简化我的博客书写，让这个过程是简单又愉悦的。</p>
<h1 id="hexo-admin插件的尝试"><a href="#hexo-admin插件的尝试" class="headerlink" title="hexo-admin插件的尝试"></a>hexo-admin插件的尝试</h1><p>之前我就有搜集和书写过一个关于hexo插件的博客，hexo-admin ， 但因自己比较不上心，就一直拖着没有部署。今天正好有这个机会 便按照之前的博客配置了admin，刚开始还是很顺利的，但遇到了一个麻烦的问题，就是图片无法很好的上传，直接的可视化是我很想要的，可是hexo-admin并没有达到预期。而且图片上传什么的也比较慢。为此我搜了很多内容，致力于修改整个插件的细节。但是最终的效果并不那么好。半上午就这么过去了。 </p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>这个插件可以给我很大的帮助，比如在新建博客，可视化编辑，一键部署方面都很有用。</p>
<p>但是图片的这个问题使我不得不重新寻找方案。 重新审视自己的需求。</p>
<p>需求1：可视化的新建文章 直接输入标题即可。</p>
<p>需求2：一键 构建，一键部署，一键启动等等我想要的操作都一键完成。</p>
<p>需求3：便捷且可视化的图片插入方式。</p>
<p>需求4：博客书写过程要流畅，清爽。专注。</p>
<p>中午跟川哥吃饭的时候，他给我提了几个解决方案，1. 使用QT来构建一个自己的客户端。 2.直接写一些批出理程序 3. 使用Quicker工具来操作。</p>
<p>因为Quicker之前我也用过，可以进行一些快捷操作。吃完午饭之后，无心午睡，便直接回实验室。尝试进行Quicker的安装与学习。</p>
<h1 id="Quicker解我燃眉之急"><a href="#Quicker解我燃眉之急" class="headerlink" title="Quicker解我燃眉之急"></a>Quicker解我燃眉之急</h1><p><img src="/2021/03/15/%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7/%E4%B8%80%E4%B8%AA%E6%9E%81%E5%A4%A7%E7%AE%80%E5%8C%96%E6%93%8D%E4%BD%9C%E7%9A%84%E5%B7%A5%E5%85%B7Quicker/%E7%BD%91%E7%AB%99%E9%A6%96%E9%A1%B5.png" alt="网站首页"></p>
<p>网址：<a href="https://getquicker.net/">https://getquicker.net/</a></p>
<p>这里是详细的帮助文档：<a href="https://www.yuque.com/quicker/help">https://www.yuque.com/quicker/help</a></p>
<p>网站配有充足的文档和讨论区可供学习</p>
<p><img src="/2021/03/15/%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7/%E4%B8%80%E4%B8%AA%E6%9E%81%E5%A4%A7%E7%AE%80%E5%8C%96%E6%93%8D%E4%BD%9C%E7%9A%84%E5%B7%A5%E5%85%B7Quicker/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2020-12-15T06-34-59.750Z.png" alt="火狐截图_2020-12-15T06-34-59.750Z"></p>
<p>安装完成之后 打开用户界面：</p>
<p><img src="/2021/03/15/%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7/%E4%B8%80%E4%B8%AA%E6%9E%81%E5%A4%A7%E7%AE%80%E5%8C%96%E6%93%8D%E4%BD%9C%E7%9A%84%E5%B7%A5%E5%85%B7Quicker/%E7%95%8C%E9%9D%A2.png" alt="界面"></p>
<p>可以点击动作框，快速编辑动作。 </p>
<p><img src="/2021/03/15/%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7/%E4%B8%80%E4%B8%AA%E6%9E%81%E5%A4%A7%E7%AE%80%E5%8C%96%E6%93%8D%E4%BD%9C%E7%9A%84%E5%B7%A5%E5%85%B7Quicker/%E5%BF%AB%E9%80%9F%E7%BC%96%E8%BE%91%E5%8A%A8%E4%BD%9C.png" alt="快速编辑动作"></p>
<p>通过这种手段，我写了几个操作，完美的解决了我的需求：</p>
<p><strong>需求1：可视化的新建文章 直接输入标题即可。</strong></p>
<p>​    方案：自带的输入组件，可以形成输入框，清晰可见。</p>
<p>![new blog](D:\Data\My Blog\blog\source_posts\一个极大简化操作的工具Quicker\new blog.png)</p>
<p>​        各个组件之间可以传参数，所以 输入组件之后连接一个脚本运行组件即可自定义一个新的博客名称并运行。一键式操作 哈哈哈哈。</p>
<p><img src="/2021/03/15/%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7/%E4%B8%80%E4%B8%AA%E6%9E%81%E5%A4%A7%E7%AE%80%E5%8C%96%E6%93%8D%E4%BD%9C%E7%9A%84%E5%B7%A5%E5%85%B7Quicker/%E5%8F%82%E6%95%B0.png" alt="参数"></p>
<p><strong>需求2：一键 构建，一键部署，一键启动等等我想要的操作都一键完成。</strong></p>
<p>​    方案：基础动作里面就可以编辑的执行脚本 批处理一键操作。</p>
<p><img src="/2021/03/15/%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7/%E4%B8%80%E4%B8%AA%E6%9E%81%E5%A4%A7%E7%AE%80%E5%8C%96%E6%93%8D%E4%BD%9C%E7%9A%84%E5%B7%A5%E5%85%B7Quicker/%E8%84%9A%E6%9C%AC%E9%A1%B5%E9%9D%A2.png" alt="脚本页面"></p>
<p><strong>需求3：便捷且可视化的图片插入方式。需求4：博客书写过程要流畅，清爽。专注。</strong></p>
<p>​    方案：这个确实是个问题，要想书写的流畅清爽，还是要在专业的markdown软件中书写最为合适。在Typora中插入图片，并一次性写成，然后在部署之前全局将路径替换掉即可。（这里因为我的博客的图片存储在md同目录下的同名文件夹下  详见我的Hexo插入图片相关博客）</p>
<p>Quicker还有很多的功能等着我探索，有的时候懒惰也是生产力呢。(#^.^#)</p>
]]></content>
      <tags>
        <tag>win工具</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda的安装与使用</title>
    <url>/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="安装Anaconda3"><a href="#安装Anaconda3" class="headerlink" title="安装Anaconda3"></a>安装Anaconda3</h1><h2 id="前言：先装Python还是先装anaconda"><a href="#前言：先装Python还是先装anaconda" class="headerlink" title="前言：先装Python还是先装anaconda?"></a>前言：先装Python还是先装anaconda?</h2><p>装anaconda，就不需要单独装python了</p>
<p>anaconda 是一个python的发行版，包括了python和很多常见的软件库, 和一个包管理器conda。</p>
<blockquote>
<p>1、anaconda里面集成了很多关于python科学计算的第三方库，主要是安装方便，而python是一个编译器，如果不使用anaconda，那么安装起来会比较痛苦，各个库之间的依赖性就很难连接的很好。</p>
<p>2、常见的科学计算类的库都包含在里面了，使得安装比常规python安装要容易。 </p>
</blockquote>
<h2 id="下载Anaconda"><a href="#下载Anaconda" class="headerlink" title="下载Anaconda"></a>下载<strong>Anaconda</strong></h2><p>选择1——官网（不推荐）</p>
<blockquote>
<p>不推荐，因为尤其的慢，还容易出错。</p>
</blockquote>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/%E5%AE%98%E7%BD%91.png" alt="img"></p>
<p><a href="https://www.anaconda.com/products/individual">https://www.anaconda.com/products/individual</a></p>
<p>选择2——镜像网站安装。（推荐）</p>
<blockquote>
<p> 这是清华大学的镜像网，直接找到你需要的下载即可，又快又省力。</p>
</blockquote>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-65bee8d6150681c9b3aecac5fa0ba644_720w.jpg" alt="img"></p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p>
<h2 id="安装Anaconda（错误重灾区）"><a href="#安装Anaconda（错误重灾区）" class="headerlink" title="安装Anaconda（错误重灾区）"></a>安装Anaconda（错误重灾区）</h2><h3 id="安装过程（图示是操作顺序）"><a href="#安装过程（图示是操作顺序）" class="headerlink" title="安装过程（图示是操作顺序）"></a>安装过程（图示是操作顺序）</h3><p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-1a95c6756d90ce6dd74a9f08f6dd50a8_720w.jpg" alt="img"></p>
<blockquote>
<p>在这里提醒，这个“All Users”选上</p>
</blockquote>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-29778a46617e491adb554ac5fa5823b1_720w.jpg" alt="img"></p>
<p>接着就是路径，提醒小白，安装到C盘真的可以避免后续的很多小问题，但是尽管这样我也没有尝试过把它装入C盘。</p>
<blockquote>
<p>注意路径要简单，我的是  D：\Programma\Anaconda3  ——不要有空格！！！不要有中文字符！！！</p>
</blockquote>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-64590b21362f65132f54d1a597f0c809_720w.jpg" alt="img"></p>
<p>最容易错的部分来了，<br>第一项Add Anaconda… 这个是说将安装路径填入到系统环境变量中，有人曾经选上，发现后期总是出现什么“无法定位到动态链接库”问题！！！（这里是自动添加系统环境变量，不选！！自己手动添加就好）</p>
<p>第二项 是说要默认使用python的版本，选上！！</p>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-118a4d294002f24f36b86cb6250b2594_720w.jpg" alt="img"></p>
<p>点击install，等待不太漫长的进度条……</p>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-76ba09f793eb5ed5044e63a9a07bb4c0_720w.jpg" alt="img"></p>
<p>提示安装成功……</p>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-fde78f1bb363c59f31ed653e872e788b_720w.jpg" alt="img"></p>
<p>提示安装VScode，选择点击“skip”</p>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-ec381c321d4a6abc833acc39e2ab1698_720w.jpg" alt="img"></p>
<p>两个“learn”，都取消打勾</p>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-6ed983e8cedf48dc0c0870d3de2c620d_720w.jpg" alt="img"></p>
<p>结束操作……</p>
<h3 id="配置Anaconda环境变量"><a href="#配置Anaconda环境变量" class="headerlink" title="配置Anaconda环境变量"></a>配置Anaconda环境变量</h3><p>此电脑——属性——高级系统设置——环境变量——path——编辑——新建</p>
<blockquote>
<p>E:\Anaconda（Python需要）<br>E:\Anaconda\Scripts（conda自带脚本）<br>E:\Anaconda\Library\mingw-w64\bin（使用C with python的时候）<br>E:\Anaconda\Library\bin（jupyter notebook动态库）</p>
</blockquote>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-a9bbc780a3d2e9e36701214395c6ec82_720w.jpg" alt="img"></p>
<h3 id="检验是否安装成功，注意：检验之前需要配置好环境变量！"><a href="#检验是否安装成功，注意：检验之前需要配置好环境变量！" class="headerlink" title="检验是否安装成功，注意：检验之前需要配置好环境变量！"></a>检验是否安装成功，注意：检验之前需要配置好环境变量！</h3><p> 在cmd中输入 ：python，——查看是否有Python环境？</p>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-bad7f81e99c68cce4359359f40bcaa0a_720w.jpg" alt="img"></p>
<p>在cmd中输入 ：conda –version，——查看是否有conda环境？ (检验安装成功的标志)</p>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-e458fb2141dd7084c1363770b17791ac_720w.jpg" alt="img"></p>
<blockquote>
<p>===2019.8.26更新===<br>我使用中更新了下conda，更新到4.7.11版本，结果又conda install报错，我再也不更新了</p>
</blockquote>
<p>在cmd中输入： conda info，——查看是否有？ (检验安装成功的标志)</p>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-26f33b7c61cc29739f172bb1a1392d66_720w.jpg" alt="img"></p>
<p>如果没有，或者提示conda不是内部或外部命令，那就意味着，你的anaconda没有把环境变量配置好。</p>
<p>（亲测过，根据我走过坑，你按照我说的流程一直下来，是不会出错的。）</p>
<h3 id="检验其他是否安装成功。尤其是-Anaconda-Navifator"><a href="#检验其他是否安装成功。尤其是-Anaconda-Navifator" class="headerlink" title="检验其他是否安装成功。尤其是 Anaconda Navifator"></a>检验其他是否安装成功。尤其是 Anaconda Navifator</h3><blockquote>
<p>点击，看是否能够进入界面，若成功，大功告成。</p>
</blockquote>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-724a6e563be81c17c9cd060ddc8e8d50_720w.jpg" alt="img"></p>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-4b2b25ef579b8dfdd55e5f4950de18cc_720w.jpg" alt="img"></p>
<h3 id="增加Anaconda中国镜像"><a href="#增加Anaconda中国镜像" class="headerlink" title="@@增加Anaconda中国镜像"></a>@@增加Anaconda中国镜像</h3><p>这是清华网站的说明：</p>
<blockquote>
<p>Anaconda | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror  </p>
</blockquote>
<p><a href="https://link.zhihu.com/?target=https://mirror.tuna.tsinghua.edu.cn/help/anaconda/">Tsinghua Open Source Mirror</a><a href="https://link.zhihu.com/?target=https://mirror.tuna.tsinghua.edu.cn/help/anaconda/">mirror.tuna.tsinghua.edu.cn<img src="https://pic2.zhimg.com/v2-22b1ca2db10aa9b49fd1e815a45ab431_180x120.jpg" alt="图标"></a></p>
<p>这是被美国禁止后，恢复的通知：</p>
<blockquote>
<p>【转载】Anaconda中国镜像-(清华已恢复，中科大暂时没恢复) - 知乎  </p>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/79538176">BG大龍：【转载】Anaconda中国镜像-(清华已恢复，中科大暂时没恢复)</a><a href="https://zhuanlan.zhihu.com/p/79538176">zhuanlan.zhihu.com<img src="https://pic3.zhimg.com/v2-515add66df47795da2f127b801b195e2_180x120.jpg" alt="图标"></a></p>
<p>在Anaconda prompt中操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;</span><br><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main&#x2F;</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>
<p>最后一条指令是，设置搜索时显示通道地址</p>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-d55010d2c69cd939f38b9c9159b895ed_720w.jpg" alt="img"></p>
<p>查看是否修改好通道？</p>
<blockquote>
<p>conda config –show channels</p>
</blockquote>
<p><img src="/2020/11/30/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/v2-b1c3610394437760bacc70142030d978_720w.jpg" alt="img"></p>
<p>至此，完成了【下载】——【安装】——【配置path环境变量】——【检验】——【修改清华镜像】，五部分内容。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Anaconda3</category>
      </categories>
  </entry>
  <entry>
    <title>Anaconda控制的各种环境以及镜像源的配置</title>
    <url>/2020/12/01/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E6%8E%A7%E5%88%B6%E7%9A%84%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E9%95%9C%E5%83%8F%E6%BA%90%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="可以在NAVIGATOR里面新建一个Python环境。"><a href="#可以在NAVIGATOR里面新建一个Python环境。" class="headerlink" title="可以在NAVIGATOR里面新建一个Python环境。"></a>可以在NAVIGATOR里面新建一个Python环境。</h2><p>新建一个环境：</p>
<p><img src="/2020/12/01/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E6%8E%A7%E5%88%B6%E7%9A%84%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E9%95%9C%E5%83%8F%E6%BA%90%E7%9A%84%E9%85%8D%E7%BD%AE/%E6%96%B0%E5%BB%BA%E7%8E%AF%E5%A2%83.PNG" alt="新建环境.PNG"></p>
<p>环境保存位置：</p>
<p><img src="/2020/12/01/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E6%8E%A7%E5%88%B6%E7%9A%84%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E9%95%9C%E5%83%8F%E6%BA%90%E7%9A%84%E9%85%8D%E7%BD%AE/%E7%8E%AF%E5%A2%83%E4%BF%9D%E5%AD%98%E5%9C%B0%E5%9D%80.PNG"></p>
<p>pip 在Scripts里面。 每个环境对应一些特定的库。</p>
<p><img src="/2020/12/01/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E6%8E%A7%E5%88%B6%E7%9A%84%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E9%95%9C%E5%83%8F%E6%BA%90%E7%9A%84%E9%85%8D%E7%BD%AE/pip%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE.PNG"> </p>
<p>用Anaconda prompt 打开的是默认的一个环境。  默认环境不在evns文件夹下。</p>
<p>  <img src="/2020/12/01/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E6%8E%A7%E5%88%B6%E7%9A%84%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E9%95%9C%E5%83%8F%E6%BA%90%E7%9A%84%E9%85%8D%E7%BD%AE/%E5%9B%BE%E6%A0%87.png"></p>
<h2 id="解决Pycharm-或者-cmd-导包慢，永久修改pip的镜像源"><a href="#解决Pycharm-或者-cmd-导包慢，永久修改pip的镜像源" class="headerlink" title="解决Pycharm 或者 cmd 导包慢，永久修改pip的镜像源"></a>解决Pycharm 或者 cmd 导包慢，永久修改pip的镜像源</h2><p>到特定环境的Terminal 里面</p>
<p><img src="/2020/12/01/0-Python%E5%9F%BA%E7%A1%80/Anaconda/Anaconda%E6%8E%A7%E5%88%B6%E7%9A%84%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E9%95%9C%E5%83%8F%E6%BA%90%E7%9A%84%E9%85%8D%E7%BD%AE/%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E7%9A%84Terminal.png"></p>
<p>先升级pip再配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pip -U</span><br><span class="line">pip config set global.index-url https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure>

<p>永久修改默认镜像之后，再安装自己的第三方库，只需要：pip install some-package，some-package即要安装的库。</p>
<p>或者直接在pycharm安装，速度也是会很快的。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Anaconda3</category>
      </categories>
  </entry>
  <entry>
    <title>【1-2】Java核心技术及面试指南</title>
    <url>/2020/11/18/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8F%8A%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/%E3%80%901-2%E3%80%91Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8F%8A%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="第一章-带你走进Java的世界"><a href="#第一章-带你走进Java的世界" class="headerlink" title="第一章  带你走进Java的世界"></a>第一章  带你走进Java的世界</h1><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><ol>
<li>调试代码时：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F6 进入下一行代码</span><br><span class="line">F5 进入当前方法中</span><br><span class="line">F8 跳转到下一个断点。</span><br></pre></td></tr></table></figure>
<h2 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h2><ol>
<li>保证单一职责原则，<ol>
<li>在一个类（class）中，应当放同一种类的代码。</li>
<li>同一类业务的类放入同一个package。</li>
</ol>
</li>
</ol>
<h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><p>在公司项目中，Web是重点，Core是基础。</p>
<p>应该通过Spring系列框架或者MyBatis等基于java Web 的架构或者技术来提升自己。</p>
<table>
<thead>
<tr>
<th>技术种类</th>
<th>具体的技术</th>
<th>应用的层面和作用</th>
</tr>
</thead>
<tbody><tr>
<td>架构技术</td>
<td>Nginx（负载均衡）<br>Kafka（消息服务）</td>
<td>在架构层面为整个系统服务，一旦有流量提升的需求，则可以采用扩展服务器的方式来应对。</td>
</tr>
<tr>
<td>Java Web 技术</td>
<td>Spring系列框架+MyBatis</td>
<td>前后端交互，完成各类web层面的业务</td>
</tr>
<tr>
<td>Core技术</td>
<td>集合，数据库，IO，异常处理。</td>
<td>在业务实现时会大量使用。</td>
</tr>
</tbody></table>
<h3 id="学习路线："><a href="#学习路线：" class="headerlink" title="学习路线："></a>学习路线：</h3><ol>
<li>第一个月  面向对象的语法，Java集合，异常处理流程和基本的IO处理流程。</li>
<li>第二个月进入Java Web初级阶段学习，数据库，JDBC，多线程编程，基本的Web技术（JSP，Servlet，JavaBean+DB架构的简单项目开发）</li>
<li>第三个月深入了解Java Web的资深框架技术 <ol>
<li>学习Spring (IOC |AOP)的基本理念， 能运行IOC和AOP的部分代码，结合代码知道AutoWire等知识。</li>
<li>学习SpringMVC（SpringBoot）框架，跑简单项目，了解组成结构和开发要点。</li>
<li>学习ORM技术，了解MyBatis基本开发模式，知道如何通过ORM和数据库交互。</li>
<li>运行简单的Spring框架+ORM框架的案例，了解框架中各部分的开发要点。</li>
</ol>
</li>
</ol>
<h3 id="学习技巧"><a href="#学习技巧" class="headerlink" title="学习技巧"></a>学习技巧</h3><ol>
<li><p>了解概念。</p>
</li>
<li><p>通读API，知道如何操作常用API，一定要通过代码（有必要就进行Debug）来了解基本用法。</p>
</li>
<li><p>了解性能相关的知识点。 积累多个知识体系是高级程序员的必备技术。</p>
<p><strong>学习一定要以市场需求为导向，切忌闭门造车</strong></p>
</li>
</ol>
<hr>
<h1 id="第二章-基本语法中的常用技术点精讲"><a href="#第二章-基本语法中的常用技术点精讲" class="headerlink" title="第二章 基本语法中的常用技术点精讲"></a>第二章 基本语法中的常用技术点精讲</h1><h2 id="数据类型，封装类"><a href="#数据类型，封装类" class="headerlink" title="数据类型，封装类"></a>数据类型，封装类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String num&#x3D;&quot;123&quot;;</span><br><span class="line">用封装类进行数据转换。</span><br><span class="line">int intval&#x3D;Integer.valuOf(num);</span><br></pre></td></tr></table></figure>

<h3 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="== 和equals的区别"></a>== 和equals的区别</h3><ol>
<li>对于基本数据类型（int等） ==  可以用来比较值是否相等。</li>
<li>对于引用类型和封装类型（如 Integer) == 是比较内存中存放的地址是否一致。而封装在Integer中的equals方法才用来比较值是否相等。</li>
</ol>
<p><strong>equals是判断两个变量或者实例指向同一个内存空间的值是不是相同</strong><br><strong>==是判断两个变量或者实例是不是指向同一个内存空间</strong></p>
<p>这里涉及JVM的相关知识：</p>
<p>​    基本数据类型和引用类型存放于栈中，引用指向的无法预测的数组和对象存放于堆中。</p>
<h3 id="流程控制时的注意要点"><a href="#流程控制时的注意要点" class="headerlink" title="流程控制时的注意要点"></a>流程控制时的注意要点</h3><ol>
<li><p>应避免短路现象。</p>
<p> 写代码时，应当只在条件表达式 [if（条件表达式）] 中做简单的判断操作，而不应该进行数值运算，从而避免在写代码时出现短路现象。要保证代码的可读性。</p>
</li>
<li><p>注意循环的边界值。</p>
</li>
<li><p>switch中，每个case分支都需要加上break跳出语句，最底部建议加上default。</p>
</li>
</ol>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1：String str &#x3D; &quot;abc&quot;; &#x2F;&#x2F; 存储在常量池中。</span><br><span class="line">2：String str &#x3D; new Sting(&quot;abc&quot;); &#x2F;&#x2F;存储在堆中（对象）</span><br></pre></td></tr></table></figure>

<ol>
<li>尽可能使用常量，如1;        避免使用变量，如2；</li>
<li>尽量避免大规模针对String的（如连接字符串）操作，这样会频繁地生成内存碎片，导致内存性能问题。应使用StringBuilder对象来处理这样的问题。</li>
</ol>
<h4 id="String易错点"><a href="#String易错点" class="headerlink" title="String易错点"></a>String易错点</h4><ol>
<li><p>String的常量（不仅是String，Interger等常量也是）是放在常量池中的，值相同的常量是共享同一块内存的，通过 == 比较他们的内存地址是相同的。</p>
</li>
<li><p>String s=new String（”abc”）创建了几个对象？ 有两种情况</p>
<ul>
<li><p>如果常量池中有字符串abc，那么只会在内存中创建一个对象</p>
</li>
<li><p>如果常量池中没有字符串abc，那么在常量池中创建一个内容为abc的对象， 但是遇到了new关键字，则还是 会在内存（不是常量池）中创建一个对象，然后将对象返回给引用s， 特别注意s不是一个对象</p>
</li>
</ul>
</li>
</ol>
<pre><code> 常量池中内容为abc的对象 + 内存中的new出来的对象，s只是一个引用不是对象</code></pre>
<ol start="3">
<li><p>StringBuffer和StringBuilder的区别是什么？</p>
<ul>
<li><p>StringBuffer是线程安全的，但性能稍低。StringBuilder非线程安全，性能高，适合单线程任务。</p>
</li>
<li><p>具体请搜索本站相关博文。</p>
</li>
</ul>
</li>
</ol>
<h2 id="封装，继承和多态是面向对象三要素"><a href="#封装，继承和多态是面向对象三要素" class="headerlink" title="封装，继承和多态是面向对象三要素"></a>封装，继承和多态是面向对象三要素</h2><h3 id="论封装"><a href="#论封装" class="headerlink" title="论封装"></a>论封装</h3><ol>
<li><p>类是个抽象的概念，仅仅存在于图纸上。new 之后称为对象，这才是真实存在的东西。</p>
</li>
<li><p>方法的参数是副本，返回值需要return.</p>
</li>
<li><p>通过合理的访问控制符实现封装</p>
<ul>
<li><p>没有特殊需求，应把类内部的属性变量设置成私有。</p>
</li>
<li><p>把类的构造函数设置成公有</p>
</li>
<li><p>在类，方法，属性变量前添加访问控制符。</p>
</li>
<li><table>
<thead>
<tr>
<th>访问控制符</th>
<th>同类</th>
<th>同包</th>
<th>子类</th>
<th>不同包</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>protected</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>X</td>
</tr>
<tr>
<td>Default默认</td>
<td>1</td>
<td>1</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>private</td>
<td>1</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ol>
<h4 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h4><ol>
<li>静态类里只能使用静态的变量。</li>
<li>使用静态类时要注意：<ol>
<li>只在需要的时候定义静态类，不要为了不想new对象而定义大量静态类。</li>
<li>静态变量相当于全局变量，只把整个项目中都会用到的变量设置成静态的。</li>
<li>在尽可能小的范围内使用静态类和静态方法。</li>
</ol>
</li>
</ol>
<h3 id="论继承"><a href="#论继承" class="headerlink" title="论继承"></a>论继承</h3><p>接口中的常量也是很有意义的。</p>
<ol>
<li><p><strong>抽象类是对概念的归纳，接口是对功能的归纳</strong></p>
<ul>
<li>继承抽象类，实现接口。</li>
</ul>
</li>
<li><p>子类覆盖父类的方法</p>
<ul>
<li>子类不能缩小父类的访问权限。 子类只能放大权限</li>
<li>子类方法不能抛出比父类方法更多的异常！</li>
</ul>
</li>
<li><p>final 关键字</p>
<ul>
<li>作用在方法上，方法不可被子类覆盖</li>
<li>作用到属性上，属性相当于常量。赋初值后不可改变。</li>
</ul>
</li>
<li><p>理解finalize方法，但别重写</p>
<p>   当垃圾回收时，会自动调用该类的finalize方法，如果类中没有定义，会调用Object类中的finalize，但Object中的finalize是空白的。</p>
</li>
</ol>
<h3 id="论多态"><a href="#论多态" class="headerlink" title="论多态"></a>论多态</h3><ol>
<li>方法重载和覆盖</li>
<li>构造函数能重载但不能覆盖<br> 有可能父类有子类不存在的属性，父类构造中会初始化这些属性，子类覆盖的话，会造成父类无法初始化。</li>
<li>this：指向方法的本类。<ul>
<li>this.value=XXX； 给本对象的属性赋值。</li>
<li>this(xx,”xxx”)  可以在不带参数的构造中 通过 this 调用带参数的构造。</li>
</ul>
</li>
<li>super：指向方法的父类。<ul>
<li><strong>子类的构造函数体中，如果什么都不写，Java编译器 会默认加上super（），以调用父类中的不带参数的构造函数，如果父类中没有不带参数的构造函数，会提示语法错误。</strong></li>
<li>可以super显示调用父类的某个构造</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java面试准备</category>
        <category>Java核心技术及面试指南</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title>【3】集合类与常用的数据结构</title>
    <url>/2020/11/24/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8F%8A%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/%E3%80%903%E3%80%91%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%8E%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="【3】集合类与常用的数据结构"><a href="#【3】集合类与常用的数据结构" class="headerlink" title="【3】集合类与常用的数据结构"></a>【3】集合类与常用的数据结构</h1><h2 id="常见集合类对象的使用方法"><a href="#常见集合类对象的使用方法" class="headerlink" title="常见集合类对象的使用方法"></a>常见集合类对象的使用方法</h2><ol>
<li>Set 对象里最多只能存储一个null元素。</li>
</ol>
<h2 id="线性表类的集合"><a href="#线性表类的集合" class="headerlink" title="线性表类的集合"></a>线性表类的集合</h2><ol>
<li>ArrayList与LinkedList的运行结果比较<ol>
<li>在尾部添加：ArrayList是基于数组的，可以很快定位到尾部。</li>
<li>在随机位置添加：包含查找和添加两个动作，查找时ArrayList占优势，添加时基于链表的LinkedList占优，综合还是LinkedList占优。</li>
<li>在随机位置查找：基于数组的ArrayList占优。</li>
</ol>
</li>
<li>对比ArrayList和Vector，为何Vector不常用？<ol>
<li>两者都是基于数组的。</li>
<li>Vector是线程安全的，ArrayList和LinkedList是线程不安全的。</li>
<li>在插入等操作中，Vector需要一定的开销来维护线程的安全。所以大多数单线程的环境下ArrayList更好。</li>
<li>Vector和ArrayList如果超出了开始预设的长度，都会扩充。Vector会扩充100%，而ArrayList会扩充50%，所以ArrayList更节省内存。</li>
</ol>
</li>
<li>Set集合是如何判断自定义类Student的对象重复？<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student implements Comparable&#123;</span><br><span class="line">.....</span><br><span class="line"> public int compareTo(Object o)&#123;</span><br><span class="line"> 	&#x2F;&#x2F;判断是否是学生类型</span><br><span class="line"> 	if (obj instanceof Student )&#123;</span><br><span class="line"> 		Student s &#x3D; (Student) obj;</span><br><span class="line"> 		&#x2F;&#x2F;如果是学生类型，如果学号相等，则不加入Set</span><br><span class="line"> 		if (s.getId() &#x3D;&#x3D; this.getId() )&#123;</span><br><span class="line"> 			return 0;</span><br><span class="line"> 		&#125;else &#123;</span><br><span class="line"> 			return s.getId() &gt; this.getId() ? 1 : -1;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	&#x2F;&#x2F;不是学生类型的话，就不要加入</span><br><span class="line"> 	else&#123;</span><br><span class="line"> 		retuen 0;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>为了将Student类放入Set，程序员需要实现Comparable接口，并重写其中的compareTo方法。</li>
<li>compareTo方法中，根据返回值int的不同，执行相应的动作<ol>
<li>返回0，表示对象已经存在在Set中，无法再次加入。</li>
<li>返回1，-1. 表示Set中还没有和它相同的对象，可以加入。 1大于（先输出），-1 小于（后输出）。</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="4">
<li><p>TreeSet,HashSet,LinkedHashSet的特点</p>
<ul>
<li>HashSet 基于Hash表实现的，不能保证线程安全，允许存在一个null值。</li>
<li>HashSet会调用插入对象的hashCode（）方法 （如果该对象没有定义，将调用Object） 来得到对象的hashcode值，根据该值决定对象的存放位置，遇到两个对象的hashCode值一直的情况，则说明他们相等，则不允许插入。</li>
<li>HashSet不能保证插入次序和遍历次序一致。</li>
<li>LinkedHashSet也是基于Hash表，但是采用了链表结构，保证了插入次序和遍历次序一致。</li>
<li>TreeSet 是 SortedSet的唯一实现类，用二叉树来存储数据，用二叉树的特性来来保证有序。</li>
<li>TreeSet中存储自定义类时，类必须实现Comparable接口，并重写compareTo方法<ul>
<li>compareTo返回值为0 表示对象相等。</li>
<li>返回值1  大于 先输出</li>
<li>返回值 -1 小于 后输出</li>
</ul>
</li>
</ul>
</li>
<li><p>浅拷贝和深拷贝带来的问题</p>
<ol>
<li>浅拷贝即对象的引用。深拷贝即通俗的复制。</li>
<li>程序员将变量放入两个不同的集合对象中，若在一个集合中进行了修改，这个修改也会影响到另外的一个备份的集合！！ 要想达到不影响，就应进行深拷贝</li>
<li>深拷贝需要通过clone方法来实现。</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现Cloneable接口，重写clone方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写clone方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>访问线性表： <strong>迭代器</strong></p>
<p> Iterator来遍历集合是实际项目中常用的。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Iterator &lt; T &gt; iter &#x3D; 集合对象.iterator();</span><br><span class="line">while(iter.hasNext())&#123;</span><br><span class="line">	System.out.println( iter.next() );	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：在迭代器遍历的时候，不能同时修改待遍历的集合对象，用for循环来代替Iterator则可以遍历+修改。</p>
<h2 id="线性表类的集合-1"><a href="#线性表类的集合-1" class="headerlink" title="线性表类的集合"></a>线性表类的集合</h2><ol>
<li><p>为什么要重写equals和hashCode方法？</p>
<ol>
<li><p>hash类型的存储结构，会先根据hashCode的值在决定存放的索引位置，如果hashCode冲突了，则根据equals来判断是否已有相同的对象，若没有，则在索引位置上新建一个链表节点，存放该对象。</p>
</li>
<li><p>equals 不重写，相当于 == ， 即比较引用的地址是否一致。</p>
</li>
<li><p>hashCode() 如果不重写，默认使用地址进行hash计算。</p>
</li>
<li><p>比较两个对象是否相等，实际上是比较的人们关心的对象内容是否相等。而非地址。是比较 “两个“ 对象是否相等。默认地址是不一样的。</p>
<p>而Hash集合的存储首先是基于hash表的，必须重写hashCode，否则会存入“两个对象”但是相等的情况，会与hash存储的对象不重复原则相违背。</p>
</li>
</ol>
</li>
<li><p>通过迭代器遍历HashMap</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Entry&lt;T,T&gt;&gt; fileIt &#x3D; hashMap对象.entrySet().iterator;</span><br><span class="line">while(fileIt.hasNext())&#123;</span><br><span class="line">	Map.Etry&lt;T,T&gt; entry&#x3D;(Map.Entry&lt;T,T&gt;)fileIt.next();</span><br><span class="line">	</span><br><span class="line"> a&#x3D;entry.getKey();</span><br><span class="line">	b&#x3D;entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><p>对比HashMap，HashTable，HashSet</p>
<ol>
<li><p>一般对顺序访问需求不多，所以Linked类的对象用的不多。</p>
</li>
<li><p>HashMap Hashtable 是键值对的集合，HashSet是线性表的集合。</p>
</li>
<li><p>HashMap和HashTbble的区别：</p>
<ol>
<li><p>HashMap线程不安全，可以说是轻量级的。</p>
</li>
<li><p>Hashtable是线程安全的。</p>
</li>
<li><p>Hashtable不允许将null值作为键，HashMap可以将null作为键key。 但是一般不要这么做。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h2><ol>
<li><p>对集合进行排序</p>
<ol>
<li><p>Student类实现Compareable接口，并在compareTo中定义规则，之后可以通过<code>Collections.sort(Student对象)</code>直接对Student对象进行排序。</p>
</li>
<li><p>Student类可以不实现Compareable接口和重写compareTo ，而是直接用compare方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(sutList,<span class="keyword">new</span> Comparatot&lt;Student&gt;()&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.getId() == s2.getId()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> s1.getId()&gt;s2.getId() ? <span class="number">1</span>:-<span class="number">1</span>;<span class="comment">//1是往前，-1是往后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>把线程不安全变成线程安全</p>
<ol>
<li><code>Collections</code>中的synchronizedXXX方法<ol>
<li><code>Collections.synchronizedList(stuList);</code> 将ArrayList或者LinkedList包装成线程安全。</li>
<li><code>Collections.synchronizedSet(stuSet)</code>  包装Set对象。</li>
<li><code>Collections.synchronizedMap(stuMap)</code> 包装Map对象</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ol>
<li><strong>定义方法参数</strong><ol>
<li><code>List&lt;? super Father&gt; dest</code>   dest存放的对象应以Father为子类。可以存放Father的父类对象。【不能从dest中读数据】，因为不知道读出来的是哪个父类，接不住。</li>
<li><code>List&lt;? extends Father&gt; dest</code>  extend 表示继承。 所以dest存放的是Father的子类对象。【不能往里面写数据】，因为不确定写的是哪个子类，要保证类型安全。</li>
<li>注意，这两种泛型只能定义方法参数，不能用来定义变量，不可下入和读取。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java面试准备</category>
        <category>Java核心技术及面试指南</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title>【4】异常处理与IO</title>
    <url>/2020/11/26/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8F%8A%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/%E3%80%904%E3%80%91%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8EIO/</url>
    <content><![CDATA[<h1 id="第四章-异常处理与IO"><a href="#第四章-异常处理与IO" class="headerlink" title="第四章 异常处理与IO"></a>第四章 异常处理与IO</h1><h2 id="异常的常规知识"><a href="#异常的常规知识" class="headerlink" title="异常的常规知识"></a>异常的常规知识</h2><ul>
<li>Throwable<ul>
<li>Error 不作任何处理 直接终止程序</li>
<li>Exception 异常类，可以处理不同情况。如RuntimeException 处理运行时异常。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">	xxxxxxxx </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>throw,throws和Throwable的区别</p>
<p>Throwable是Error和Exception的父类。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkData</span> <span class="params">(<span class="keyword">int</span> data)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (data&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Data Error&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throws 出现在方法声明的位置，throw 出现在函数体中。</p>
<p>如果在某个函数内部用throw抛出了异常，那么在声明该函数时，一定要配套使用throws，否则会有语法错误。</p>
<h2 id="异常的高级知识点"><a href="#异常的高级知识点" class="headerlink" title="异常的高级知识点"></a>异常的高级知识点</h2><ol>
<li><p>父类方法应当充分考虑运行环境的险恶程度， 子类不应抛出比父类范围更广的异常， 先有需求再有语法!!!</p>
</li>
<li><p>异常处理部分的使用要点</p>
<ol>
<li><p>try-catch-finally 语句来处理异常，在finally中应当尽可能的回收内存资源</p>
</li>
<li><p>尽量减少用try监控的代码块。 对于无需监控的代码，不应受try的影响。</p>
</li>
<li><p>先用专业的异常来处理，最后用Exception异常来处理。</p>
</li>
<li><p>在catch从句中，不应只简单抛出异常，要尽可能的处理异常。 推荐弹出对话框。</p>
<p>​    <code>catch(Exception ex )&#123;ex.printStackTrace(); &#125;</code></p>
</li>
<li><p>出现异常后，应尽量保证项目不会终止，把异常造成的影响降到最小。</p>
</li>
</ol>
</li>
<li><p>运行期异常（RuntimeException ）可以不try-catch   </p>
<p>​    除以零异常， 空指针异常，数组越界异常。</p>
</li>
</ol>
<h2 id="常见的IO读写操作"><a href="#常见的IO读写操作" class="headerlink" title="常见的IO读写操作"></a>常见的IO读写操作</h2><h3 id="遍历指定文件夹的内容"><a href="#遍历指定文件夹的内容" class="headerlink" title="遍历指定文件夹的内容"></a>遍历指定文件夹的内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//遍历目录，找到csv文件，参数是文件夹的路径。</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCSVInFolder</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line">		File folderName = <span class="keyword">new</span> File(filePath);</span><br><span class="line">		File flist[] = folderName.listFiles();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(flist == <span class="keyword">null</span> || flist.length ==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		String fileName = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">for</span> (File f :flist)&#123;</span><br><span class="line">			<span class="keyword">if</span>(f.isDirectory())&#123;</span><br><span class="line">                <span class="comment">//如果是文件夹，递归调用方法。</span></span><br><span class="line">				getCSVInFolder(f.getAbsolutePath());</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="comment">//如果是文件，则判断是否是csv文件。</span></span><br><span class="line">                fileNaem  = f.getName();</span><br><span class="line">                <span class="keyword">if</span>(fileName.subString(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>).equals(<span class="string">&quot;csv&quot;</span>))&#123;</span><br><span class="line">                    System.out.println(f.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        getCSVInFolder(<span class="string">&quot;c://1&quot;</span>);  <span class="comment">//Java里面的盘符 / 要用双斜杠来代替。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非阻塞性的NIO操作。"><a href="#非阻塞性的NIO操作。" class="headerlink" title="非阻塞性的NIO操作。"></a>非阻塞性的NIO操作。</h2><h3 id="NIO与传统的IO的区别"><a href="#NIO与传统的IO的区别" class="headerlink" title="NIO与传统的IO的区别"></a>NIO与传统的IO的区别</h3><p>JDK1.4以上提供了一种 new IO，即 NIO ，与iO不同，NIO是非阻塞的IO</p>
<table>
<thead>
<tr>
<th>NIO</th>
<th>IO</th>
</tr>
</thead>
<tbody><tr>
<td>NIO是面向缓存（Buffer）的，而不是面向流操作的，所以可以跳跃读取或者反复读取。</td>
<td>IO是面向流（Stream）的，只能顺序从流中读取数据。</td>
</tr>
<tr>
<td>读写操作有非阻塞性，如从某通道中读取数据时，仅能得到当前可用的数据，如果当前没有数据就什么偶读不会获取，而且代码可以继续运行。</td>
<td>IO是阻塞的，如调用InputStream.read() 方法时，他会一直等到数据到来时（或超时)才会继续执行后续代码，否则就会一直等待。</td>
</tr>
<tr>
<td>NIO的selectors组件允许一个线程（即一个Java类）监控多个来源（即 channels）， 也就是说，可以通过一个线程来管理多个输入和输出通道。</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="NIO的三大重要组件"><a href="#NIO的三大重要组件" class="headerlink" title="NIO的三大重要组件"></a>NIO的三大重要组件</h3><p>Channel 通道， Buffer 缓冲器， Selector 选择器</p>
<p>Channel与传统的IO中的流Stream类似，但Channel是双向的，Stream是单向的（分输入输出流）</p>
<p>唯一能与Channel交互的是 Buffer ，通过Channel，可以从Buffer中读写数据。</p>
<p>用户可以通过选择器Selector来管理Channel，在一个Selector上注册多个Channel，通过这个Selector来管理多个Channel的操作。</p>
<h3 id="Channel和Bufer"><a href="#Channel和Bufer" class="headerlink" title="Channel和Bufer"></a>Channel和Bufer</h3><p>NIO中， 有4种Channel对象。</p>
<p>有针对文件的 FIleChannel <strong>常用</strong></p>
<p>针对网络编程的 DatagramChannel，SocketChannel和ServerSocketChannel  <strong>大多数项目中，很少直接通过Java代码进行网络编程</strong></p>
<p>通过Channel对象进行读写操作，通过Buffer对象缓存读写的内容。</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><ol>
<li><p><code>Selector selector = Selector.open();</code> 创建一个Selector；</p>
</li>
<li><p>将Channel注册到Selector上。</p>
<p><code>channel.configureBlocking(false);</code> // 将channel设置成非阻塞式（必须）</p>
<p><code>SelectionKey  Key = channel.register(selector,Selectionkey.OP_READ)</code></p>
</li>
</ol>
<p>FileChannel不能与Selector一起使用，因为FileChannel不能切换到非阻塞式，但是套接字通道可以。</p>
]]></content>
      <categories>
        <category>Java面试准备</category>
        <category>Java核心技术及面试指南</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下右键快速新建md文件</title>
    <url>/2021/11/09/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02-Windows/windows%E4%B8%8B%E5%8F%B3%E9%94%AE%E5%BF%AB%E9%80%9F%E6%96%B0%E5%BB%BAmd%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p><a href="https://stepneverstop.github.io/win-rightclick-create-md.html">转载自Keavnn’Blog</a><br>  今天新建Markdown文件的时候发现很不方便，之前我是将typora固定到任务栏，点击图标就可以打开新建Markdown文件，今天想右键快速新建md文件，找了很多都不行，最后找到一个可以实现的。最后简单介绍了一些Markdown常用的快捷键和语法。话不多说，图先奉上。</p>
<h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="/2021/11/09/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02-Windows/windows%E4%B8%8B%E5%8F%B3%E9%94%AE%E5%BF%AB%E9%80%9F%E6%96%B0%E5%BB%BAmd%E6%96%87%E4%BB%B6/watermark.png" alt="在这里插入图片描述"><br> （ps：电脑截屏竟然可以用windows+shift+S)</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1、前提：安装有Typora（很好用的一款软件，官网可以直接下载）或其他Markdown编辑软件<br> 2、打开注册表<br> <code>Windows+R</code>，打开运行对话框<br> 输入<code>regedit</code>，打开注册表编辑器<br> 2、修改注册表</p>
<ul>
<li><p>在<code>计算机&gt;HKEY_CLASSES_ROOT</code>右键查找，输入<code>Typora</code>,勾选项取消<code>值</code>和<code>数据</code><br> <img src="/2021/11/09/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02-Windows/windows%E4%B8%8B%E5%8F%B3%E9%94%AE%E5%BF%AB%E9%80%9F%E6%96%B0%E5%BB%BAmd%E6%96%87%E4%BB%B6/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjI3NzMz,size_16,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述"></p>
</li>
<li><p>点击<code>查找下一个</code>，出现如下图所示<br> <img src="/2021/11/09/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02-Windows/windows%E4%B8%8B%E5%8F%B3%E9%94%AE%E5%BF%AB%E9%80%9F%E6%96%B0%E5%BB%BAmd%E6%96%87%E4%BB%B6/20201106151140713.png" alt="在这里插入图片描述"></p>
</li>
<li><p>然后在桌面或磁盘其他任意地方新建一个文本文档，输入一下代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00 </span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@&#x3D;&quot;Typora.exe&quot;</span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;&#x3D;&quot;&quot;</span><br><span class="line">[HKEY_CLASSES_ROOT\Typora.exe]</span><br><span class="line">@&#x3D;&quot;Markdown&quot;</span><br></pre></td></tr></table></figure>

<p>@=“Typora.exe” 代表的是指定.md文件的运行程序<br> @=“Markdown” 代表的是右键时默认的文件名字，这样写新建为”新建Markdown.md文件”，而且右键菜单中显示MarkDown</p>
<p>注意，第一行的 <code>Windows Registry Editor Version 5.00</code> 一定要有，否则会报 “指定的文件不是注册脚本。您在注册表编辑器中只能导入二进位注册文件”</p>
<ul>
<li>编辑好之后另存为<code>reg</code>格式，如图</li>
<li><img src="/2021/11/09/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02-Windows/windows%E4%B8%8B%E5%8F%B3%E9%94%AE%E5%BF%AB%E9%80%9F%E6%96%B0%E5%BB%BAmd%E6%96%87%E4%BB%B6/20201106151819309.png" alt="在这里插入图片描述"><br> （有的博客编码用的Unicode，本机没有，直接用的UTF- 8也可，保存类型一定要是<code>文本文档(*.txt)</code>）<br> 保存文件后双击运行<br> <img src="/2021/11/09/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02-Windows/windows%E4%B8%8B%E5%8F%B3%E9%94%AE%E5%BF%AB%E9%80%9F%E6%96%B0%E5%BB%BAmd%E6%96%87%E4%BB%B6/20201106152143953.png" alt="在这里插入图片描述"><br> 直接继续</li>
<li>现在右键新建应该有<code>Markdown</code>，如果不行，重启一下试试</li>
</ul>
<h4 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h4><p>右键软件Typora，打开文件所在位置，找到Typora快捷方式，右键点击属性，找到快捷键一栏，直接按键选择快捷键，例如我的是ctrl+shift+M键（其他软件同理）。</p>
<h4 id="最后介绍一下简单的Markdown常用快捷键"><a href="#最后介绍一下简单的Markdown常用快捷键" class="headerlink" title="最后介绍一下简单的Markdown常用快捷键"></a>最后介绍一下简单的Markdown常用快捷键</h4><p>撤销 Ctrl +Z<br> 重做 Ctrl +Y<br> 加粗 Ctrl +B<br> 斜体 Ctrl +I<br> 标题 Ctrl +Shift +H<br> 有序列表 Ctrl +Shift +O<br> 无序列表 Ctrl +Shift +U<br> 待办列表 Ctrl +Shift +C<br> 插入代码 Ctrl +Shift +K<br> 插入链接 Ctrl +Shift +L<br> 插入图片 Ctrl +Shift +G<br> 查找 Ctrl +F<br> 替换 Ctrl +G</p>
]]></content>
      <categories>
        <category>2-操作系统</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>【5】SQL,JDBC与数据库编程</title>
    <url>/2020/11/28/1-JavaSE%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8F%8A%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/%E3%80%905%E3%80%91SQL-JDBC%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="常用SQL语句的注意事项。"><a href="#常用SQL语句的注意事项。" class="headerlink" title="常用SQL语句的注意事项。"></a>常用SQL语句的注意事项。</h2><ol>
<li><p>尽量别写Select * ， 只取需要的返回列。</p>
</li>
<li><p>count（*）和count（字段名）的比较</p>
<ul>
<li>如果表中某字段允许null，那么count（字段名）取的是非null的数量，而不是总数。</li>
<li>推荐使用count（主键名） ，因为有索引，性能好。</li>
<li>select count（1） from xxx的写法，表示用表的第一个字段来获取总条数。不推荐。</li>
<li>count（带索引的字段）性能好于  count（*）</li>
</ul>
</li>
<li><p>insert的注意事项</p>
<ol>
<li>insert into  student (id,name,address) values (‘1’,.’zhangsan’,’beijing’) 建议不要省略字段列表，要保证复用性。</li>
<li>Oracle就不支持批量插入。MySQL可以。insert into  student (id,name,address) values (‘1’,.’zhangsan’,’beijing’) ， (‘2’,.’zhangsan’,’beijing’)</li>
</ol>
</li>
<li><p>delete中，通过in同时删除多条。</p>
<ol>
<li>delete from student where id in (1,2,3,4)</li>
</ol>
</li>
<li><p>merge和update的比较</p>
<ol>
<li><p>update 对表更新。merge 无则插入，有则更新。更牛逼。</p>
</li>
<li><p>不是每种数据库都支持merge。</p>
</li>
<li><p>MySQL没有merge into 的用法，但是可以  insert  …. on duplicate key update 来实现。</p>
</li>
<li><pre><code class="sql"> merge语法
 MERGE INTO 目标表 a
 using 源表 b
 on (a.条件字段1 = b.条件字段1  可以加上其他条件)
 when matched then update set a.更新字段 = b.字段 ...
 when not macthed then 
     insert into a (字段1，字段2,。。。。。) values(值1，值2，，，，)
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 通过JDBC开发读写数据库的代码</span><br><span class="line"></span><br><span class="line">操作数据库的代码：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;装载MySQL数据库的驱动</span><br><span class="line">1:  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">&#x2F;&#x2F;创建连接</span><br><span class="line">2: Connection connection &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;...&quot;,&quot;username&quot;,&quot;password&quot;);</span><br><span class="line">&#x2F;&#x2F;通过Statement 对象执行SQL语句</span><br><span class="line">3: Statement stmt &#x3D; connection.createStatement();</span><br><span class="line">&#x2F;&#x2F;通过ResultSet对象得到查询结果</span><br><span class="line">4：ResultSet rs &#x3D; stmt.executeQuery(Sql);</span><br><span class="line">&#x2F;&#x2F;通过rs.next 方法遍历查询结果。</span><br><span class="line">5: while(rs.next())&#123;</span><br><span class="line">    System ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java面试准备</category>
        <category>Java核心技术及面试指南</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title>【排错】JDBC：Access denied for user &#39;root&#39;@&#39;localhost</title>
    <url>/2020/11/18/2-%E6%95%B0%E6%8D%AE%E5%BA%93/01-MySQL/JDBC%EF%BC%9AAccess-denied-for-user-root-localhost/</url>
    <content><![CDATA[<h2 id="springboot-com-mysql-cj-exceptions-CJException-Access-denied-for-user-‘root’-’localhost"><a href="#springboot-com-mysql-cj-exceptions-CJException-Access-denied-for-user-‘root’-’localhost" class="headerlink" title="springboot com.mysql.cj.exceptions.CJException: Access denied for user ‘root’@’localhost"></a>springboot com.mysql.cj.exceptions.CJException: Access denied for user ‘root’@’localhost</h2><p>在application.yml文件中配置的时候要记得</p>
<p>1）最重要的！<strong>密码（password）要加双引号！！！！！特别是以零开头的密码！！</strong></p>
<p>2）设置time__zone 为 +8：00</p>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc.url &#x3D; jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;imoocmybatis?characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">      datasource:</span><br><span class="line">        driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">        url: jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;girl</span><br><span class="line">        username: root</span><br><span class="line">        password: &quot;0111&quot;  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL-JDBC</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SpringBoot</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL安装（win10 + 64bit)</title>
    <url>/2020/03/26/2-%E6%95%B0%E6%8D%AE%E5%BA%93/01-MySQL/MySQL%E5%AE%89%E8%A3%85%EF%BC%88win10-64bit/</url>
    <content><![CDATA[<p>记录下mysql 的安装过程，Mysql版本：8.0.13</p>
<p>安装步骤：</p>
<p>1、下载地址：<a href="https://dev.mysql.com/downloads/mysql/,%E6%97%A0%E9%9C%80%E7%99%BB%E5%BD%95%EF%BC%8C%E7%82%B9%E5%87%BB%E5%BA%95%E9%83%A8%E2%80%9CNo">https://dev.mysql.com/downloads/mysql/,无需登录，点击底部“No</a> thanks, just start my download.”即可开始下载。</p>
<p><img src="/2020/03/26/2-%E6%95%B0%E6%8D%AE%E5%BA%93/01-MySQL/MySQL%E5%AE%89%E8%A3%85%EF%BC%88win10-64bit/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMDEwMTAxMF95,size_27,color_FFFFFF,t_70" alt="img"></p>
<p>2、下载完成后解压（我解压的路径：F:\mysql-8.0.13-winx64）</p>
<p>3、配置初始化的my.ini文件（创建my.ini文件并把以下内容粘贴进去）</p>
<p>[mysql]</p>
<p># 设置mysql客户端默认字符集</p>
<p>default-character-set=utf8</p>
<p>[mysqld]</p>
<p>#设置3306端口</p>
<p>port = 3306</p>
<p># 设置mysql的安装目录</p>
<p>basedir=F:\mysql-8.0.13-winx64</p>
<p># 设置mysql数据库的数据的存放目录</p>
<p>datadir=F:\mysql-8.0.13-winx64\data</p>
<p># 允许最大连接数</p>
<p>max_connections=200</p>
<p># 服务端使用的字符集默认为8比特编码的latin1字符集</p>
<p>character-set-server=utf8</p>
<p># 创建新表时将使用的默认存储引擎</p>
<p>default-storage-engine=INNODB</p>
<p>4、安装mysql</p>
<p>管理员权限进入cmd命令窗口，且cd到安装路径的bin目录下。</p>
<p>依次输入:mysqld –install (安装) mysqld –initialize （初始化）net start mysql（运行）</p>
<p><img src="/2020/03/26/2-%E6%95%B0%E6%8D%AE%E5%BA%93/01-MySQL/MySQL%E5%AE%89%E8%A3%85%EF%BC%88win10-64bit/2" alt="img"></p>
<p>5、修改密码</p>
<p>先获取原始密码命令：mysqld –initialize –console</p>
<p>如果出现以下情况：红色标注将是原始密码（我的始终获取不到，所以采取了第二种方法）</p>
<p><img src="/2020/03/26/2-%E6%95%B0%E6%8D%AE%E5%BA%93/01-MySQL/MySQL%E5%AE%89%E8%A3%85%EF%BC%88win10-64bit/3" alt="img"></p>
<p>第二种获取方法：在data文件夹下找寻.err后缀的文件</p>
<p><img src="/2020/03/26/2-%E6%95%B0%E6%8D%AE%E5%BA%93/01-MySQL/MySQL%E5%AE%89%E8%A3%85%EF%BC%88win10-64bit/4" alt="img"></p>
<p>打开文件找寻密码：</p>
<p><img src="/2020/03/26/2-%E6%95%B0%E6%8D%AE%E5%BA%93/01-MySQL/MySQL%E5%AE%89%E8%A3%85%EF%BC%88win10-64bit/6" alt="img"></p>
<p>然后在cmd窗口下执行：mysql -u root -p，并输入原始密码</p>
<p><img src="/2020/03/26/2-%E6%95%B0%E6%8D%AE%E5%BA%93/01-MySQL/MySQL%E5%AE%89%E8%A3%85%EF%BC%88win10-64bit/1" alt="img"></p>
<p>成功登陆后，将会出现mysql&gt;闪动光标。输入命令修改密码：</p>
<p> alter user user() identified by “123456”;</p>
<p><img src="/2020/03/26/2-%E6%95%B0%E6%8D%AE%E5%BA%93/01-MySQL/MySQL%E5%AE%89%E8%A3%85%EF%BC%88win10-64bit/5" alt="img"></p>
<p>ok，此刻可以开始操作Mysql了，祝大家好运！</p>
<p>查看是否安装Mysql：电脑-管理-服务-Mysql</p>
<p>MySQL可视化工具—navicat;</p>
<p>链接：<a href="https://pan.baidu.com/s/1nDytvylhHIz64WCY0WGfDg">https://pan.baidu.com/s/1nDytvylhHIz64WCY0WGfDg</a><br> 提取码：b5mi</p>
<p>备注：当用navicat连接测试时出现了1251错误提示，解决方法：</p>
<p>alter user ‘root’@’localhost’ identified with mysql_native_password by ‘123456’;</p>
<p>alter user ‘root’@’localhost’ identified by ‘123456’ password expire never;</p>
]]></content>
  </entry>
  <entry>
    <title>如何让mysql的自动递增的字段重新从1开始呢？</title>
    <url>/2020/11/18/2-%E6%95%B0%E6%8D%AE%E5%BA%93/01-MySQL/%E5%A6%82%E4%BD%95%E8%AE%A9mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E9%80%92%E5%A2%9E%E7%9A%84%E5%AD%97%E6%AE%B5%E9%87%8D%E6%96%B0%E4%BB%8E1%E5%BC%80%E5%A7%8B%E5%91%A2%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="如何让mysql的自动递增的字段重新从1开始"><a href="#如何让mysql的自动递增的字段重新从1开始" class="headerlink" title="如何让mysql的自动递增的字段重新从1开始?"></a>如何让mysql的自动递增的字段重新从1开始?</h1><p>数据库表自动递增字段在用过一段时间后清空，还是继续从清空后的自动编号开始。</p>
<h2 id="让某个字段自动从1开始自动递增呢？"><a href="#让某个字段自动从1开始自动递增呢？" class="headerlink" title="让某个字段自动从1开始自动递增呢？"></a>让某个字段自动从1开始自动递增呢？</h2><p>下面两个方法偶都试过，很好用：</p>
<ol>
<li><p>清空所有数据，将自增去掉，存盘，在加上自增，存盘，就从1开始了<br>如何让mysql的自动编号从1开始</p>
</li>
<li><p>truncate table 你的表名</p>
<p>这样不但将清除数据，而且可以重新位置identity属性的字段</p>
</li>
</ol>
<p>不过以上都不能保留现有数据哦。</p>
<h2 id="设置MySQL自动增长从某个指定的数开始"><a href="#设置MySQL自动增长从某个指定的数开始" class="headerlink" title="设置MySQL自动增长从某个指定的数开始"></a>设置MySQL自动增长从某个指定的数开始</h2><ol>
<li> 创建表的时候就设置： </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;Test&#96; (</span><br><span class="line">&#96;ID&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">&#96;class&#96; varchar(2) NOT NULL,</span><br><span class="line">&#96;NAME&#96; varchar(50) NOT NULL,</span><br><span class="line">&#96;SEX&#96; varchar(2) NOT NULL,</span><br><span class="line">PRIMARY KEY (&#96;ID&#96;)</span><br><span class="line">) ENGINE&#x3D;MEMORY AUTO_INCREMENT&#x3D;1000 DEFAULT CHARSET&#x3D;utf8 CHECKSUM&#x3D;1 DELAY_KEY_WRITE&#x3D;1 ROW_FORMAT&#x3D;DYNAMIC</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>如果在创建表时没有设置，后来想设置，可以通过修改实现： </p>
<p>alter table Test auto_increment = 1000; </p>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL-JDBC</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>【排错】Java出现The server time zone value &#39;�й���׼ʱ��&#39; is unrecognising</title>
    <url>/2020/11/18/2-%E6%95%B0%E6%8D%AE%E5%BA%93/01-MySQL/Java%E5%87%BA%E7%8E%B0The-server-time-zone-value-%EF%BF%BD%D0%B9%EF%BF%BD%EF%BF%BD%EF%BF%BD%D7%BC%CA%B1%EF%BF%BD%EF%BF%BD-is-unrecogni/</url>
    <content><![CDATA[<h1 id="Java出现The-server-time-zone-value-‘�й���׼ʱ��’-is-unrecogni的解决"><a href="#Java出现The-server-time-zone-value-‘�й���׼ʱ��’-is-unrecogni的解决" class="headerlink" title="Java出现The server time zone value ‘�й���׼ʱ��’ is unrecogni的解决"></a>Java出现The server time zone value ‘�й���׼ʱ��’ is unrecogni的解决</h1><p>报错<br> The server time zone value ‘й׼ʱ’ is  unrecognized or represents more than one time zone. You must configure  either the server or JDBC driver (via the serverTimezone configuration  property) to use a more specifc time zone value if you want to utilize  time zone support.</p>
<h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>原因是因为使用了Mysql Connector/J 6.x以上的版本，然后就报了时区的错误</p>
<p>遇到的问题 servertime=UTC导致时间差8个小时（MySQL jdbc 6.0 版本以上必须配置此参数）</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p> 在配置url的时候不能简单写成 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;数据库名</span><br></pre></td></tr></table></figure>

<p>而是要写成 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;数据库名?serverTimezone&#x3D;UTC</span><br></pre></td></tr></table></figure>

<p>而UTC代表的是全球标准时间 ，但是我们使用的时间是北京时区也就是东八区，领先UTC八个小时。</p>
<p>UTC + (＋0800) = 本地（北京）时间</p>
<h2 id="设置成中国时间"><a href="#设置成中国时间" class="headerlink" title="设置成中国时间"></a>设置成中国时间</h2><p>url的时区使用中国标准时间。也是就</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">jdbc:mysql://localhost:3306/数据库名?serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL-JDBC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle命令行黑魔法</title>
    <url>/2020/11/17/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/Gradle%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%BB%91%E9%AD%94%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Gradle命令行黑魔法"><a href="#Gradle命令行黑魔法" class="headerlink" title="Gradle命令行黑魔法"></a>Gradle命令行黑魔法</h1><p>毫无疑问，现在Gradle已经成为java世界最火的构建工具，风头已经盖过了冗余的ant，落后的maven。Gradle是以Groovy语言编写的一套构建脚本的DSL，由于Groovy语法的优雅，所以导致Gradle天生就有简洁、可读性强、灵活等特性。</p>
<p>Gradle的命令行功能也非常强大。本人从maven转到Gradle，深深被gradle强大的命令行功能折服。通过命令行来实现Gradle的各种特性，就像魔法师在表演魔法一样。</p>
<h2 id="日志输出。"><a href="#日志输出。" class="headerlink" title="日志输出。"></a><strong>日志输出。</strong></h2><p>Gradle中的日志有6个层级。从高到低分别是  ERROR（错误信息）、QUIET（重要信息）、WARNGING（警告信息）、LIFECYCLE（进程信息）、INFO（一般信息）、DEBUG（调试信息）。在执行gradle task时可以适时的调整信息输出等级，以便更方便的观看执行结果。</p>
<p><code>-q</code>(或<code>--quiet</code>)是启用重要信息级别，该级别下只会输出自己在命令行下打印的信息及错误信息。</p>
<p><code>-i</code>(或<code>--info</code>)则会输出除debug以外的所有信息。</p>
<p><code>-d</code>（或<code>--debug</code>)会输出所有日志信息。</p>
<p>比如一个build.gradle有这样一个task。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">     println &#39;hello world!&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入<code>-q</code>与不加<code>-q</code>的输出结果不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gradle hello</span><br><span class="line">:hello</span><br><span class="line">hello world!</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 3.546 secs</span><br><span class="line">$ gradle -q hello</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<h2 id="堆栈跟踪。"><a href="#堆栈跟踪。" class="headerlink" title="堆栈跟踪。"></a><strong>堆栈跟踪。</strong></h2><p>如果执行gradle task失败时，如果想得到更详细的错误信息，那么就可以使用<code>-s</code>(或<code>--stacktrace</code>)来输出详细的错误堆栈。你还可以使用<code>-S</code>(或<code>--full-stacktrace</code>)来输出全部堆栈信息，不过一般不推荐这样做，因为gradle是基于groovy语言，而groovy作为一门动态语言可能会输出与你的错误代码毫不相关的信息。</p>
<h2 id="跳过指定的测试。"><a href="#跳过指定的测试。" class="headerlink" title="跳过指定的测试。"></a><strong>跳过指定的测试。</strong></h2><p>如果你在执行build的时候想跳过test task，那么可以使用<code>-x</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gradle build -x test</span><br><span class="line">:compileJava UP-TO-DATE</span><br><span class="line">:processResources UP-TO-DATE</span><br><span class="line">:classes UP-TO-DATE</span><br><span class="line">:jar UP-TO-DATE</span><br><span class="line">:assemble UP-TO-DATE</span><br><span class="line">:check</span><br><span class="line">:build</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 3.529 secs</span><br></pre></td></tr></table></figure>

<h2 id="继续执行task而忽略前面失败的task。"><a href="#继续执行task而忽略前面失败的task。" class="headerlink" title="继续执行task而忽略前面失败的task。"></a><strong>继续执行task而忽略前面失败的task。</strong></h2><p>默认情况下，如果有某个task失败，后续的task就不会继续执行。但是有时候我们想运行所有的task来一次性得到所有的构建错误，那么我们可以使用<code>--continue</code>命令。使用<code>--continue</code>命令后即使遇到某些task失败也不会停止后续task的执行。但是需要注意的是如果某个task失败了，那么依赖于这个task的其他task依旧不会执行，因为这会带来不安全的因素。</p>
<h2 id="调用task时使用短名或缩写。"><a href="#调用task时使用短名或缩写。" class="headerlink" title="调用task时使用短名或缩写。"></a><strong>调用task时使用短名或缩写。</strong></h2><p>如果一个task的名称过长，那么调用时可以只输入部分名称即可调用，无需输入全名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task helloWorld &lt;&lt; &#123;</span><br><span class="line">     println &#39;hello world!&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如调用helloWorld可以通过全名调用、前缀调用或首字母调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gradle -q helloWorld</span><br><span class="line">hello world!</span><br><span class="line">$ gradle -q hell</span><br><span class="line">hello world!</span><br><span class="line">$ gradle -q hW</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<h2 id="使用指定的gradle文件调用task。"><a href="#使用指定的gradle文件调用task。" class="headerlink" title="使用指定的gradle文件调用task。"></a><strong>使用指定的gradle文件调用task。</strong></h2><p>默认情况下，如果你调用gradle task，那么首先会寻找当前目录下的build.gradle文件,以及根据settings.gradle中的配置寻找子项目的build.gradle。但是有时候我们想指定使用某个gradle文件，那么可以使用<code>-b</code>命令。 比如当前目录有个子目录subproject1,里面有个叫hello.gradle。</p>
<p>subproject1/hello.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task helloWorld &lt;&lt; &#123;</span><br><span class="line">     println &#39;hello world!&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在当前目录可以使用以下命令调用这个task。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gradle -b subproject1&#x2F;hello.gradle  helloWorld</span><br><span class="line">:helloWorld</span><br><span class="line">hello world!</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 3.752 secs</span><br></pre></td></tr></table></figure>

<h2 id="使用指定的项目目录调用task。"><a href="#使用指定的项目目录调用task。" class="headerlink" title="使用指定的项目目录调用task。"></a><strong>使用指定的项目目录调用task。</strong></h2><p>前面已经说过，执行gradle的task默认会在当前目录寻找build.gradle及settings.gradle文件。如果我们想在任何地方执行某个项目的task，那么可以使用<code>-p</code>来指定使用的项目。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gradle -q -p learnGradle helloWorld </span><br></pre></td></tr></table></figure>

<p>这条命令是调用learnGradle这个项目下的helloWorld task。</p>
<h2 id="显示task之间的依赖关系。"><a href="#显示task之间的依赖关系。" class="headerlink" title="显示task之间的依赖关系。"></a><strong>显示task之间的依赖关系。</strong></h2><p>众所周知，使用<code>gradle tasks</code>可以列出当前所有可被使用的task，但是并没有显示task之间的依赖关系。我们可以加上<code>--all</code>来显示 task的依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gradle tasks --all</span><br><span class="line">………………</span><br><span class="line"></span><br><span class="line">Other tasks</span><br><span class="line">-----------</span><br><span class="line">task0</span><br><span class="line">    task1</span><br><span class="line">    task2</span><br><span class="line">    task3</span><br><span class="line"></span><br><span class="line">…………</span><br></pre></td></tr></table></figure>

<p>从上面可以看出task0依赖task1、task2及task3。</p>
<h2 id="查看指定阶段的依赖关系。"><a href="#查看指定阶段的依赖关系。" class="headerlink" title="查看指定阶段的依赖关系。"></a><strong>查看指定阶段的依赖关系。</strong></h2><p>使用<code>gradle dependencies</code> 可以查看项目中包的依赖关系。不过是列出了所有阶段的依赖，如果项目中依赖复杂的话看起来有点头痛。那么可以使用<code>--configuration</code>来查看指定阶段的依赖情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gradle -q dependencies</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">archives - Configuration for archive artifacts.</span><br><span class="line">No dependencies</span><br><span class="line"></span><br><span class="line">compile - Compile classpath for source set &#39;main&#39;.</span><br><span class="line">No dependencies</span><br><span class="line"></span><br><span class="line">default - Configuration for default artifacts.</span><br><span class="line">No dependencies</span><br><span class="line"></span><br><span class="line">runtime - Runtime classpath for source set &#39;main&#39;.</span><br><span class="line">No dependencies</span><br><span class="line"></span><br><span class="line">testCompile - Compile classpath for source set &#39;test&#39;.</span><br><span class="line">\--- junit:junit:4.11</span><br><span class="line">     \--- org.hamcrest:hamcrest-core:1.3</span><br><span class="line"></span><br><span class="line">testRuntime - Runtime classpath for source set &#39;test&#39;.</span><br><span class="line">\--- junit:junit:4.11</span><br><span class="line">     \--- org.hamcrest:hamcrest-core:1.3</span><br></pre></td></tr></table></figure>

<p>使用<code>gradle -q dependencies --configuration testCompile</code>可以只查看testComiple的依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gradle -q dependencies --configuration testCompile</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">testCompile - Compile classpath for source set &#39;test&#39;.</span><br><span class="line">\--- junit:junit:4.11</span><br><span class="line">     \--- org.hamcrest:hamcrest-core:1.3</span><br></pre></td></tr></table></figure>

<h2 id="查看指定dependency的依赖情况。"><a href="#查看指定dependency的依赖情况。" class="headerlink" title="查看指定dependency的依赖情况。"></a><strong>查看指定dependency的依赖情况。</strong></h2><p>假如我想查看项目中有没有引入junit，那些阶段引入了junit，那么可以使用<code>dependecyInsight</code>来查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gradle dependencyInsight --dependency junit --configuration testCompile</span><br><span class="line">:dependencyInsight</span><br><span class="line">junit:junit:4.11</span><br><span class="line">\--- testCompile</span><br></pre></td></tr></table></figure>

<p>注意<code>dependencyInsight</code>默认只会查看compile阶段的依赖，如果要查看其他阶段可以使用<code>--configuration</code>来指定。</p>
<h2 id="使用-profile命令行可以产生build运行时间的报告。"><a href="#使用-profile命令行可以产生build运行时间的报告。" class="headerlink" title="使用--profile命令行可以产生build运行时间的报告。"></a><strong>使用<code>--profile</code>命令行可以产生build运行时间的报告。</strong></h2><p>该报告存储在build/report/profile目录，名称为build运行的时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gradle build --profile</span><br><span class="line">:compileJava UP-TO-DATE</span><br><span class="line">:processResources UP-TO-DATE</span><br><span class="line">:classes UP-TO-DATE</span><br><span class="line">:jar UP-TO-DATE</span><br><span class="line">:assemble UP-TO-DATE</span><br><span class="line">:compileTestJava UP-TO-DATE</span><br><span class="line">:processTestResources UP-TO-DATE</span><br><span class="line">:testClasses UP-TO-DATE</span><br><span class="line">:test UP-TO-DATE</span><br><span class="line">:check UP-TO-DATE</span><br><span class="line">:build UP-TO-DATE</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 3.726 secs</span><br></pre></td></tr></table></figure>

<p>然后在build/report/profile目录下可以看到build的report。</p>
<p><img src="/2020/11/17/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/Gradle%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%BB%91%E9%AD%94%E6%B3%95/gradle_profile.png" alt="img"></p>
<p>这个报表非常有用，尤其是在在缩短build时间时可以快速定位那些耗时长的task。</p>
<h2 id="试运行build。"><a href="#试运行build。" class="headerlink" title="试运行build。"></a><strong>试运行build。</strong></h2><p>如果你想知道某个task执行时那些task会被一起执行，但是你又不想真正的执行这些task，可以使用<code>-m</code>来试运行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gradle -m build</span><br><span class="line">:compileJava SKIPPED</span><br><span class="line">:processResources SKIPPED</span><br><span class="line">:classes SKIPPED</span><br><span class="line">:jar SKIPPED</span><br><span class="line">:assemble SKIPPED</span><br><span class="line">:compileTestJava SKIPPED</span><br><span class="line">:processTestResources SKIPPED</span><br><span class="line">:testClasses SKIPPED</span><br><span class="line">:test SKIPPED</span><br><span class="line">:check SKIPPED</span><br><span class="line">:build SKIPPED</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 3.53 secs</span><br></pre></td></tr></table></figure>

<p>这样我们可以一目了然的看到那些task被执行了，又不需要花太多的时间。</p>
<h2 id="Gradle的图形界面。"><a href="#Gradle的图形界面。" class="headerlink" title="Gradle的图形界面。"></a><strong>Gradle的图形界面。</strong></h2><p>其实Gradle自带一个图形界面来让习惯gui操作的人来操作Gradle。打开方式很简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gradle --gui </span><br></pre></td></tr></table></figure>

<p>这样就会弹出一个gui界面。</p>
<p><img src="/2020/11/17/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/Gradle%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%BB%91%E9%AD%94%E6%B3%95/gradle_gui.png" alt="img"></p>
<p>通过这个gui界面可以很方面的执行gradle的各种命令，还可以将常用的命令保存为favorites。该gui的配置信息默认被存储在当前项目的gradle-app.setting文件中。</p>
<p>注意使用<code>gradle --gui</code>会阻塞当前终端，可以使用<code>gradle --gui&amp;</code>来实现后台运行。</p>
<h2 id="重新编译Gradle脚本。"><a href="#重新编译Gradle脚本。" class="headerlink" title="重新编译Gradle脚本。"></a><strong>重新编译Gradle脚本。</strong></h2><p>第一次运行Gradle命令，会在项目更目录下生成一个.gradle目录来存放编译后的脚本。只有当构建脚本发生修改时采用重新编译。我们可以使用<code>--recompile-scripts</code>来强行重新编译。</p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven和Gradle对比</title>
    <url>/2020/10/14/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/Maven%E5%92%8CGradle%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h1 id="Maven和Gradle对比"><a href="#Maven和Gradle对比" class="headerlink" title="Maven和Gradle对比"></a>Maven和Gradle对比</h1><p>Java世界中主要有三大构建工具：Ant、Maven和Gradle。经过几年的发展，Ant几乎销声匿迹、Maven也日薄西山，而Gradle的发展则如日中天。笔者有幸见证了Maven的没落和Gradle的兴起。Maven的主要功能主要分为5点，分别是依赖管理系统、多模块构建、一致的项目结构、一致的构建模型和插件机制。我们可以从这五个方面来分析一下Gradle比起Maven的先进之处。</p>
<h2 id="依赖管理系统"><a href="#依赖管理系统" class="headerlink" title="依赖管理系统"></a>依赖管理系统</h2><p>Maven为Java世界引入了一个新的依赖管理系统。在Java世界中，可以用groupId、artifactId、version组成的Coordination（坐标）唯一标识一个依赖。任何基于Maven构建的项目自身也必须定义这三项属性，生成的包可以是Jar包，也可以是war包或者ear包。一个典型的依赖引用如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;    &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;    &lt;version&gt;4.12&lt;&#x2F;version&gt;    &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; </span><br></pre></td></tr></table></figure>

<p>从上面可以看出当引用一个依赖时，version可以省略掉，这样在获取依赖时会选择最新的版本。而存储这些组件的仓库有远程仓库和本地仓库之分。远程仓库可以使用世界公用的central仓库，也可以使用Apache  Nexus自建私有仓库；本地仓库则在本地计算机上。通过Maven安装目录下的settings.xml文件可以配置本地仓库的路径，以及采用的远程仓库的地址。</p>
<p>Gradle在设计的时候基本沿用了Maven的这套依赖管理体系。不过它在引用依赖时还是进行了一些改进。</p>
<ol>
<li>首先引用依赖方面变得非常简洁。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &#39;org.hibernate:hibernate-core:3.6.7.Final&#39;</span><br><span class="line">    testCompile ‘junit:junit:4.+&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>第二，Maven和Gradle对依赖项的scope有所不同。在Maven世界中，一个依赖项有6种scope，分别是complie(默认)、provided、runtime、test、system、import。而grade将其简化为了4种，compile、runtime、testCompile、testRuntime。那么如果想在gradle使用类似于provided的scope怎么办？别着急，由于gradle语言的强大表现力，我们可以轻松编写代码来实现类似于provided scope的概念（例如<a href="http://stackoverflow.com/questions/18738888/how-to-use-provided-scope-for-jar-file-in-gradle-build">How to use provided scope for jar file in Gradle build?</a>）。</p>
</li>
<li><p>第三点是Gradle支持动态的版本依赖。在版本号后面使用+号的方式可以实现动态的版本管理。</p>
</li>
<li><p>第四点是在解决依赖冲突方面Gradle的实现机制更加明确。使用Maven和Gradle进行依赖管理时都采用的是传递性依赖；而如果多个依赖项指向同一个依赖项的不同版本时就会引起依赖冲突。而Maven处理这种依赖关系往往是噩梦一般的存在。而Gradle在解决依赖冲突方面相对来说比较明确。在<a href="https://docs.gradle.org/current/userguide/dependency_management.html">Chapter 23. Dependency Management </a>中的23.2.3章节详细解读了gradle是如何处理版本冲突的。</p>
</li>
</ol>
<h2 id="多模块构建"><a href="#多模块构建" class="headerlink" title="多模块构建"></a>多模块构建</h2><p>在SOA和微服务的浪潮下，将一个项目分解为多个模块已经是很通用的一种方式。在Maven中需要定义个parent POM作为一组module的聚合POM。在该POM中可以使用<code>&lt;modules&gt;</code>标签来定义一组子模块。parent POM不会有什么实际构建产出。而parent POM中的build配置以及依赖配置都会自动继承给子module。</p>
<p>而Gradle也支持多模块构建。而在parent的build.gradle中可以使用allprojects和subprojects代码块来分别定义里面的配置是应用于所有项目还是子项目。对于子模块的定义是放置在setttings.gradle文件中的。在gradle的设计当中，每个模块都是Project的对象实例。而在parent build.gradle中通过allprojects或subprojects可以对这些对象进行各种操作。这无疑比Maven要灵活的多。</p>
<p>比如在parent的build.gradle中有以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    task hello &lt;&lt; &#123; task -&gt; println &quot;I&#39;m $task.project.name&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令<code>gradle -q hello</code>会依次打印出父module以及各个submodule的项目名称。这种强大的能力能让gradle对各个模块具有更强的定制化。</p>
<h2 id="一致的项目结构"><a href="#一致的项目结构" class="headerlink" title="一致的项目结构"></a>一致的项目结构</h2><p>在Ant时代大家创建Java项目目录时比较随意，然后通过Ant配置指定哪些属于source，那些属于testSource等。而Maven在设计之初的理念就是Conversion over configuration（约定大于配置）。其制定了一套项目目录结构作为标准的Java项目结构。一个典型的Maven项目结构如下：</p>
<p><img src="/2020/10/14/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/Maven%E5%92%8CGradle%E5%AF%B9%E6%AF%94/project_structure.png" alt="img"></p>
<p>Gradle也沿用了这一标准的目录结构。如果你在Gradle项目中使用了标准的Maven项目结构的话，那么在Gradle中也无需进行多余的配置,只需在文件中包含<code>apply plugin:&#39;java&#39;</code>,系统会自动识别source、resource、test srouce、 test  resource等相应资源。不过Gradle作为JVM上的构建工具，也同时支持groovy、scala等源代码的构建，甚至支持Java、groovy、scala语言的混合构建。虽然Maven通过一些插件（比如<a href="http://scala-tools.org/mvnsites/maven-scala-plugin/">maven-scala-plugin</a>）也能达到相同目的，但配置方面显然Gradle要更优雅一些。</p>
<h2 id="一致的构建模型"><a href="#一致的构建模型" class="headerlink" title="一致的构建模型"></a>一致的构建模型</h2><p>为了解决Ant中对项目构建活动缺乏标准化的问题，Maven特意设置了标准的项目构建周期，其默认的构建周期如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;phases&gt;</span><br><span class="line">  &lt;phase&gt;validate&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;initialize&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;generate-sources&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;process-sources&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;generate-resources&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;process-resources&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;compile&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;process-classes&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;generate-test-sources&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;process-test-sources&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;generate-test-resources&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;process-test-resources&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;test-compile&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;process-test-classes&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;test&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;prepare-package&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;package&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;pre-integration-test&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;integration-test&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;post-integration-test&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;verify&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;install&lt;&#x2F;phase&gt;</span><br><span class="line">  &lt;phase&gt;deploy&lt;&#x2F;phase&gt;</span><br><span class="line">&lt;&#x2F;phases&gt;</span><br></pre></td></tr></table></figure>

<p>而这种构建周期也是Maven最为人诟病的地方。因为Maven将项目的构建周期限制的太死，你无法在构建周期中添加新的phase，只能将插件绑定到已有的phase上。而现在项目的构建过程变得越来越复杂，而且多样化，显然Maven对这种复杂度缺少足够的应变能力。比如你想在项目构建过程中进行一项压缩所有javascript的任务，那么就要绑定到Maven的现有的某个phase上，而显然貌似放在哪个phase都不太合适。而且这些phase都是串行的，整个执行下来是一条线，这也限制了Maven的构建效率。而Gradle在构建模型上则非常灵活。在Gradle世界里可以轻松创建一个task，并随时通过<code>depends</code>语法建立与已有task的依赖关系。甚至对于Java项目的构建来说，Gradle是通过名为<code>java</code>的插件来包含了一个对Java项目的构建周期，这等于Gradle本身直接与项目构建周期是解耦的。</p>
<h2 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h2><p>Maven和Gradle设计时都采用了插件机制。但显然Gradle更胜一筹。主要原因在于Maven是基于XML进行配置。所以其配置语法太受限于XML。即使实现很小的功能都需要设计一个插件，建立其与XML配置的关联。比如想在Maven中执行一条shell命令，其配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">  &lt;groupId&gt;org.codehaus.mojo&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;exec-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;executions&gt;</span><br><span class="line">    &lt;execution&gt;</span><br><span class="line">      &lt;id&gt;drop DB &#x3D;&gt; db_name&lt;&#x2F;id&gt;</span><br><span class="line">      &lt;phase&gt;pre-integration-test&lt;&#x2F;phase&gt;</span><br><span class="line">      &lt;goals&gt;</span><br><span class="line">        &lt;goal&gt;exec&lt;&#x2F;goal&gt;</span><br><span class="line">      &lt;&#x2F;goals&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;executable&gt;curl&lt;&#x2F;executable&gt;</span><br><span class="line">        &lt;arguments&gt;</span><br><span class="line">          &lt;argument&gt;-s&lt;&#x2F;argument&gt;</span><br><span class="line">          &lt;argument&gt;-S&lt;&#x2F;argument&gt;</span><br><span class="line">          &lt;argument&gt;-X&lt;&#x2F;argument&gt;</span><br><span class="line">          &lt;argument&gt;DELETE&lt;&#x2F;argument&gt;</span><br><span class="line">          &lt;argument&gt;http:&#x2F;&#x2F;$&#123;db.server&#125;:$&#123;db.port&#125;&#x2F;db_name&lt;&#x2F;argument&gt;</span><br><span class="line">        &lt;&#x2F;arguments&gt;</span><br><span class="line">      &lt;&#x2F;configuration&gt;</span><br><span class="line">    &lt;&#x2F;execution&gt;</span><br><span class="line">  &lt;&#x2F;executions&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure>

<p>而在Gradle中则一切变得非常简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task dropDB(type: Exec) &#123;</span><br><span class="line"> commandLine ‘curl’,’-s’,’s’,’-x’,’DELETE’,&quot;http:&#x2F;&#x2F;$&#123;db.server&#125;:&#123;db.port&#125;&#x2F;db_name&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在创建自定义插件方面，Maven和Gradle的机制都差不多，都是继承自插件基类，然后实现要求的方法。这里就不展开说明。</p>
<hr>
<p>从以上五个方面可以看出Maven和Gradle的主要差异。Maven的设计核心<code>Convention Over Configuration</code>被Gradle更加发扬光大，而Gradle的<code>配置即代码</code>又超越了Maven。在Gradle中任何配置都可以作为代码被执行的，我们也可以随时使用已有的Ant脚本（Ant task是Gradle中的一等公民）、Java类库、Groovy类库来辅助完成构建任务的编写。</p>
<p>这种采用本身语言实现的DSL对本身语言项目进行构建管理的例子比比皆是。比如Rake和Ruby、Grunt和JavaScript、Sbt和Ruby…..而Gradle之所以使用Groovy语言实现，是因为Groovy比Java语言更具表现力，其语法特性更丰富，又兼具函数式的特点。这几年兴起的语言（比如Scala、Go、Swift）都属于强类型的语言，兼具面向对象和函数式的特点。</p>
<p>Gradle的命令行比Maven的也要要强大的多。</p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle 打包springboot war包部署到tomcat</title>
    <url>/2020/10/14/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/gradle-%E6%89%93%E5%8C%85springboot-war%E5%8C%85%E9%83%A8%E7%BD%B2%E5%88%B0tomcat/</url>
    <content><![CDATA[<h2 id="gradle把SpringBoot项目打成war包在tomcat中运行"><a href="#gradle把SpringBoot项目打成war包在tomcat中运行" class="headerlink" title="gradle把SpringBoot项目打成war包在tomcat中运行"></a>gradle把SpringBoot项目打成war包在tomcat中运行</h2><p>springboot项目内置有tomcat容器，打war包时需要去掉项目中内置的tomcat的相关jar包，否则启动会报错。</p>
<ol>
<li>首先在eclipse中配置好gradle;</li>
</ol>
<p><img src="/2020/10/14/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/gradle-%E6%89%93%E5%8C%85springboot-war%E5%8C%85%E9%83%A8%E7%BD%B2%E5%88%B0tomcat/9f6154c1a465f09f4d70495110b8ed7c.png" alt="img"></p>
<ol start="2">
<li>找到项目中配置的build.gradle文件，把spring-boot-starter-tomcat的jar包引入方式改为providedCompile，改为providedCompile后spring-boot-starter-tomcat的jar包只会在编译时引入，在打包时不会引入该jar包；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">providedCompile group: <span class="string">&#x27;org.springframework.boot&#x27;</span>, name: <span class="string">&#x27;spring-boot-starter-tomcat&#x27;</span>, version: springBootVersion</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>打开Gradle Tasks窗口；</li>
</ol>
<p><img src="/2020/10/14/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/gradle-%E6%89%93%E5%8C%85springboot-war%E5%8C%85%E9%83%A8%E7%BD%B2%E5%88%B0tomcat/ffbc503b2dadf62a58a4dd9900e6e450.png" alt="img"></p>
<ol start="4">
<li>在Gradle Task窗口中的Project选项中选择要打包的项目，双击war按钮即可把war包打包至项目的\build\libs目录下。</li>
</ol>
<p><img src="/2020/10/14/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/gradle-%E6%89%93%E5%8C%85springboot-war%E5%8C%85%E9%83%A8%E7%BD%B2%E5%88%B0tomcat/91177840f3c1167a89958e2cac537450.png" alt="img"></p>
<ol start="5">
<li>把打包好的jar包放置在tomcat的webapps目录下，启动tomcat即可，此时项目运行的端口为tomcat的server.xml中配置的端口。</li>
</ol>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Gradle</tag>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title>一分钟上手Gradle</title>
    <url>/2020/10/14/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8BGradle/</url>
    <content><![CDATA[<h1 id="没用过Maven，没用过Gradle，直接上Gradle，一分钟直接使用"><a href="#没用过Maven，没用过Gradle，直接上Gradle，一分钟直接使用" class="headerlink" title="没用过Maven，没用过Gradle，直接上Gradle，一分钟直接使用"></a>没用过Maven，没用过Gradle，直接上Gradle，一分钟直接使用</h1><p>最近做项目，要使用Gradle构建工具，常用的构建工具有Ant，Maven和Gradle，综合来讲Gradle应该是这里面最好用的，Maven的配置有些残忍。<br>  使用之前，一直在查Gradle使用教程啥啥的，发现大家都从Groovy开始讲起，我想对于像我这样时间很急，急于使用Gradle构建Java程序的人，显然这些干货有点潮湿，所以我索性就不再看了，直接摸索这进行，下面就分享一下我所学的的东西，按步骤来讲： </p>
<ol>
<li><p>新建Gradle Project 。很简单 右键-&gt;Project，就会看到下图：<br><img src="/2020/10/14/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8BGradle/1" alt="这里写图片描述"></p>
</li>
<li><p>一路next，当然这个过程中的路径你可以选择改一下，如果不修改，其默认在C盘 </p>
</li>
<li><p>当建好一个Gradle Project后，如下：<br><img src="/2020/10/14/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8BGradle/2" alt="这里写图片描述"> </p>
</li>
<li><p>需要在src/main/java下写逻辑代码，在src/test/java下写测试代码。 </p>
</li>
<li><p>我对于Gradle的第一个印象是我不用再去CSDN上花积分下载jar包了。这些都可以在build.gradle中解决。打开build.gradle，会看到如下的内容：<br><img src="/2020/10/14/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8BGradle/3" alt="这里写图片描述"><br> 你只需将你使用的jar包在里面配置即可，即在dependencies（）里的compile（）里进行配置，你可能会想我只知道jar包叫mybatis，可是不知道具体叫啥，是的，配置需要详细的jar包版本等，这个可以去<strong>Maven中央仓库</strong>寻找，以mybatis的jar包为例子。你可以用度娘度一下，也可以输入下图的网址。<br><img src="/2020/10/14/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8BGradle/4" alt="这里写图片描述"><br>然后输入你要找的jar包。点击进去<br><img src="/2020/10/14/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8BGradle/5" alt="这里写图片描述"><br>这里就是需要的配置，maven的gradle的都有，你只需将内容<strong>复制</strong>进你的build.gradle里的dependencies（）下。 </p>
</li>
<li><p><strong>右键项目，选择Gradle，选择更新。</strong><br><img src="/2020/10/14/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8BGradle/6" alt="这里写图片描述"><br>会自己下载jar包，如果成功了，你会在这里看到这个jar包<br><img src="/2020/10/14/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02-Gradle/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8BGradle/7" alt="这里写图片描述">。 </p>
</li>
<li><p>结束</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven版本选型</title>
    <url>/2021/11/20/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01-Maven/Maven%E7%89%88%E6%9C%AC%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<p>IDE在使用maven的时候maven版本如果高于IDE版本太多的话，容易出现版本不匹配，报错的情况发生</p>
<p>此时对于版本问题发生的报错问题，要及时更换maven或者IDE版本，最好Maven发布时间早于IDE发布时间。</p>
<h1 id="Maven-Releases-History"><a href="#Maven-Releases-History" class="headerlink" title="Maven Releases History"></a>Maven Releases History</h1><p>Date format is: YYYY-MM-DD</p>
<h3 id="Maven-3-1"><a href="#Maven-3-1" class="headerlink" title="Maven 3.1+"></a>Maven 3.1+</h3><table>
<thead>
<tr>
<th>Release Date</th>
<th>Version</th>
<th>Required Java Version</th>
</tr>
</thead>
<tbody><tr>
<td><strong>2021-09-27</strong></td>
<td><strong>3.8.3</strong></td>
<td>Java 7</td>
</tr>
<tr>
<td>2021-08-04</td>
<td>3.8.2</td>
<td></td>
</tr>
<tr>
<td>2021-04-04</td>
<td>3.8.1</td>
<td></td>
</tr>
<tr>
<td><strong>2019-11-25</strong></td>
<td><strong>3.6.3</strong></td>
<td></td>
</tr>
<tr>
<td>2019-08-27</td>
<td>3.6.2</td>
<td></td>
</tr>
<tr>
<td>2019-04-04</td>
<td>3.6.1</td>
<td></td>
</tr>
<tr>
<td>2018-10-24</td>
<td>3.6.0</td>
<td></td>
</tr>
<tr>
<td><strong>2018-06-21</strong></td>
<td><strong>3.5.4</strong></td>
<td></td>
</tr>
<tr>
<td>2018-03-08</td>
<td>3.5.3</td>
<td></td>
</tr>
<tr>
<td>2017-10-24</td>
<td>3.5.2</td>
<td></td>
</tr>
<tr>
<td>2017-04-07</td>
<td>3.5.0</td>
<td></td>
</tr>
<tr>
<td>2017-03-24</td>
<td>3.5.0-beta-1</td>
<td></td>
</tr>
<tr>
<td>2017-02-28</td>
<td>3.5.0-alpha-1</td>
<td></td>
</tr>
<tr>
<td><strong>2015-11-14</strong></td>
<td><strong>3.3.9</strong></td>
<td></td>
</tr>
<tr>
<td>2015-04-28</td>
<td>3.3.3</td>
<td></td>
</tr>
<tr>
<td>2015-03-18</td>
<td>3.3.1</td>
<td></td>
</tr>
<tr>
<td><strong>2014-12-20</strong></td>
<td><strong>3.2.5</strong></td>
<td>Java 6</td>
</tr>
<tr>
<td>2014-08-17</td>
<td>3.2.3</td>
<td></td>
</tr>
<tr>
<td>2014-06-26</td>
<td>3.2.2</td>
<td></td>
</tr>
<tr>
<td>2014-02-21</td>
<td>3.2.1</td>
<td></td>
</tr>
<tr>
<td><strong>2013-10-04</strong></td>
<td><strong>3.1.1</strong></td>
<td>Java 5</td>
</tr>
<tr>
<td>2013-07-15</td>
<td>3.1.0</td>
<td></td>
</tr>
<tr>
<td>2013-06-10</td>
<td>3.1.0-alpha-1</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>3-JavaEE-包管理工具</category>
        <category>01-Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>创建maven项目报错“Cannot  hange  ersion  f  roject  acet  ynamic Web Module to 3.0.”</title>
    <url>/2020/11/17/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01-Maven/%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99%E2%80%9CCannot-hange-ersion-f-roject-acet-ynamic-Web-Module-to-3-0-%E2%80%9D/</url>
    <content><![CDATA[<h1 id="创建maven项目报错“Cannot-hange-ersion-f-roject-acet-ynamic-Web-Module-to-3-0-”"><a href="#创建maven项目报错“Cannot-hange-ersion-f-roject-acet-ynamic-Web-Module-to-3-0-”" class="headerlink" title="创建maven项目报错“Cannot  hange  ersion  f  roject  acet  ynamic Web Module to 3.0.”"></a>创建maven项目报错“Cannot  hange  ersion  f  roject  acet  ynamic Web Module to 3.0.”</h1><p><img src="/2020/11/17/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01-Maven/%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99%E2%80%9CCannot-hange-ersion-f-roject-acet-ynamic-Web-Module-to-3-0-%E2%80%9D/%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99.png"></p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>新建Maven项目，JAR包或者test目录显示灰色</title>
    <url>/2020/11/17/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01-Maven/%E6%96%B0%E5%BB%BAMaven%E9%A1%B9%E7%9B%AE%EF%BC%8Ctest%E5%8C%85%E6%88%96%E8%80%85JAR%E5%8C%85%E6%98%BE%E7%A4%BA%E7%81%B0%E8%89%B2/</url>
    <content><![CDATA[<h1 id="新建Maven项目，test包或者JAR包显示灰色"><a href="#新建Maven项目，test包或者JAR包显示灰色" class="headerlink" title="新建Maven项目，test包或者JAR包显示灰色"></a>新建Maven项目，test包或者JAR包显示灰色</h1><h2 id="src-test-文件夹显示灰色"><a href="#src-test-文件夹显示灰色" class="headerlink" title="src/test 文件夹显示灰色"></a>src/test 文件夹显示灰色</h2><ol>
<li>build path-&gt;configure build path-&gt;source,双击“conntains test source:yes” 变为“conntains test source:yes”<br> <img src="/2020/11/17/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01-Maven/%E6%96%B0%E5%BB%BAMaven%E9%A1%B9%E7%9B%AE%EF%BC%8Ctest%E5%8C%85%E6%88%96%E8%80%85JAR%E5%8C%85%E6%98%BE%E7%A4%BA%E7%81%B0%E8%89%B2/1" alt="在这里插入图片描述"></li>
<li>pom文件里面去掉或注释掉test<br> <img src="/2020/11/17/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01-Maven/%E6%96%B0%E5%BB%BAMaven%E9%A1%B9%E7%9B%AE%EF%BC%8Ctest%E5%8C%85%E6%88%96%E8%80%85JAR%E5%8C%85%E6%98%BE%E7%A4%BA%E7%81%B0%E8%89%B2/2" alt="在这里插入图片描述"></li>
</ol>
<h2 id="maven项目里jar包变成了灰色"><a href="#maven项目里jar包变成了灰色" class="headerlink" title="maven项目里jar包变成了灰色"></a>maven项目里jar包变成了灰色</h2><p><img src="/2020/11/17/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01-Maven/%E6%96%B0%E5%BB%BAMaven%E9%A1%B9%E7%9B%AE%EF%BC%8Ctest%E5%8C%85%E6%88%96%E8%80%85JAR%E5%8C%85%E6%98%BE%E7%A4%BA%E7%81%B0%E8%89%B2/3" alt="img"></p>
<p>是因为pom里面带上了<scope>XXX</scope>导致的，</p>
<h3 id="scope的分类"><a href="#scope的分类" class="headerlink" title="scope的分类"></a>scope的分类</h3><p>在POM 4中，<dependency>中还引入了<scope>，它主要管理依赖的部署。目前<scope>可以使用5个值： </scope></scope></dependency></p>
<p>* compile，缺省值，适用于所有阶段，会随着项目一起发布。<br>* provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。<br>* runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。<br>* test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。<br>* system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。</p>
<p>依赖范围控制哪些依赖在哪些classpath 中可用，哪些依赖包含在一个应用中。让我们详细看一下每一种范围：</p>
<ol>
<li><p><strong>compile（编译范围）</strong></p>
<p>compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath 中可用，同时它们也会被打包。</p>
</li>
<li><p><strong>provided</strong> <strong>（已提供范围）</strong></p>
<p>provided 依赖只有在当JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译 classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这个Servlet API  JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包。</p>
</li>
<li><p><strong>runtime（运行时范围）</strong></p>
<p>runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC<br>驱动实现。</p>
</li>
<li><p><strong>test</strong> <strong>（测试范围）</strong></p>
<p>test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。</p>
</li>
<li><p><strong>system</strong> <strong>（系统范围）</strong></p>
<p>system范围依赖与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖）。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>Eclipse</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>项目打包Maven Install报错：Perhaps you are running on a JRE rather than a JDK</title>
    <url>/2020/11/17/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01-Maven/%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85Maven-Install%E6%8A%A5%E9%94%99%EF%BC%9APerhaps-you-are-running-on-a-JRE-rather-than-a-JDK/</url>
    <content><![CDATA[<h1 id="项目打包Maven-Install报错：Perhaps-you-are-running-on-a-JRE-rather-than-a-JDK"><a href="#项目打包Maven-Install报错：Perhaps-you-are-running-on-a-JRE-rather-than-a-JDK" class="headerlink" title="项目打包Maven Install报错：Perhaps you are running on a JRE rather than a JDK"></a>项目打包Maven Install报错：Perhaps you are running on a JRE rather than a JDK</h1><p><img src="/2020/11/17/3-JavaEE-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01-Maven/%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85Maven-Install%E6%8A%A5%E9%94%99%EF%BC%9APerhaps-you-are-running-on-a-JRE-rather-than-a-JDK/%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85Maven-Install%E6%8A%A5%E9%94%99.png"></p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea在html里面的快捷键</title>
    <url>/2021/09/17/3-%E5%B8%B8%E7%94%A8IDE/IDEA/Idea%E5%9C%A8html%E9%87%8C%E9%9D%A2%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="IntelliJ-Idea里常用的快捷键"><a href="#IntelliJ-Idea里常用的快捷键" class="headerlink" title="IntelliJ-Idea里常用的快捷键"></a>IntelliJ-Idea里常用的快捷键</h1><table>
<thead>
<tr>
<th>Ctrl+/ 或 Ctrl+Shift+/</th>
<th>注释（// 或者/<em>…</em>/ ）</th>
</tr>
</thead>
<tbody><tr>
<td>Shift+F6</td>
<td>重构-重命名</td>
</tr>
<tr>
<td>Ctrl+X</td>
<td>删除行</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>复制行</td>
</tr>
<tr>
<td>Ctrl+G</td>
<td>查找行</td>
</tr>
<tr>
<td>Ctrl+Shift+Up/Down</td>
<td>代码向上/下移动。</td>
</tr>
<tr>
<td>F2 或Shift+F2</td>
<td>高亮错误或警告快速定位</td>
</tr>
<tr>
<td>写代码，按Tab</td>
<td>生成代码</td>
</tr>
<tr>
<td>选中文本，按Ctrl+Shift+F7</td>
<td>高亮显示所有该文本，按Esc高亮消失。</td>
</tr>
<tr>
<td>Ctrl+B</td>
<td>快速打开光标处的类或方法</td>
</tr>
<tr>
<td>Ctrl+E</td>
<td>最近打开的文件</td>
</tr>
<tr>
<td>Alt+F1</td>
<td>查找代码所在位置</td>
</tr>
<tr>
<td>Ctrl+Alt+L</td>
<td>格式化代码</td>
</tr>
<tr>
<td>Ctrl+R</td>
<td>替换文本</td>
</tr>
<tr>
<td>Ctrl+F</td>
<td>查找文本</td>
</tr>
<tr>
<td>Ctrl+P</td>
<td>方法参数提示</td>
</tr>
<tr>
<td>Ctrl+shift+c</td>
<td>拷贝文件路径</td>
</tr>
<tr>
<td>Ctrl+alt+shift+c</td>
<td>拷贝相关数据 包括路径和所在行</td>
</tr>
<tr>
<td>Ctrl+shift+v</td>
<td>从历史记录中粘贴</td>
</tr>
<tr>
<td>ctrl+Y</td>
<td>删除整行</td>
</tr>
<tr>
<td>ctrl+shift+enter</td>
<td>新建行</td>
</tr>
<tr>
<td>ctrl+alt+enter</td>
<td>在当前行前面新建行</td>
</tr>
<tr>
<td>Ctrl+Shift+N</td>
<td>查找文件</td>
</tr>
<tr>
<td>ctrl+alt+t</td>
<td>选中代码可以添加try catch等</td>
</tr>
</tbody></table>
<h2 id="zencoding-输入左边缩写，按下tab键就ok啦（在html里的快捷键）"><a href="#zencoding-输入左边缩写，按下tab键就ok啦（在html里的快捷键）" class="headerlink" title="zencoding-输入左边缩写，按下tab键就ok啦（在html里的快捷键）"></a>zencoding-输入左边缩写，按下tab键就ok啦（在html里的快捷键）</h2><table>
<thead>
<tr>
<th>html:5</th>
<th><a href="http://lib.csdn.net/base/html5">HTML5</a>结构</th>
</tr>
</thead>
<tbody><tr>
<td>link:css</td>
<td>引入css</td>
</tr>
<tr>
<td>script:src</td>
<td>引入<a href="http://lib.csdn.net/base/javascript">js</a></td>
</tr>
<tr>
<td>script</td>
<td>html中插入js</td>
</tr>
<tr>
<td>ul+</td>
<td>ul及一个li</td>
</tr>
<tr>
<td>a:link</td>
<td><a href="”http://”"></a></td>
</tr>
<tr>
<td>a:mail</td>
<td><a href="”mailto:“"></a></td>
</tr>
<tr>
<td>form:get</td>
<td>get表单</td>
</tr>
<tr>
<td>input:hidden</td>
<td>hidden输入框</td>
</tr>
<tr>
<td>div#name</td>
<td>id:name</td>
</tr>
<tr>
<td>div.name</td>
<td>class:name</td>
</tr>
<tr>
<td>div.one.two</td>
<td>class:one,two</td>
</tr>
<tr>
<td>head&gt;link:css</td>
<td>head加link</td>
</tr>
<tr>
<td>p+p</td>
<td>两个p</td>
</tr>
<tr>
<td>p*3</td>
<td>3个p</td>
</tr>
<tr>
<td>ul&gt;li.item$*6</td>
<td>创建ul下有个li同时class分别为item1，item2.。。</td>
</tr>
<tr>
<td>pos</td>
<td>postion,组合可用pos:s|a|r|f</td>
</tr>
<tr>
<td>t</td>
<td>top,组合a auto</td>
</tr>
<tr>
<td>r</td>
<td>right,组合 a</td>
</tr>
<tr>
<td>l</td>
<td>left</td>
</tr>
<tr>
<td>b</td>
<td>bottom</td>
</tr>
<tr>
<td>z</td>
<td>z-index</td>
</tr>
<tr>
<td>fl</td>
<td>float</td>
</tr>
<tr>
<td>cl</td>
<td>clear</td>
</tr>
<tr>
<td>d</td>
<td>display 组合可用n|b|i|ib</td>
</tr>
<tr>
<td>v</td>
<td>visibility</td>
</tr>
<tr>
<td>ov</td>
<td>overflow</td>
</tr>
<tr>
<td>zoo</td>
<td>zoom:1</td>
</tr>
<tr>
<td>cp</td>
<td>clip</td>
</tr>
<tr>
<td>bx</td>
<td>box-sizing</td>
</tr>
<tr>
<td>bxsh:w</td>
<td>-webkit-box-shadow: 0 0 0 #000;</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>IDEA-Maven报Unable-to-import-maven-project</title>
    <url>/2020/10/26/3-%E5%B8%B8%E7%94%A8IDE/IDEA/IDEA-Maven%E6%8A%A5Unable-to-import-maven-project/</url>
    <content><![CDATA[<h2 id="IDEA-Maven报Unable-to-import-maven-project-See-logs-for-details解决方法"><a href="#IDEA-Maven报Unable-to-import-maven-project-See-logs-for-details解决方法" class="headerlink" title="IDEA Maven报Unable to import maven project See logs for details解决方法"></a>IDEA Maven报Unable to import maven project See logs for details解决方法</h2><p><img src="/2020/10/26/3-%E5%B8%B8%E7%94%A8IDE/IDEA/IDEA-Maven%E6%8A%A5Unable-to-import-maven-project/%E5%9B%BE%E7%89%87.png" alt="IDEA"></p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA排错</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ-IDEA中Project和Module的概念及区别</title>
    <url>/2020/10/19/3-%E5%B8%B8%E7%94%A8IDE/IDEA/IntelliJ-IDEA%E4%B8%ADProject%E5%92%8CModule%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="IntelliJ-IDEA-中-Project-和-Module-的概念及区别"><a href="#IntelliJ-IDEA-中-Project-和-Module-的概念及区别" class="headerlink" title="IntelliJ IDEA 中 Project 和 Module 的概念及区别"></a>IntelliJ IDEA 中 Project 和 Module 的概念及区别</h1><p>在 IntelliJ IDEA 中，没有类似于 Eclipse 工作空间（<code>Workspace</code>）的概念，而是提出了<code>Project</code>和<code>Module</code>这两个概念。接下来，就让我们一起看看 IntelliJ IDEA 官方是如何描述两者的吧！<strong>对于 Project，IntelliJ IDEA 官方是这样介绍的</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A project is a top-level organizational unit for your  development work in IntelliJ IDEA. In its finished form, a project may  represent a complete software solution. A project is a collection of:</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Your work results: source code, build scripts, configuration files, documentation, artifacts, etc.</code></li>
<li><code>SDKs and libraries that you use to develop, compile, run and test your code.</code></li>
<li><code>Project settings that represent your working preferences in the context of a project.</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A project has one or more modules as its parts.</span><br></pre></td></tr></table></figure>

<p><strong>对于 Module，IntelliJ IDEA 官方是这样介绍的</strong>：</p>
<ul>
<li><code>A module is a part of a project that you can compile, run, test and debug independently.</code></li>
<li><code>Modules are a way to reduce complexity of large projects while maintaining a common (project) configuration.</code></li>
<li><code>Modules are reusable: if necessary, a module can be included in more than one project.</code></li>
</ul>
<p>通过上面的介绍，我们知道：在 IntelliJ IDEA 中<code>Project</code>是最顶级的结构单元，然后就是<code>Module</code>，一个<code>Project</code>可以有多个<code>Module</code>。目前，主流的大型项目结构基本都是多<code>Module</code>的结构，这类项目一般是按功能划分的，比如：<code>user-core-module</code>、<code>user-facade-module</code>和<code>user-hessian-module</code>等等，模块之间彼此可以相互依赖。通过这些<code>Module</code>的命名可以看出，它们都是处于同一个项目中的模块，彼此之间是有着不可分割的业务关系。因此，我们可以大致总结出：一个<code>Project</code>是由一个或多个<code>Module</code>组成，</p>
<ul>
<li>当为单<code>Module</code>项目的时候，这个单独的<code>Module</code>实际上就是一个<code>Project</code>；</li>
<li>当为多<code>Module</code>项目的时候，多个模块处于同一个<code>Project</code>之中，此时彼此之间具有互相依赖的关联关系。</li>
</ul>
<p>此外， IntelliJ IDEA 的<code>Project</code>是一个不具备任何编码设置、构建等开发功能的概念，其主要作用就是起到一个项目定义、范围约束、规范类型的效果，或许，我们也可以简单地理解<code>Project</code>就是一个单纯的目录，只是这个目录在命名上必须有其代表性的意义。在缺省情况下，IntelliJ IDEA 是默认单<code>Project</code>单<code>Module</code>的，这时<code>Project</code>和<code>Module</code>合二为一，在没有修改存储路径的时候，显然<code>Project</code>对<code>Module</code>具有强约束作用！不过说实话，这里就是将<code>Module</code>的内容放在了<code>Project</code>的目录下，实际上还是<code>Module</code>自己约束自己。</p>
<p><img src="/2020/10/19/3-%E5%B8%B8%E7%94%A8IDE/IDEA/IntelliJ-IDEA%E4%B8%ADProject%E5%92%8CModule%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8C%BA%E5%88%AB/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzIzMjEwMDU2MjYz" alt="000"></p>
<ul>
<li><strong>标注 1</strong>：<code>Project name</code>，项目名称；</li>
<li><strong>标注 2</strong>：<code>Project location</code>，项目存储地址；</li>
<li><strong>标注 3</strong>：<code>Module name</code>，模块名称；</li>
<li><strong>标注 4</strong>：<code>Module file location</code>，模块存储地址。</li>
</ul>
<p>如上图所示，通过观察<code>Project</code>和<code>Module</code>的存储地址，我们可以发现，IntelliJ IDEA 在此处建立了一个名为<code>user-core-module</code>的目录，并将其放在了名为<code>user-modules-project</code>的目录下，而没有将两个目录合二为一，也就为我们建立多<code>Module</code>的<code>Project</code>作了准备。</p>
<p><img src="/2020/10/19/3-%E5%B8%B8%E7%94%A8IDE/IDEA/IntelliJ-IDEA%E4%B8%ADProject%E5%92%8CModule%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8C%BA%E5%88%AB/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI0MTQxODEzNDk1" alt="111"></p>
<p>如上图所示，显然<code>user-modules-project</code>仅表现为一个目录而已。</p>
<p><img src="/2020/10/19/3-%E5%B8%B8%E7%94%A8IDE/IDEA/IntelliJ-IDEA%E4%B8%ADProject%E5%92%8CModule%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8C%BA%E5%88%AB/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI0MTQyNzUwNDI3" alt="112"></p>
<p>如上图所示，依次点击<code>File -&gt; New -&gt; Module</code>，进入如下界面：</p>
<p><img src="/2020/10/19/3-%E5%B8%B8%E7%94%A8IDE/IDEA/IntelliJ-IDEA%E4%B8%ADProject%E5%92%8CModule%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8C%BA%E5%88%AB/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI0MTQyOTEyNDk0" alt="113"></p>
<p>如上图所示，输入<code>Module name</code>之后，<code>Content root</code>和<code>Module file location</code>自动发生改变，然后点击<code>Finish</code>，完成：</p>
<p><img src="/2020/10/19/3-%E5%B8%B8%E7%94%A8IDE/IDEA/IntelliJ-IDEA%E4%B8%ADProject%E5%92%8CModule%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8C%BA%E5%88%AB/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI0MTQzMTAyMDI4" alt="114"></p>
<p>如上图所示，我们在项目<code>user-modules-project</code>中，建立了两个<code>Module</code>，分别为<code>user-core-module</code>和<code>user-hessian-module</code>，然后我们再来看看存储目录：</p>
<p><img src="/2020/10/19/3-%E5%B8%B8%E7%94%A8IDE/IDEA/IntelliJ-IDEA%E4%B8%ADProject%E5%92%8CModule%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8C%BA%E5%88%AB/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI0MTQzNTU2ODk5" alt="115"></p>
<p>如上图所示，显然在<code>user-modules-project</code>目录中，又多了一个名为<code>user-hessian-module</code>的目录。</p>
<p>至此，多<code>Module</code>的<code>Project</code>构建完成！</p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>idea2019版与maven3-6-2版本不兼容的解决方法</title>
    <url>/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/idea2019%E7%89%88%E4%B8%8Emaven3-6-2%E7%89%88%E6%9C%AC%E4%B8%8D%E5%85%BC%E5%AE%B9%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="idea2019版与maven3-6-2版本不兼容的解决方法"><a href="#idea2019版与maven3-6-2版本不兼容的解决方法" class="headerlink" title="idea2019版与maven3-6-2版本不兼容的解决方法"></a>idea2019版与maven3-6-2版本不兼容的解决方法</h2><p><img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/idea2019%E7%89%88%E4%B8%8Emaven3-6-2%E7%89%88%E6%9C%AC%E4%B8%8D%E5%85%BC%E5%AE%B9%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/%E7%89%88%E6%9C%AC%E4%B8%8D%E5%85%BC%E5%AE%B9%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.png" alt="idea2019版与maven3.6.2版本不兼容的解决方法"></p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>idea快捷键</title>
    <url>/2021/09/17/3-%E5%B8%B8%E7%94%A8IDE/IDEA/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="idea快捷键"><a href="#idea快捷键" class="headerlink" title="idea快捷键"></a>idea快捷键</h1><p><em>注：以下快捷键在mac系统中用command键替换Ctrl键（如：windows环境Ctrl+c对应于mac环境的command+c）</em>。</p>
<p>  <strong>【常用】</strong> </p>
<ol>
<li>Ctrl+Shift + Enter，语句完成 </li>
<li>“！”，否定完成，输入表达式时按 “！”键 </li>
<li>Ctrl+E，最近的文件 </li>
<li>Ctrl+Shift+E，最近更改的文件 </li>
<li>Shift+Click，可以关闭文件 </li>
<li>Ctrl+[ OR ]，可以跑到大括号的开头与结尾 </li>
<li>Ctrl+F12，可以显示当前文件的结构 </li>
<li>Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择 </li>
<li>Ctrl+N，可以快速打开类 </li>
<li>Ctrl+Shift+N，可以快速打开文件 </li>
<li>Alt+Q，可以看到当前方法的声明 </li>
<li>Ctrl+P，可以显示参数信息 </li>
<li>Ctrl+Shift+Insert，可以选择剪贴板内容并插入 </li>
<li>Alt+Insert，可以生成构造器/Getter/Setter等 </li>
<li>Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 </li>
<li>Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch </li>
<li>Ctrl+Enter，导入包，自动修正 </li>
<li>Ctrl+Alt+L，格式化代码 </li>
<li>Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作 </li>
<li>Ctrl+Alt+O，优化导入的类和包 </li>
<li>Ctrl+R，替换文本 </li>
<li>Ctrl+F，查找文本 </li>
<li>Ctrl+Shift+Space，自动补全代码 </li>
<li>Ctrl+空格，代码提示（与系统输入法快捷键冲突） </li>
<li>Ctrl+Shift+Alt+N，查找类中的方法或变量 </li>
<li>Alt+Shift+C，最近的更改 </li>
<li>Alt+Shift+Up/Down，上/下移一行 </li>
<li>Shift+F6，重构 - 重命名 </li>
<li>Ctrl+X，删除行 </li>
<li>Ctrl+D，复制行 </li>
<li>Ctrl+/或Ctrl+Shift+/，注释（//或者/**/） </li>
<li>Ctrl+J，自动代码（例如：serr） </li>
<li>Ctrl+Alt+J，用动态模板环绕 </li>
<li>Ctrl+H，显示类结构图（类的继承层次） </li>
<li>Ctrl+Q，显示注释文档 </li>
<li>Alt+F1，查找代码所在位置 </li>
<li>Alt+1，快速打开或隐藏工程面板 </li>
<li>Ctrl+Alt+left/right，返回至上次浏览的位置 </li>
<li>Alt+left/right，切换代码视图 </li>
<li>Alt+Up/Down，在方法间快速移动定位 </li>
<li>Ctrl+Shift+Up/Down，向上/下移动语句 </li>
<li>F2 或 Shift+F2，高亮错误或警告快速定位 </li>
<li>Tab，代码标签输入完成后，按 Tab，生成代码 </li>
<li>Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失 </li>
<li>Alt+F3，逐个往下查找相同文本，并高亮显示 </li>
<li>Ctrl+Up/Down，光标中转到第一行或最后一行下 </li>
<li>Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处） </li>
<li>Ctrl+Alt+B，跳转到方法实现处 </li>
<li>Ctrl+Shift+Backspace，跳转到上次编辑的地方 </li>
<li>Ctrl+O，重写方法 </li>
<li>Ctrl+Alt+Space，类名自动完成 </li>
<li>Ctrl+Alt+Up/Down，快速跳转搜索结果 </li>
<li>Ctrl+Shift+J，整合两行 </li>
<li>Alt+F8，计算变量值 </li>
<li>Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本 </li>
<li>Ctrl+Alt+Shift+V，简单粘贴 </li>
<li>Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口 </li>
<li>F12，把焦点从编辑器移到最近使用的工具窗口 </li>
<li>Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器 </li>
<li>Ctrl+W，可以选择单词继而语句继而行继而函数 </li>
<li>Ctrl+Shift+W，取消选择光标所在词 </li>
<li>Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置 </li>
<li>Ctrl+I，实现方法 </li>
<li>Ctrl+Shift+U，大小写转化 </li>
<li>Ctrl+Y，删除当前行 </li>
<li>Shift+Enter，向下插入新行 </li>
<li>psvm/sout，main/System.out.println(); Ctrl+J，查看更多 </li>
<li>Ctrl+Shift+F，全局查找 </li>
<li>Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找 </li>
<li>Ctrl+Shift+S，高级搜索 </li>
<li>Ctrl+U，转到父类 </li>
<li>Ctrl+Alt+S，打开设置对话框 </li>
<li>Alt+Shift+Inert，开启/关闭列选择模式 </li>
<li>Ctrl+Alt+Shift+S，打开当前项目/模块属性 </li>
<li>Ctrl+G，定位行 </li>
<li>Alt+Home，跳转到导航栏 </li>
<li>Ctrl+Enter，上插一行 </li>
<li>Ctrl+Backspace，按单词删除 </li>
<li>Ctrl+”+/-“，当前方法展开、折叠 </li>
<li>Ctrl+Shift+”+/-“，全部展开、折叠</li>
</ol>
<p>  <strong>【调试、编译】</strong> </p>
<ol>
<li>Ctrl+F2，停止</li>
<li></li>
<li>Alt+Shift+F9，选择 Debug </li>
<li>Alt+Shift+F10，选择 Run</li>
<li>Ctrl+Shift+F9，编译 </li>
<li>Ctrl+Shift+F10，运行</li>
<li>Ctrl+Shift+F8，查看断点</li>
<li>F8，步过</li>
<li>F7，步入</li>
<li>Shift+F7，智能步入</li>
<li>Shift+F8，步出</li>
<li>Alt+Shift+F8，强制步过</li>
<li>Alt+Shift+F7，强制步入</li>
<li>Alt+F9，运行至光标处</li>
<li>Ctrl+Alt+F9，强制运行至光标处</li>
<li>F9，恢复程序</li>
<li>Alt+F10，定位到断点</li>
<li>Ctrl+F8，切换行断点</li>
<li>Ctrl+F9，生成项目</li>
<li>Alt+1，项目</li>
<li>Alt+2，收藏</li>
<li>Alt+6，TODO</li>
<li>Alt+7，结构</li>
<li>Ctrl+Shift+C，复制路径</li>
<li>Ctrl+Alt+Shift+C，复制引用，必须选择类名</li>
<li>Ctrl+Alt+Y，同步</li>
<li>Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）</li>
<li>Shift+F12，还原默认布局</li>
<li>Ctrl+Shift+F12，隐藏/恢复所有窗口</li>
<li>Ctrl+F4，关闭</li>
<li>Ctrl+Shift+F4，关闭活动选项卡</li>
<li>Ctrl+Tab，转到下一个拆分器</li>
<li>Ctrl+Shift+Tab，转到上一个拆分器</li>
</ol>
<p>  <strong>【重构】</strong> </p>
<ol>
<li>Ctrl+Alt+Shift+T，弹出重构菜单</li>
<li>Shift+F6，重命名</li>
<li>F6，移动</li>
<li>F5，复制</li>
<li>Alt+Delete，安全删除</li>
<li>Ctrl+Alt+N，内联</li>
</ol>
<p>  <strong>【查找】</strong> </p>
<ol>
<li>Ctrl+F，查找</li>
<li>Ctrl+R，替换</li>
<li>F3，查找下一个</li>
<li>Shift+F3，查找上一个</li>
<li>Ctrl+Shift+F，在路径中查找</li>
<li>Ctrl+Shift+R，在路径中替换</li>
<li>Ctrl+Shift+S，搜索结构</li>
<li>Ctrl+Shift+M，替换结构</li>
<li>Alt+F7，查找用法</li>
<li>Ctrl+Alt+F7，显示用法</li>
<li>Ctrl+F7，在文件中查找用法</li>
<li>Ctrl+Shift+F7，在文件中高亮显示用法</li>
</ol>
<p>  <strong>【VCS】</strong> </p>
<ol>
<li>Alt+~，VCS 操作菜单</li>
<li>Ctrl+K，提交更改</li>
<li>Ctrl+T，更新项目</li>
<li>Ctrl+Alt+Shift+D，显示变化</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>如何调出IDEA的Maven-Project视图</title>
    <url>/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%A6%82%E4%BD%95%E8%B0%83%E5%87%BAIDEA%E7%9A%84Maven-Project%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="如何调出IDEA的Maven-Project-视图"><a href="#如何调出IDEA的Maven-Project-视图" class="headerlink" title="如何调出IDEA的Maven-Project-视图"></a>如何调出IDEA的Maven-Project-视图</h2><p><img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%A6%82%E4%BD%95%E8%B0%83%E5%87%BAIDEA%E7%9A%84Maven-Project%E8%A7%86%E5%9B%BE/123.png" alt="关于idea右侧的maven project 如何调出来"></p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>在Intellij-IDEA中使用Debug</title>
    <url>/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/</url>
    <content><![CDATA[<h1 id="在Intellij-IDEA中使用Debug"><a href="#在Intellij-IDEA中使用Debug" class="headerlink" title="在Intellij IDEA中使用Debug"></a>在Intellij IDEA中使用Debug</h1><p>　　Debug用来追踪代码的运行流程，通常在程序运行过程中出现异常，启用Debug模式可以分析定位异常发生的位置，以及在运行过程中参数的变化。通常我们也可以启用Debug模式来跟踪代码的运行流程去学习三方框架的源码。</p>
<p>　　所以学习下如何在Intellij IDEA中使用好Debug，主要包括如下内容：</p>
<h2 id="一、Debug开篇"><a href="#一、Debug开篇" class="headerlink" title="一、Debug开篇"></a>一、Debug开篇</h2><p>　　首先看下IDEA中Debug模式下的界面。</p>
<p>　　如下是在IDEA中启动Debug模式，进入断点后的界面，我这里是Windows，可能和Mac的图标等会有些不一样。就简单说下图中标注的8个地方：</p>
<p>　　① 以Debug模式启动服务，左边的一个按钮则是以Run模式启动。在开发中，我一般会直接启动Debug模式，方便随时调试代码。</p>
<p>　　② 断点：在左边行号栏单击左键，或者快捷键Ctrl+F8 打上/取消断点，断点行的颜色可自己去设置。</p>
<p>　　③ Debug窗口：访问请求到达第一个断点后，会自动激活Debug窗口。如果没有自动激活，可以去设置里设置，如图1.2。</p>
<p>　　④ 调试按钮：一共有8个按钮，调试的主要功能就对应着这几个按钮，鼠标悬停在按钮上可以查看对应的快捷键。在菜单栏Run里可以找到同样的对应的功能，如图1.4。</p>
<p>　　⑤ 服务按钮：可以在这里关闭/启动服务，设置断点等。</p>
<p>　　⑥ 方法调用栈：这里显示了该线程调试所经过的所有方法，勾选右上角的[Show All Frames]按钮，就不会显示其它类库的方法了，否则这里会有一大堆的方法。</p>
<p>　　⑦ Variables：在变量区可以查看当前断点之前的当前方法内的变量。</p>
<p>　　⑧ Watches：查看变量，可以将Variables区中的变量拖到Watches中查看 </p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905221418147-1205043020.png" alt="img"></p>
<p> 在设置里勾选Show debug window on breakpoint，则请求进入到断点后自动激活Debug窗口</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905111655647-1134637623.png" alt="img"></p>
<p> 如果你的IDEA底部没有显示工具栏或状态栏，可以在View里打开，显示出工具栏会方便我们使用。可以自己去尝试下这四个选项。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905112617351-1554043487.png" alt="img"></p>
<p> 在菜单栏Run里有调试对应的功能，同时可以查看对应的快捷键。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905124338444-556465721.png" alt="img"></p>
<h2 id="二、基本用法-amp-快捷键"><a href="#二、基本用法-amp-快捷键" class="headerlink" title="二、基本用法&amp;快捷键"></a>二、基本用法&amp;快捷键</h2><p>Debug调试的功能主要对应着图一中4和5两组按钮：</p>
<p>　　1. 说第一组按钮，共8个按钮，从左到右依次如下：</p>
<p>　　　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905134837851-1615718043.png" alt="img"> </p>
<p>　　　　&gt; Show Execution Point (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。</p>
<p>　　　　&gt; Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</p>
<p>　　　　&gt; Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法，如第25行的put方法。</p>
<p>　　　　&gt; Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</p>
<p>　　　　&gt; Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</p>
<p>　　　　&gt; Drop Frame (默认无)：回退断点，后面章节详细说明。</p>
<p>　　　　&gt; Run to Cursor (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。</p>
<p>　　　　&gt; Evaluate Expression (Alt + F8)：计算表达式，后面章节详细说明。</p>
<p>　　2. 按钮，共7个按钮，从上到下依次如下：</p>
<p> 　　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905134011101-1824595229.png" alt="img"> </p>
<p>　　　　&gt; Rerun ‘xxxx’：重新运行程序，会关闭服务后重新启动程序。</p>
<p>　　　　&gt; Update ‘tech’ application (Ctrl + F5)：更新程序，一般在你的代码有改动后可执行这个功能。而这个功能对应的操作则是在服务配置里，如图2.3。</p>
<p>　　　　&gt; Resume Program (F9)：恢复程序，比如，你在第20行和25行有两个断点，当前运行至第20行，按F9，则运行到下一个断点(即第25行)，再按F9，则运行完整个流程，因为后面已经没有断点了。</p>
<p>　　　　&gt; Pause Program：暂停程序，启用Debug。目前没发现具体用法。</p>
<p>　　　　&gt; Stop ‘xxx’ (Ctrl + F2)：连续按两下，关闭程序。有时候你会发现关闭服务再启动时，报端口被占用，这是因为没完全关闭服务的原因，你就需要查杀所有JVM进程了。</p>
<p>　　　　&gt; View Breakpoints (Ctrl + Shift + F8)：查看所有断点，后面章节会涉及到。</p>
<p>　　　　&gt; Mute Breakpoints：哑的断点，选择这个后，所有断点变为灰色，断点失效，按F9则可以直接运行完程序。再次点击，断点变为红色，有效。如果只想使某一个断点失效，可以在断点上右键取消Enabled，如图 则该行断点失效。 <img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905193821194-225518192.png" alt="img"></p>
<ul>
<li><p>更新程序，On ‘Update’ actions，执行更新操作时所做的事情，一般选择’Update classes and resources’，即更新类和资源文件。</p>
<p>一般配合热部署插件会更好用，如JRebel，这样就不用每次更改代码后还要去重新启动服务。如何激活JRebel，在最后章节附上。</p>
<p>下面的On frame deactivation，在IDEA窗口失去焦点时触发，即一般你从idea切换到浏览器的时候，idea会自动帮你做的事情，一般可以设置Do nothing，频繁切换会比较消耗资源的。</p>
<p>　 　 <img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905143932694-500925087.png" alt="img"></p>
</li>
</ul>
<p>　　</p>
<h2 id="三、变量查看"><a href="#三、变量查看" class="headerlink" title="三、变量查看"></a>三、变量查看</h2><p>在Debug过程中，跟踪查看变量的变化是非常必要的，这里就简单说下IDEA中可以查看变量的几个地方，相信大部分人都了解。</p>
<p>　　1. 如下，在IDEA中，参数所在行后面会显示当前变量的值。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905154209179-9123997.png" alt="img"> </p>
<p>　　2. 光标悬停到参数上，显示当前变量信息。点击打开详情如图。我一般会使用这种方式，快捷方便。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905154425772-770303651.png" alt="img"> </p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905154724866-160919363.png" alt="img"> </p>
<p>　　3. 在Variables里查看，这里显示当前方法里的所有变量。</p>
<p> 　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905155339491-1166069157.png" alt="img"></p>
<p>　　4. 在Watches里，点击New Watch，输入需要查看的变量。或者可以从Variables里拖到Watche里查看。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905160057038-750351531.png" alt="img"> </p>
<p>　　如果你发现你没有Watches，可能在下图所在的地方。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905160433710-2004658473.png" alt="img"> </p>
<p>　  <img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905160515538-1647769062.png" alt="img"> </p>
<h2 id="四、计算表达式"><a href="#四、计算表达式" class="headerlink" title="四、计算表达式"></a>四、计算表达式</h2><p>　　在前面提到的计算表达式如图4.1的按钮，Evaluate Expression (Alt + F8) 。可以使用这个操作在调试过程中计算某个表达式的值，而不用再去打印信息。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905160826444-1625048711.png" alt="img"> </p>
<p>　　1. 按Alt + F8或按钮，或者，你可以选中某个表达式再Alt + F8，弹出计算表达式的窗口，如下，回车或点击Evaluate计算表达式的值。</p>
<p>　　　 这个表达式不仅可以是一般变量或参数，也可以是方法，当你的一行代码中调用了几个方法时，就可以通过这种方式查看查看某个方法的返回值。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905161614694-93470669.png" alt="img"> </p>
<p>　　2. 设置变量，在计算表达式的框里，可以改变变量的值，这样有时候就能很方便我们去调试各种值的情况了不是。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905162404288-824548249.png" alt="img"></p>
<h2 id="五、智能步入"><a href="#五、智能步入" class="headerlink" title="五、智能步入"></a>五、智能步入</h2><p>　　想想，一行代码里有好几个方法，怎么只选择某一个方法进入。之前提到过使用Step Into (Alt + F7) 或者 Force  Step Into (Alt + Shift + F7)进入到方法内部，但这两个操作会根据方法调用顺序依次进入，这比较麻烦。</p>
<p>　　那么智能步入就很方便了，智能步入，这个功能在Run里可以看到，Smart Step Into (Shift + F7)，如图5.1</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905152523304-803289488.png" alt="img"> </p>
<p>　　按Shift + F7，会自动定位到当前断点行，并列出需要进入的方法，如图5.2，点击方法进入方法内部。</p>
<p>　　如果只有一个方法，则直接进入，类似Force Step Into。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905163730929-1374653206.png" alt="img"> </p>
<h2 id="六、断点条件设置"><a href="#六、断点条件设置" class="headerlink" title="六、断点条件设置"></a>六、断点条件设置</h2><p>　　通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。</p>
<p>　　通常，当我们在遍历一个比较大的集合或数组时，在循环内设置了一个断点，难道我们要一个一个去看变量的值？那肯定很累，说不定你还错过这个值得重新来一次。</p>
<p>　　1. 在断点上右键直接设置当前断点的条件，如图6.1，我设置exist为true时断点才生效。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905165253944-1162138475.png" alt="img"></p>
<p>　　2. 点击View Breakpoints (Ctrl + Shift + F8)，查看所有断点。</p>
<p>　　　　Java Line Breakpoints 显示了所有的断点，在右边勾选Condition，设置断点的条件。</p>
<p>　　　　勾选Log message to console，则会将当前断点行输出到控制台，如图6.3</p>
<p>　　　　勾选Evaluate and log，可以在执行这行代码是计算表达式的值，并将结果输出到控制台。</p>
<p>　　</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905170655163-1805982960.png" alt="img"></p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905170947257-1667065155.png" alt="img"></p>
<p>　　3. 再说说右边的Filters过滤，这些一般情况下不常用，简单说下意思。</p>
<p>　　　　Instance filters：实例过滤，输入实例ID(如图6.5中的实例ID)，但是我这里没有成功，不知道什么原因，知道的朋友留个言。</p>
<p>　　　　Class filters：类过滤，根据类名过滤，同样没有成功….</p>
<p>　　　　Pass count：用于循环中，如果断点在循环中，可以设置该值，循环多少次后停在断点处，之后的循环都会停在断点处。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905185247132-1922055922.png" alt="img"> </p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905190253304-1057381593.png" alt="img"></p>
<p>　　4. 异常断点，通过设置异常断点，在程序中出现需要拦截的异常时，会自动定位到异常行。</p>
<p>　　如图6.6，点击+号添加Java Exception Breakpoints，添加异常断点。然后输入需要断点的异常类，如图6.7，之后可以在Java Exception Breakpoints里看到添加的异常断点。</p>
<p>　　我这里添加了一个NullPointerException异常断点，如图6.8，出现空指针异常后，自动定位在空指针异常行。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905200131851-150143203.png" alt="img"></p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905200305147-527881101.png" alt="img"> </p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905200726069-688175303.png" alt="img"> </p>
<h2 id="七、多线程调试"><a href="#七、多线程调试" class="headerlink" title="七、多线程调试"></a>七、多线程调试</h2><p>　　一般情况下我们调试的时候是在一个线程中的，一步一步往下走。但有时候你会发现在Debug的时候，想发起另外一个请求都无法进行了？</p>
<p>　　那是因为IDEA在Debug时默认阻塞级别是ALL，会阻塞其它线程，只有在当前调试线程走完时才会走其它线程。可以在View Breakpoints里选择Thread，如图7.1，然后点击Make Default设置为默认选项。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905204329757-1196950664.png" alt="img"> </p>
<p>　　切换线程，在图7.2中Frames的下拉列表里，可以切换当前的线程，如下我这里有两个Debug的线程，切换另外一个则进入另一个Debug的线程。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905205012663-56609868.png" alt="img"> </p>
<h2 id="八、回退断点"><a href="#八、回退断点" class="headerlink" title="八、回退断点"></a>八、回退断点</h2><p>　　在调试的时候，想要重新走一下流程而不用再次发起一个请求？</p>
<p>　　1. 首先认识下这个方法调用栈，如图8.1，首先请求进入DemoController的insertDemo方法，然后调用insert方法，其它的invoke我们且先不管，最上面的方法是当前断点所在的方法。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905210917741-1095775464.png" alt="img"> </p>
<p>　　2. 断点回退</p>
<p>　　所谓的断点回退，其实就是回退到上一个方法调用的开始处，在IDEA里测试无法一行一行地回退或回到到上一个断点处，而是回到上一个方法。</p>
<p>　　回退的方式有两种，一种是Drop Frame按钮(图8.2)，按调用的方法逐步回退，包括三方类库的其它方法(取消Show All Frames按钮会显示三方类库的方法，如图8.3)。</p>
<p>　　第二种方式，在调用栈方法上选择要回退的方法，右键选择Drop Frame(图8.4)，回退到该方法的上一个方法调用处，此时再按F9(Resume Program)，可以看到程序进入到该方法的断点处了。</p>
<p>　　但有一点需要注意，断点回退只能重新走一下流程，之前的某些参数/数据的状态已经改变了的是无法回退到之前的状态的，如对象、集合、更新了数据库数据等等。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905211428554-1617570377.png" alt="img"></p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905211723304-1223322879.png" alt="img"></p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905212138101-113776159.png" alt="img"></p>
<h2 id="九、中断Debug"><a href="#九、中断Debug" class="headerlink" title="九、中断Debug"></a>九、中断Debug</h2><p>　　想要在Debug的时候，中断请求，不要再走剩余的流程了？</p>
<p>　　有些时候，我们看到传入的参数有误后，不想走后面的流程了，怎么中断这次请求呢(后面的流程要删除数据库数据呢….)，难道要关闭服务重新启动程序？嗯，我以前也是这么干的。</p>
<p>　　确切的说，我也没发现可以直接中断请求的方式(除了关闭服务)，但可以通过Force Return，即强制返回来避免后续的流程，如图9.1。</p>
<p>　　点击Force Return，弹出Return Value的窗口，我这个方法的返回类型为Map，所以，我这里直接返回 results，来强制返回，从而不再进行后续的流程。或者你可以new HashMap&lt;&gt;()。</p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905213656241-1998475384.png" alt="img"></p>
<p>　　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905214031397-1943297392.png" alt="img"></p>
<h2 id="十、附：JRebel激活"><a href="#十、附：JRebel激活" class="headerlink" title="十、附：JRebel激活"></a>十、附：JRebel激活</h2><p>　　目前本人一直使用JRebel做热部署工具，效果还算理想，修改Java代码或者xml等配置文件都能热更新。偶尔服务开久了，或更改的文件较多时，热更新没有生效，需要重新启动服务。</p>
<p>　　这里只是简单说下我在网上看到的一种免费获得永久使用权的方式(非破解)，不确定这种方式什么时候不能用。</p>
<p>　　① 首先你需要一个Facebook或Twitter的账号(最好Twitter)</p>
<p>　　② 进入这个网址：<a href="https://my.jrebel.com/%EF%BC%8C%E5%B9%B6%E7%99%BB%E5%BD%95%EF%BC%8C%E5%A6%82%E5%9B%BE10.1">https://my.jrebel.com/，并登录，如图10.1</a></p>
<p>　　③ 然后在Install and Acticate里可以得到你的永久激活码。</p>
<p>　　④ 在设置里Jrebel里设置激活码，如图10.3，如果没有安装JRebel插件，先在Plugins里安装搜索安装JRebel插件。</p>
<p> 　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905215607882-171678285.png" alt="img"></p>
<p>　<img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905215814194-779245117.png" alt="img"></p>
<p>​    <img src="/2020/11/14/3-%E5%B8%B8%E7%94%A8IDE/IDEA/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/856154-20170905220123351-598613604.png" alt="img"></p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse导出配置文件,并给新工作空间使用</title>
    <url>/2020/10/15/3-%E5%B8%B8%E7%94%A8IDE/Eclipse/Eclipse%E5%AF%BC%E5%87%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6,%E5%B9%B6%E7%BB%99%E6%96%B0%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="eclipse配置文件导出-并给新工作空间使用"><a href="#eclipse配置文件导出-并给新工作空间使用" class="headerlink" title="eclipse配置文件导出,并给新工作空间使用"></a>eclipse配置文件导出,并给新工作空间使用</h1><p> eclipse的默认配置一般不能满足我们的要求，我们一般会修改一些配置，如字体、背景颜色、快捷键及一些template等等，这样方便我们的开发。可是当我们新建一个工作空间的时候，eclipse又会使用默认配置，怎样将我们习惯的配置导出然后导入新工作空间呢？   </p>
<h2 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h2><p>  在被复制的工作空间下，File-&gt;Switch workspace-&gt;Other… 打开如下窗口：</p>
<p> <img src="/2020/10/15/3-%E5%B8%B8%E7%94%A8IDE/Eclipse/Eclipse%E5%AF%BC%E5%87%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6,%E5%B9%B6%E7%BB%99%E6%96%B0%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8/1" alt="img"></p>
<h2 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h2><p>​       将workspace/.metadata/.plugins/org.eclipse.core.runtime中的.settings文件夹拷贝出来，里面就是所有的配置文件，新建工作空间的时候将该.settings文件夹替换掉新工作空间中的.settings文件夹即可。（有网友是将.plugings文件夹替换，但是.plugings文件夹太大了，实际上就是替换.settings文件夹，.settings只有几百k。）</p>
]]></content>
      <categories>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>Eclipse配置</tag>
      </tags>
  </entry>
  <entry>
    <title>【排错】META-INFMANIFEST.MF (系统找不到指定的路径)</title>
    <url>/2020/11/01/3-%E5%B8%B8%E7%94%A8IDE/Eclipse/%E3%80%90%E6%8E%92%E9%94%99%E3%80%91META-INFMANIFEST.MF%20(%E7%B3%BB%E7%BB%9F%E6%89%BE%E4%B8%8D%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E8%B7%AF%E5%BE%84)/</url>
    <content><![CDATA[<p><img src="/2020/11/01/3-%E5%B8%B8%E7%94%A8IDE/Eclipse/%E3%80%90%E6%8E%92%E9%94%99%E3%80%91META-INFMANIFEST.MF%20(%E7%B3%BB%E7%BB%9F%E6%89%BE%E4%B8%8D%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E8%B7%AF%E5%BE%84)/123.png" alt="234"></p>
]]></content>
      <categories>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>Eclipse排错</tag>
      </tags>
  </entry>
  <entry>
    <title>修改eclipse的web项目默认浏览器</title>
    <url>/2020/10/15/3-%E5%B8%B8%E7%94%A8IDE/Eclipse/%E4%BF%AE%E6%94%B9eclipse%E7%9A%84web%E9%A1%B9%E7%9B%AE%E9%BB%98%E8%AE%A4%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    <content><![CDATA[<p><img src="/2020/10/15/3-%E5%B8%B8%E7%94%A8IDE/Eclipse/%E4%BF%AE%E6%94%B9eclipse%E7%9A%84web%E9%A1%B9%E7%9B%AE%E9%BB%98%E8%AE%A4%E6%B5%8F%E8%A7%88%E5%99%A8/123.png"></p>
]]></content>
      <categories>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>Eclipse配置</tag>
      </tags>
  </entry>
  <entry>
    <title>【排错】项目编译问题，Java版本不匹配： Description Resource Path Location Type Java compiler level does not match the version of</title>
    <url>/2020/10/15/3-%E5%B8%B8%E7%94%A8IDE/Eclipse/%E3%80%90%E6%8E%92%E9%94%99%E3%80%91%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98%EF%BC%8CJava%E7%89%88%E6%9C%AC%E4%B8%8D%E5%8C%B9%E9%85%8D%EF%BC%9A%20Description%20Resource%20Path%20Location%20Type%20Java%20compiler%20level%20does%20not%20match%20the%20version%20of/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="./项目编译问题，Java版本不匹配.pdf" width="100%" height="550" type="application/pdf">
	</div>




<h1 id="图解-Description-Resource-Path-Location-Type-Java-compiler-level-does-not-match-the-version-of"><a href="#图解-Description-Resource-Path-Location-Type-Java-compiler-level-does-not-match-the-version-of" class="headerlink" title="(图解)Description Resource Path Location Type Java compiler level does not match the version of"></a>(图解)Description Resource Path Location Type Java compiler level does not match the version of</h1><p>project 编译问题，需要三处的jdk版本要保持一致，才能编译通过。</p>
<ol>
<li>在项目上右键properties-&gt;project Facets-&gt;修改右侧的version 保持一致<img src="/2020/10/15/3-%E5%B8%B8%E7%94%A8IDE/Eclipse/%E3%80%90%E6%8E%92%E9%94%99%E3%80%91%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98%EF%BC%8CJava%E7%89%88%E6%9C%AC%E4%B8%8D%E5%8C%B9%E9%85%8D%EF%BC%9A%20Description%20Resource%20Path%20Location%20Type%20Java%20compiler%20level%20does%20not%20match%20the%20version%20of/1" alt="img"></li>
</ol>
<ol start="2">
<li>window-&gt;preferences-&gt;java-&gt;Compiler-&gt;设置右侧的Compiler compliance level</li>
</ol>
<p><img src="/2020/10/15/3-%E5%B8%B8%E7%94%A8IDE/Eclipse/%E3%80%90%E6%8E%92%E9%94%99%E3%80%91%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98%EF%BC%8CJava%E7%89%88%E6%9C%AC%E4%B8%8D%E5%8C%B9%E9%85%8D%EF%BC%9A%20Description%20Resource%20Path%20Location%20Type%20Java%20compiler%20level%20does%20not%20match%20the%20version%20of/2" alt="img"></p>
<ol start="3">
<li>window-&gt;preferences-&gt;java-&gt;Installed JREs-&gt;设置或者选择右侧的Installed JREs</li>
</ol>
<p><img src="/2020/10/15/3-%E5%B8%B8%E7%94%A8IDE/Eclipse/%E3%80%90%E6%8E%92%E9%94%99%E3%80%91%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98%EF%BC%8CJava%E7%89%88%E6%9C%AC%E4%B8%8D%E5%8C%B9%E9%85%8D%EF%BC%9A%20Description%20Resource%20Path%20Location%20Type%20Java%20compiler%20level%20does%20not%20match%20the%20version%20of/3" alt="img"></p>
<p>以上三处的jdk版本要保持一致，才能编译通过</p>
<ol start="4">
<li>另外，一般新导入的工程需要设置编码格式，如下图：</li>
</ol>
<p><img src="/2020/10/15/3-%E5%B8%B8%E7%94%A8IDE/Eclipse/%E3%80%90%E6%8E%92%E9%94%99%E3%80%91%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98%EF%BC%8CJava%E7%89%88%E6%9C%AC%E4%B8%8D%E5%8C%B9%E9%85%8D%EF%BC%9A%20Description%20Resource%20Path%20Location%20Type%20Java%20compiler%20level%20does%20not%20match%20the%20version%20of/4" alt="img"></p>
]]></content>
      <categories>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>Eclipse排错</tag>
      </tags>
  </entry>
  <entry>
    <title>Github使用方法：如何将本地的文件夹整体上传到Github上</title>
    <url>/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/GitHub/Github%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B4%E4%BD%93%E4%B8%8A%E4%BC%A0%E5%88%B0Github%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="Git使用方法：如何将本地的文件夹整体上传到Github上"><a href="#Git使用方法：如何将本地的文件夹整体上传到Github上" class="headerlink" title="Git使用方法：如何将本地的文件夹整体上传到Github上"></a>Git使用方法：如何将本地的文件夹整体上传到Github上</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>怎么注册和安装git客户端，可参照以下这篇博客：<a href="http://blog.csdn.net/vipzjyno1/article/details/22098621">http://blog.csdn.net/vipzjyno1/article/details/22098621</a></p>
<p>通过命令行，以上的博客也说德很清楚，下面要说的是如何通过Git GUI将自己本地的文件上传至Github上。</p>
<h2 id="将本地文件上传至Github"><a href="#将本地文件上传至Github" class="headerlink" title="将本地文件上传至Github"></a>将本地文件上传至Github</h2><h3 id="创建本地-git仓库"><a href="#创建本地-git仓库" class="headerlink" title="创建本地.git仓库"></a>创建本地.git仓库</h3><p>  在自己的本地文件（位置随意），点击右键==》选择Git GUI Here ，会弹出以下框，选择create new Repository，也就是箭头处，红色圈内是我自己已经创建的。</p>
<p>点击create new  Repository以后会出现让你输入一个文件夹的弹窗，直接输入一个文件夹名称即可。点击创建，这时打开Git文件夹里面有一个.git文件夹，但有些人是看不到的，这是因为，默认情况下是隐藏的，自己将自己电脑里的文件显示即可，不会的自行百度。这时，这个Git文件夹就是你的项目仓库。只要将你需要上传的项目放在该文件夹即可。</p>
<p><img src="/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/GitHub/Github%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B4%E4%BD%93%E4%B8%8A%E4%BC%A0%E5%88%B0Github%E4%B8%8A/Center.jpg" alt="img"></p>
<p><img src="/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/GitHub/Github%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B4%E4%BD%93%E4%B8%8A%E4%BC%A0%E5%88%B0Github%E4%B8%8A/Center22.jpg" alt="img"></p>
<h3 id="配置远程仓库"><a href="#配置远程仓库" class="headerlink" title="配置远程仓库"></a>配置远程仓库</h3><p>完成点击创建以后，会弹出可视化窗：点击Remote–》Add…</p>
<p><img src="/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/GitHub/Github%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B4%E4%BD%93%E4%B8%8A%E4%BC%A0%E5%88%B0Github%E4%B8%8A/Center2.jpg" alt="img"></p>
<p>弹出以下框以后输入你Github的用户名（shanerou是我的github名称）和你需要将你本地的项目放在Github的仓库的地址，如我在Github上创建了一个repository名称为Test的，然后添加如下，点击创建，弹出success的框代表创建成功</p>
<p><img src="/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/GitHub/Github%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B4%E4%BD%93%E4%B8%8A%E4%BC%A0%E5%88%B0Github%E4%B8%8A/Center3.jpg" alt="img"></p>
<p><img src="/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/GitHub/Github%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B4%E4%BD%93%E4%B8%8A%E4%BC%A0%E5%88%B0Github%E4%B8%8A/Center4.jpg" alt="img"></p>
<h3 id="文件推送"><a href="#文件推送" class="headerlink" title="文件推送"></a>文件推送</h3><p>在Git文件夹下放入我的一个demo：SD_SQList2</p>
<p><img src="/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/GitHub/Github%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B4%E4%BD%93%E4%B8%8A%E4%BC%A0%E5%88%B0Github%E4%B8%8A/Center5.jpg" alt="img"></p>
<p>按以下步骤操作：</p>
<p><img src="/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/GitHub/Github%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B4%E4%BD%93%E4%B8%8A%E4%BC%A0%E5%88%B0Github%E4%B8%8A/Center6.jpg" alt="img"><br>点击第三步时，在Initial Commit Message 框里将会看到一行信息</p>
<p>点击第四步，也就是提交命令以后，左边已经缓存的文件被提交，缓存文件消失，这时点击第五步即可，点击第五步后出现以下框：</p>
<p> <img src="/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/GitHub/Github%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B4%E4%BD%93%E4%B8%8A%E4%BC%A0%E5%88%B0Github%E4%B8%8A/Center7.jpg" alt="img"></p>
<p>输入你Github的用户名 和密码：</p>
<p><img src="/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/GitHub/Github%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B4%E4%BD%93%E4%B8%8A%E4%BC%A0%E5%88%B0Github%E4%B8%8A/Center8.jpg" alt="img"></p>
<p>点击上传：出现以下弹框则表示上传成功</p>
<p><img src="/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/GitHub/Github%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B4%E4%BD%93%E4%B8%8A%E4%BC%A0%E5%88%B0Github%E4%B8%8A/Center9.jpg" alt="img"></p>
<h3 id="成功，查看结果"><a href="#成功，查看结果" class="headerlink" title="成功，查看结果"></a>成功，查看结果</h3><p>这时到你的Github上去看，将会看到以下dome：</p>
<p><img src="/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/GitHub/Github%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B4%E4%BD%93%E4%B8%8A%E4%BC%A0%E5%88%B0Github%E4%B8%8A/Center11..jpg" alt="img"></p>
<p>至此上传结束。</p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>git出现RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errfno 10054</title>
    <url>/2020/11/14/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/Git/git%E5%87%BA%E7%8E%B0RPC-failed-curl-56-OpenSSL-SSL-read-SSL-ERROR-SYSCALL-errfno-10054/</url>
    <content><![CDATA[<h1 id="git出现RPC-failed-curl-56-OpenSSL-SSL-read-SSL-ERROR-SYSCALL-errfno-10054"><a href="#git出现RPC-failed-curl-56-OpenSSL-SSL-read-SSL-ERROR-SYSCALL-errfno-10054" class="headerlink" title="git出现RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errfno 10054"></a>git出现RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errfno 10054</h1><h2 id="问题：git下载代码时，报“git出现RPC-failed-curl-56-OpenSSL-SSL-read-SSL-ERROR-SYSCALL-errfno-10054”的问题，"><a href="#问题：git下载代码时，报“git出现RPC-failed-curl-56-OpenSSL-SSL-read-SSL-ERROR-SYSCALL-errfno-10054”的问题，" class="headerlink" title="问题：git下载代码时，报“git出现RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errfno 10054”的问题，"></a>问题：git下载代码时，报“git出现RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errfno 10054”的问题，</h2><p>如下所示的截图 </p>
<p> <img src="/2020/11/14/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/Git/git%E5%87%BA%E7%8E%B0RPC-failed-curl-56-OpenSSL-SSL-read-SSL-ERROR-SYSCALL-errfno-10054/1832793-20191012165127495-1172697860.png" alt="img"></p>
<h2 id="解决步骤："><a href="#解决步骤：" class="headerlink" title="解决步骤："></a>解决步骤：</h2><ol>
<li><p>首先输入如下命令：  　　git config http.sslVerify “false”</p>
</li>
<li><p> 如果输入上面命令提示报“ fatal: not in a git directory  ”，则输入如下命令：git init</p>
</li>
<li><p>重新下载代码：  git clone  <a href="https://gitee.com/">https://gitee.com</a>……</p>
</li>
<li><p>如果还是git代码还是下载失败，则需要修改git缓存的大小为100MB，输入如下命令：  git config –global http.postBuffer 100M</p>
<p><img src="/2020/11/14/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/Git/git%E5%87%BA%E7%8E%B0RPC-failed-curl-56-OpenSSL-SSL-read-SSL-ERROR-SYSCALL-errfno-10054/1832793-20191012165654492-604506312.png" alt="img"></p>
</li>
<li><p>问题解决了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git排错</tag>
      </tags>
  </entry>
  <entry>
    <title>Thymeleaf + SpringBoot 学习笔记</title>
    <url>/2021/09/16/4-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/03-Thymeleaf/Thymeleaf-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Thymeleaf-模板引擎-快速入门"><a href="#Thymeleaf-模板引擎-快速入门" class="headerlink" title="Thymeleaf 模板引擎 快速入门"></a>Thymeleaf 模板引擎 快速入门</h1><p>现在市面上大部分的项目 都是 SpringBoot + vue/react 前后端 分离的教程。而JSP已经淘汰。不过模板引擎始终在。</p>
<p>Thymeleaf 是 SpringBoot 推荐使用的模板引擎</p>
<p>JSP 必须动态渲染，启动服务才能看到效果，而Thymeleaf是动静分离的，页面某些标签若无参数传入会被渲染成默认的样子。，故开发静态页面的时候，前端工程师是可以独立进行的，完全的动静分离。</p>
<p>Thymeleaf的语法和VUE是类似的。</p>
<h1 id="Thymeleaf-整合Spring-Boot"><a href="#Thymeleaf-整合Spring-Boot" class="headerlink" title="Thymeleaf 整合Spring Boot"></a>Thymeleaf 整合Spring Boot</h1><ol>
<li><p>新建一个Spring Boot项目<br><img src="/2021/09/16/4-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/03-Thymeleaf/Thymeleaf-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210916094116968.png" alt="image-20210916094116968"></p>
</li>
<li><p>输入项目描述<br><img src="/2021/09/16/4-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/03-Thymeleaf/Thymeleaf-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210916100539945.png" alt="image-20210916100539945"></p>
</li>
<li><p>依次选择所需依赖<br><img src="/2021/09/16/4-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/03-Thymeleaf/Thymeleaf-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210916100719653.png" alt="image-20210916100719653"><br><img src="/2021/09/16/4-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/03-Thymeleaf/Thymeleaf-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210916100832271.png" alt="image-20210916100832271"><br><img src="/2021/09/16/4-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/03-Thymeleaf/Thymeleaf-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210916100854657.png" alt="image-20210916100854657"></p>
</li>
<li><p>创建项目<br><img src="/2021/09/16/4-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/03-Thymeleaf/Thymeleaf-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210916100936226.png" alt="image-20210916100936226"></p>
</li>
</ol>
<p>注意，IDEA的不同版本会和不同版本Maven出现不兼容的问题。 我的是2018版本的，Maven使用 3.2版本，3.6版Maven便会报错。</p>
<p>在用@Data注解时，没有生成setter/getter方法、百度了一堆都没解决方法，后来用Google查了一下解决了<del>~</del></p>
<p>使用IDEA需要安装Lombok插件，我这里已经下载好，如果没下载安装点击install进行下载安装即可<del>~</del></p>
<p><img src="/2021/09/16/4-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/03-Thymeleaf/Thymeleaf-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDk3ODIw,size_16,color_FFFFFF,t_70.png" alt="img"></p>
]]></content>
      <tags>
        <tag>Thymeleaf</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>使用git分支保存hexo博客源码到github</title>
    <url>/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/Git/%E4%BD%BF%E7%94%A8git%E5%88%86%E6%94%AF%E4%BF%9D%E5%AD%98hexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%B0github/</url>
    <content><![CDATA[<h1 id="使用git分支保存hexo博客源码到github"><a href="#使用git分支保存hexo博客源码到github" class="headerlink" title="使用git分支保存hexo博客源码到github"></a>使用git分支保存hexo博客源码到github</h1><p>hexo是当前最火的静态博客框架，支持Markdown格式文章编辑并自动生成对应的静态网页，简单高效令人爱不释手。<br>使用hexo写博客的流程通常是，</p>
<ol>
<li>通过<code>hexo new post_name</code>命令，会自动在<code>source/_post</code>目录下生成一个待写的<code>post_name.md</code>文件</li>
<li>编写完该md文件后，用<code>hexo generate</code>编译生成对应的HTML文件</li>
<li>发布之前，可以用<code>hexo s</code>本地预览，然后通过<code>hexo deploy</code>发布到远程仓库的<strong>master</strong>分支，然后你的个人站点就能看到刚才新加的文章了</li>
</ol>
<h2 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h2><p>然而，使用过hexo搭建个人博客的朋友们想必都会遇到博客源码保存的问题。即远程仓库只会保存hexo发布后的静态HTML文件，你的博客md源文件、主题配置等还在本地，一旦电脑磁盘坏了或者换了电脑，就无法在之前仓库的基础上继续写博客。针对此问题，有不少博主会在github上单独另起一个<strong>repository</strong>来专门保存博客源文件，每次发布完新文章，需要手动地将<code>source/post</code>下的md文件上传到源文件对应的<strong>repository</strong>，确实也能解决问题，但总归是麻烦。后来偶然看到聪明的网友借助git分支来巧妙地实现用同一个仓库保存静态网页和博客源码，自己试了下确实很赞，故总结之。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h4 id="新建git分支"><a href="#新建git分支" class="headerlink" title="新建git分支"></a>新建git分支</h4><p>因Github  Page要求使用master分支作为发布网站的源代码，我们只能用master分支来保存hexo生成的静态网页，对于博客源码，可以新建一个source分支来存储。在github上打开Pages对应的仓库，也就是以”username.github.io”命名的仓库，然后建立一个source分支，如下图：</p>
<p><img src="/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/Git/%E4%BD%BF%E7%94%A8git%E5%88%86%E6%94%AF%E4%BF%9D%E5%AD%98hexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%B0github/create_branch.png" alt="create_branch"></p>
<p>因为我已经创建过source分支，故下方会显示目前该仓库上有master和source两个分支。其中source分支显示打钩，表示当前仓库的默认分支已经是source而不是master了，下面会讲。</p>
<h4 id="更改仓库的默认分支"><a href="#更改仓库的默认分支" class="headerlink" title="更改仓库的默认分支"></a>更改仓库的默认分支</h4><p>github上的仓库初始都会有个master分支，也就是默认分支。对于一个仓库<code>project_name</code>，当我们通过<code>git clone https://github.com/sherlockyb/project_name.git</code>下载代码时，实际拉取的是默认分支master对应的代码。而我们用hexo写博客时，通常是与md源文件打交道，对于deploy生成的master分支代码并不需要我们关注，因此可将仓库的默认分支改为保存源码的source分支，这样通过<code>git clone</code>拉取的就是source分支代码了。</p>
<p>在仓库的主页面，通过Settings -&gt; Branchs，可以看到<strong>Default branch</strong>的Tab，显示的默认分支是master，可以勾选source，然后update即可将默认分支设置为source，如下图：</p>
<p><img src="/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/Git/%E4%BD%BF%E7%94%A8git%E5%88%86%E6%94%AF%E4%BF%9D%E5%AD%98hexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%B0github/default_branch.png" alt="switch_default_branch"></p>
<h4 id="将本地hexo目录与远程仓库关联"><a href="#将本地hexo目录与远程仓库关联" class="headerlink" title="将本地hexo目录与远程仓库关联"></a>将本地hexo目录与远程仓库关联</h4><p>进入到本地hexo工程目录，也就是我们通常执行<code>hexo new post</code>等命令的目录，执行如下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;sherlockyb&#x2F;sherlockyb.github.io.git</span><br></pre></td></tr></table></figure>

<h4 id="推送博客源码"><a href="#推送博客源码" class="headerlink" title="推送博客源码"></a>推送博客源码</h4><p>将本地的md源文件、站点配置文件等推送到source分支。<br>因为我们只需要保留博客源码，其他无关的文件并不希望推送，需要确保配好了<code>.gitignore</code>文件，通常如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules&#x2F;</span><br><span class="line">public&#x2F;</span><br><span class="line">.deploy*&#x2F;</span><br></pre></td></tr></table></figure>

<p>然后依次执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m &#39;hexo source post&#39;</span><br><span class="line">git push origin source</span><br></pre></td></tr></table></figure>

<h4 id="删除public等文件（可选）"><a href="#删除public等文件（可选）" class="headerlink" title="删除public等文件（可选）"></a>删除public等文件（可选）</h4><p>因为source分支是从master分支新建的，初始代码实际就是master的拷贝，因而master中已有的public等deploy生成的文件也会一起带过来，这些都不算是博客源文件，如果你也觉着source分支还存着这些有些别扭，就可以先在本地把它删掉，然后执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &#39;DEL: public things which only for deploy&#39;</span><br><span class="line">git push origin source</span><br></pre></td></tr></table></figure>

<p>执行完之后，你的仓库大概就是长这个样子：</p>
<p><img src="/2020/11/08/3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B9%B3%E5%8F%B0%EF%BC%88Git%E7%AD%89%EF%BC%89/Git/%E4%BD%BF%E7%94%A8git%E5%88%86%E6%94%AF%E4%BF%9D%E5%AD%98hexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%B0github/source_files.png" alt="source_files"></p>
<p>后续即便你再发布博客时，deploy生成public文件，在提交博客源码时，也不会将其带上去，因为有<code>.gitignore</code>将其忽略了。</p>
<h2 id="新环境配置"><a href="#新环境配置" class="headerlink" title="新环境配置"></a>新环境配置</h2><p>假设我们换电脑了，要在新环境继续在原有仓库基础上撸文章，此时通过<code>git clone</code>将博客源码拉到本地，然后安装、初始化hexo就能搞定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;ZhangHao0810&#x2F;ZhangHao0810.github.io.git sherlockyb</span><br><span class="line">cd sherlockyb</span><br><span class="line">npm install hexo</span><br><span class="line">npm install hexo-deployer-git -save</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; hexo环境配置好后，继续像之前一样</span><br><span class="line">hexo new post_name</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>确保<code>hexo deploy</code>推送的是master分支，hexo目录下的_config.yml文件通常会配置deploy推送的目标地址，这个一般在最初使用hexo时，就会配置为master，不用改动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;ZhangHao0810&#x2F;ZhangHao0810.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis之整合Spring（Dao和Mapper两种方式）</title>
    <url>/2020/10/28/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/03-Mybatis-Mybatis%20Plus/MyBatis%E4%B9%8B%E6%95%B4%E5%90%88Spring%EF%BC%88Dao%E5%92%8CMapper%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="MyBatis之整合Spring（Dao和Mapper两种方式）"><a href="#MyBatis之整合Spring（Dao和Mapper两种方式）" class="headerlink" title="MyBatis之整合Spring（Dao和Mapper两种方式）"></a>MyBatis之整合Spring（Dao和Mapper两种方式）</h2><h3 id="1-基础环境搭建"><a href="#1-基础环境搭建" class="headerlink" title="1. 基础环境搭建"></a>1. 基础环境搭建</h3><p> 　　首先环境肯定得有，环境嘛，除了<a href="http://lib.csdn.net/base/java">Java</a>环境和开发环境外，那就是jar包咯，关于mybatis和spring整合的jar包，我已经上传到下载频道了==&gt;<a href="http://download.csdn.net/detail/eson_15/9549624">传送门</a><br> 　　 将这些jar包导入到lib文件夹中即可，然后就是工程中的一些文件了，配置文件啊，java文件啊等，先看一下整个工程的结构。<br> <img src="https://img-blog.csdn.net/20160615203246719" alt="工程结构"><br> 　　下面来完成所有的整合步骤。</p>
<h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h3><p> 　　在于spring整合之前，mybatis都是自己管理数据源的，然后sqlSessionFactory是我们自己去注入的，现在整合了，这些都要交给spring来管理了，来看一下beans.xml文件中的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 加载classpath下的db.properties文件，里面配了数据库连接的一些信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;$&#123;dataSource&#125;&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 配置sqlSessionFactory，SqlSessionFactoryBean是用来产生sqlSessionFactory的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 加载mybatis的全局配置文件，放在classpath下的mybatis文件夹中了 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mybatis/SqlMapConfig.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 加载数据源，使用上面配置好的数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 　　跟spring和<a href="http://lib.csdn.net/base/javaee">hibernate</a>整合的情况差不多，都是通过properties文件加载<a href="http://lib.csdn.net/base/mysql">数据库</a>连接信息，然后导入配置文件配置一下sessionFactory，下面看看db.properties和SqlMapConfig.xml文件。</p>
<p>db.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#db.properties</span></span><br><span class="line"><span class="attr">dataSource</span>=<span class="string">org.apache.commons.dbcp.BasicDataSource</span></span><br><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc\:mysql\://localhost\:3306/mybatis</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>SqlMapConfig.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span><span class="comment">&lt;!--整合的话，不设置settngs也行 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打开延迟加载的开关 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将积极加载改为消极加载，即延迟加载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 别名的定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;ssm.po&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;sqlmap/User.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;ssm.mapper&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 扫描整个包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-dao方式开发的配置"><a href="#3-dao方式开发的配置" class="headerlink" title="3. dao方式开发的配置"></a>3. dao方式开发的配置</h2><p> 　　在最开始我们提到，mybatis中有两种开发方式，一种dao开发方式，一种mapper开发方式，后者用的比较多，但是不排除没有使用dao方式的，所以两种我都总结一下，首先看dao方式开发的配置。</p>
<h3 id="3-1-配置User-xml"><a href="#3-1-配置User-xml" class="headerlink" title="3.1 配置User.xml"></a>3.1 配置User.xml</h3><p> 　　在sqlMap包中有个User.xml，里面是针对用户的操作的一些配置，这里是整合，所以我就写了一个statement，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- namespace命名空间，作用就是对sql进行分类化管理，即sql隔离</span></span><br><span class="line"><span class="comment">注意：使用mapper代理方法开发的话，namespace就有特殊重要的作用了</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;ssm.po.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 　　只是通过id查询用户，如果测试成功，说明整合成功，这里写完了后，别忘了在SqlMapConfig.xml中加载这个映射文件，但是上面已经加载过了，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mapper resource&#x3D;&quot;sqlmap&#x2F;User.xml&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-开发dao及其实现类"><a href="#3-2-开发dao及其实现类" class="headerlink" title="3.2 开发dao及其实现类"></a>3.2 开发dao及其实现类</h3><p> 　　接下来就是开发dao及其实现类了，就一个方法，通过id查询用户，先来看下dao的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//根据用户id查询用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 　　再看下实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//继承SqlSessionDaoSupport，通过this.getSqlSession()就能得到sqlSession，因为SqlSessionDaoSupport中有该方法</span></span><br><span class="line">        SqlSession sqlSession = <span class="keyword">this</span>.getSqlSession();</span><br><span class="line">        User user = sqlSession.selectOne(<span class="string">&quot;test.findUserById&quot;</span>, id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 　　这里是重点：通过dao方式开发的话，dao的实现类在实现接口的同时，需要继承SqlSessionDaoSupport类，这个类中有获取SqlSession的方法，因为sqlSessionFactory已经在beans.xml文件中配置好了（下面有写），spring会自动注入进去，继承了SqlSessionDaoSupport类就可以直接通过getSqlSession()方法来获取sqlSession。然后就可以操作数据库了。</p>
<h3 id="3-3-配置dao"><a href="#3-3-配置dao" class="headerlink" title="3.3 配置dao"></a>3.3 配置dao</h3><p> 　　上面也说了，要获取sqlSession必须得有sqlSessionFactory才行啊，这就需要spring来注入了，所以我们在beans.xml中配置一下该dao</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 原始dao方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ssm.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 　　这样的话，dao开发方式就整合好了，下面来测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImplTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:beans.xml&quot;</span>);<span class="comment">//得到spring容器</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindUserById</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        UserDao userDao = (UserDao) applicationContext.getBean(<span class="string">&quot;userDao&quot;</span>);<span class="comment">//获取这个bean</span></span><br><span class="line">        User user = userDao.findUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-mapper方式开发的配置"><a href="#4-mapper方式开发的配置" class="headerlink" title="4. mapper方式开发的配置"></a>4. mapper方式开发的配置</h2><p> 　　由前面的博文可知，mapper方法开发的话，mapper.xml和mapper.java文件要放在一个包下，这里主要放在ssm.mapper的包下了，下面看一下两个文件：</p>
<h3 id="4-1-配置UserMapper-xml和UserMapper-java"><a href="#4-1-配置UserMapper-xml和UserMapper-java" class="headerlink" title="4.1 配置UserMapper.xml和UserMapper.java"></a>4.1 配置UserMapper.xml和UserMapper.java</h3><p>​        UserMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- UserMapper.xml文件 --&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- namespace命名空间，作用就是对sql进行分类化管理，即sql隔离</span></span><br><span class="line"><span class="comment">注意：使用mapper代理方法开发的话，namespace就有特殊重要的作用了,namespace=mapper接口地址</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;ssm.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 　　UserMapper.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mapper接口，相当于dao接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//根据id查询用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"> </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>这个和之前的都一样，没什么难度，注意xml中的namespace要写成对应的java文件的完全限定名即可。</p>
<h3 id="4-2-配置beans-xml"><a href="#4-2-配置beans-xml" class="headerlink" title="4.2 配置beans.xml"></a>4.2 配置beans.xml</h3><p> 　　上面已经配置好了mapper的映射和接口了，那么如何由spring来产生一个代理对象呢？spring是通过MapperFactoryBean来创建代理对象的，看下面的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MapperFactoryBean：根据mapper接口生成的代理对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperInterface&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ssm.mapper.UserMapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 　　从配置中可以看出，使用MapperFactoryBean来产生mapper的代理对象，首先要配置一个mapperInterface，即你要spring产生哪个mapper接口对应的代理对象，所以肯定要把我们刚刚写好的mapper接口的完全限定名给传进去，spring就知道要创建对应的代理对象了。当然，sqlSessionFactory是必不可少的，否则怎么产生sqlSession呢？<br> 　　测试程序就不写了，把上面的测试程序改一下，获取”userMapper”这个bean即可。<br>  但是问题来了，如果有很多个mapper接口咋整？那beans.xml中难道要写很多个这样的bean么？答案肯定不是这样，我们可以在beans.xml中通过扫描包即可，即告诉spring，你把指定的包中所有的mapper接口都给我生成一个代理对象出来，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mapper批量扫描包，从mapper包中扫描出mapper接口，自动创建代理对象并且在spring容器中注册 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ssm.mapper&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 　　从上面的配置中可以看出，spring使用MapperScannerConfiger来进行mapper扫描的。要想扫描成功，必须遵循之前说的规范：即mapper.xml和mapper.java两个文件名必须保持一致，且在同一个目录下。这样的话，自动扫描出来的mapper的bean的id就为mapper类名的首字母小写。所以上面的bean没有id属性，因为这个是根据具体的mapper接口来的。basePackage是用来指定要扫描的包。这样就可以批量扫描mapper接口了。<br> 　　测试程序和上面的一样，就不写了。到这里，spring和mybatis就整合好了，这里只是简单整合一下，主要是了解这个整合的过程以及方法，并没有用到spring的aop和事务等配置。</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>项目实战</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 自动生成代码的插件使用</title>
    <url>/2021/09/17/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/03-Mybatis-Mybatis%20Plus/Mybatis-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Mybatis插件使用"><a href="#Mybatis插件使用" class="headerlink" title="Mybatis插件使用"></a>Mybatis插件使用</h1><p>pom 加入插件依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span><span class="comment">&lt;!--Mybatis自动生成代码的插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">                    src/main/resources/mybatis-generate-config.xml</span><br><span class="line">                <span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在resource下创建配置文件</p>
<p><img src="/2021/09/17/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/03-Mybatis-Mybatis%20Plus/Mybatis-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/image-20210917194311357.png" alt="image-20210917194311357"></p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;simple&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/nuomishe?characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Hongkong&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">userId</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;0206&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.nuomi.nuomishe.entity&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;mappers&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.nuomi.nuomishe.dao&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;user_info&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;User&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">&quot;ID&quot;</span> <span class="attr">sqlStatement</span>=<span class="string">&quot;MYSQL&quot;</span> <span class="attr">identity</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;table tableName=&quot;item&quot; domainObjectName=&quot;Item&quot;</span></span><br><span class="line"><span class="comment">enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot; &gt;</span></span><br><span class="line"><span class="comment">&lt;generatedKey column=&quot;ID&quot; sqlStatement=&quot;MYSQL&quot; identity=&quot;true&quot; /&gt;</span></span><br><span class="line"><span class="comment">&lt;columnOverride column=&quot;price&quot; jdbcType=&quot;DECIMAL&quot; javaType=&quot;java.math.BigDecimal&quot; /&gt;</span></span><br><span class="line"><span class="comment">&lt;/table&gt;</span></span><br><span class="line"><span class="comment">&lt;table tableName=&quot;item_stock&quot; domainObjectName=&quot;ItemStock&quot;</span></span><br><span class="line"><span class="comment">enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot; &gt;</span></span><br><span class="line"><span class="comment">&lt;generatedKey column=&quot;ID&quot; sqlStatement=&quot;MYSQL&quot; identity=&quot;true&quot; /&gt;</span></span><br><span class="line"><span class="comment">&lt;/table&gt;</span></span><br><span class="line"><span class="comment">&lt;table tableName=&quot;user_info&quot; domainObjectName=&quot;User&quot;</span></span><br><span class="line"><span class="comment">enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot; &gt;</span></span><br><span class="line"><span class="comment">&lt;generatedKey column=&quot;ID&quot; sqlStatement=&quot;MYSQL&quot; identity=&quot;true&quot; /&gt;</span></span><br><span class="line"><span class="comment">&lt;/table&gt;</span></span><br><span class="line"><span class="comment">&lt;table tableName=&quot;promotion&quot; domainObjectName=&quot;Promotion&quot;</span></span><br><span class="line"><span class="comment">enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot; &gt;</span></span><br><span class="line"><span class="comment">&lt;generatedKey column=&quot;ID&quot; sqlStatement=&quot;MYSQL&quot; identity=&quot;true&quot; /&gt;</span></span><br><span class="line"><span class="comment">&lt;columnOverride column=&quot;promotion_price&quot; jdbcType=&quot;DECIMAL&quot; javaType=&quot;java.math.BigDecimal&quot; /&gt;</span></span><br><span class="line"><span class="comment">&lt;columnOverride column=&quot;start_time&quot; jdbcType=&quot;TIMESTAMP&quot; javaType=&quot;java.sql.Timestamp&quot; /&gt;</span></span><br><span class="line"><span class="comment">&lt;columnOverride column=&quot;end_time&quot; jdbcType=&quot;TIMESTAMP&quot; javaType=&quot;java.sql.Timestamp&quot; /&gt;</span></span><br><span class="line"><span class="comment">&lt;/table&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>根据模板，添加我想生成的实体类和对应的数据库中的表名。</p>
<ol start="3">
<li><p>在项目目录下运行CMD 或用IDEA内置的Terminal，输入下方指令，利用Maven来构建代码。</p>
<p><code>D:\Data\IDEA DATA\nuomishe&gt;mvn mybatis-generator:generate</code></p>
</li>
</ol>
<p><img src="/2021/09/17/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/03-Mybatis-Mybatis%20Plus/Mybatis-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/image-20210917194207967.png" alt="image-20210917194207967"></p>
<p>至此，代码便自动生成成功。</p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot整合Mybatis完整详细版</title>
    <url>/2020/10/28/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/03-Mybatis-Mybatis%20Plus/SpringBoot%20%E6%95%B4%E5%90%88Mybais/</url>
    <content><![CDATA[<h1 id="SpringBoot整合Mybatis完整详细版"><a href="#SpringBoot整合Mybatis完整详细版" class="headerlink" title="SpringBoot整合Mybatis完整详细版"></a>SpringBoot整合Mybatis完整详细版</h1><p>记得刚接触SpringBoot时，大吃一惊，世界上居然还有这么省事的框架，立马感叹：SpringBoot是世界上最好的框架。哈哈！</p>
<p>当初跟着教程练习搭建了一个框架，传送门：<a href="https://blog.csdn.net/iku5200/article/details/81163395">spring boot + jpa + bootstrap + thymeleaf 简单的增删改查Demo</a></p>
<p>后来进了新公司，用不到而且忙于任务，今天重温一遍居然有些忘了，看来真是好记性不如烂笔头。于是写下本篇SpringBoot整合Mybatis的文章，做个笔记。</p>
<p>本章节主要搭建框架，下章节实现登录注册以及拦截器的配置：<a href="https://blog.csdn.net/iku5200/article/details/82878893">SpringBoot整合Mybatis完整详细版二：注册、登录、拦截器配置</a></p>
<p>本章项目源码下载：<a href="https://download.csdn.net/download/iku5200/10690117">springBoot整合mybatis完整详细版</a></p>
<p>github地址：<a href="https://github.com/zhanghao/springBoot_Mybatis">https://github.com/zhanghao/springBoot_Mybatis</a></p>
<p><strong>练习完此篇，可下载<a href="http://blog.zhanghao.top/2019/09/30/%E4%B8%80%E5%B0%8F%E6%97%B6%E5%BF%AB%E9%80%9F%E6%92%B8%E5%87%BA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE/">一小时快速撸出一个短网址生成项目</a>源码来看（欢迎star），也是非常适合入门练手的。</strong></p>
<p>天也不早了，言归正传，开始</p>
<hr>
<blockquote>
<p>IDE：idea、DB：mysql</p>
</blockquote>
<ul>
<li><strong><em>新建一个Spring Initializr项目</em></strong></li>
</ul>
<p><img src="https://img-blog.csdn.net/20180926174038560?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li><strong><em>创建项目的文件结构以及jdk的版本</em></strong> </li>
</ul>
<p><img src="https://img-blog.csdn.net/20180926174149120?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li><strong><em>选择项目所需要的依赖</em></strong></li>
</ul>
<p><img src="https://img-blog.csdn.net/20180926174507971?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li><strong><em>修改项目名，finish完成</em></strong></li>
</ul>
<p><img src="https://img-blog.csdn.net/20180926174536917?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li><strong><em>来看下建好后的pom</em></strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><em>修改配置文件</em></strong></li>
</ul>
<p>本文不使用application.properties文件  而使用更加简洁的application.yml文件。将resource文件夹下原有的application.properties文件删除，创建application.yml配置文件（备注：其实SpringBoot底层会把<strong>application.yml文件解析为\</strong>application.properties****），本文创建了两个yml文件（application.yml和application-dev.yml），分别来看一下内容</p>
<p>application.yml</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br></pre></td></tr></table></figure>

<p>application-dev.yml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line"> </span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: <span class="number">1234</span></span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC</span></span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line"> </span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapping<span class="comment">/*Mapper.xml</span></span><br><span class="line"><span class="comment">  type-aliases-package: com.example.entity</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">#showSql</span></span><br><span class="line"><span class="comment">logging:</span></span><br><span class="line"><span class="comment">  level:</span></span><br><span class="line"><span class="comment">    com:</span></span><br><span class="line"><span class="comment">      example:</span></span><br><span class="line"><span class="comment">        mapper : debug</span></span><br></pre></td></tr></table></figure>

<p>两个文件的意思是：</p>
<blockquote>
<p>在项目中配置多套环境的配置方法。<br> 因为现在一个项目有好多环境，开发环境，测试环境，准生产环境，生产环境，每个环境的参数不同，所以我们就可以把每个环境的参数配置到yml文件中，这样在想用哪个环境的时候只需要在主配置文件中将用的配置文件写上就行如application.yml</p>
<p>笔记：在Spring Boot中多环境配置文件名需要满足application-{profile}.yml的格式，其中{profile}对应你的环境标识，比如：</p>
<p>application-dev.yml：开发环境<br> application-test.yml：测试环境<br> application-prod.yml：生产环境<br> 至于哪个具体的配置文件会被加载，需要在application.yml文件中通过spring.profiles.active属性来设置，其值对应{profile}值。</p>
</blockquote>
<p>还有配置文件中最好不要有中文注释，会报错。</p>
<p>解决方法（未测试）：<a href="https://blog.csdn.net/u013887008/article/details/82528066">spring boot application.yml文件中文注释乱码</a></p>
<p>接下来把启动文件移到com.example下，而且springboot的启动类不能放在java目录下！！！必须要个包将它包进去</p>
<p>否则会报错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Your ApplicationContext is unlikely to start due to a @ComponentScan of the default package.</span><br></pre></td></tr></table></figure>

<p>这个原因值得注意就是因为有时候很难在IDEA中的项目目录认出来这个错误并且还容易扫描不到一些类，传送门：<a href="https://blog.csdn.net/iku5200/article/details/81112665">SpringBoot扫描不到controller</a></p>
<p>​      <img src="https://img-blog.csdn.net/20180726185807306?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nX2xpX2tl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img">       <img src="https://img-blog.csdn.net/20180726185825592?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nX2xpX2tl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li><strong><em>然后开始创建实体类实现业务流程</em></strong></li>
</ul>
<p>创建包controller、entity、mapper、service。resources下创建mapping文件夹，用于写sql语句，也可以用注解的方式直接写在mapper文件里。下面直接贴代码</p>
<p>数据库表结构（之前小项目的表，直接拿来用）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`userName`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`passWord`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`realName`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180927092715962?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>entity.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.entity;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:zhanghao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/9/26 0026</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 14:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String passWord;</span><br><span class="line">    <span class="keyword">private</span> String realName;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> passWord;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassWord</span><span class="params">(String passWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRealName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> realName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRealName</span><span class="params">(String realName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realName = realName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, userName=&#x27;&quot;</span> + userName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, passWord=&#x27;&quot;</span> + passWord + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, realName=&#x27;&quot;</span> + realName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserController.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.controller;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:zhanghao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/9/26 0026</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 14:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testBoot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;getUser/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">GetUser</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.Sel(id).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserService.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:zhanghao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/9/26 0026</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 15:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">Sel</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.Sel(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserMapper.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mapper;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:zhanghao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/9/26 0026</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 15:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function">User <span class="title">Sel</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserMapper.xml</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">package com.example.mapper;</span><br><span class="line"> </span><br><span class="line">import com.example.entity.User;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * @Author:zhanghao</span><br><span class="line"> * @Date: 2018/9/26 0026</span><br><span class="line"> * @Time: 15:20</span><br><span class="line"> */</span><br><span class="line">@Repository</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line"> </span><br><span class="line">    User Sel(int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><em>最终框架结构</em></strong></li>
</ul>
<p><img src="https://img-blog.csdn.net/20180927095129598?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"><img src="https://img-blog.csdn.net/20180927095234881?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li><strong><em>完成以上，下面在启动类里加上注解用于给出需要扫描的mapper文件路径@MapperScan(“com.example.mapper”)</em></strong> </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span> <span class="comment">//扫描的mapper</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><em>最后启动，浏览器输入地址看看吧：<a href="http://localhost:8080/testBoot/getUser/1">http://localhost:8080/testBoot/getUser/1</a></em></strong></li>
</ul>
<p><img src="https://img-blog.csdn.net/20180927092946586?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>测试成功，就这样基本框架就搭建成功了</p>
<ul>
<li><strong><em>最后给个番外篇如何更改启动时显示的字符拼成的字母，就是更改下图标红框的地方</em></strong></li>
</ul>
<p><img src="https://img-blog.csdn.net/20180927093510607?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>其实很好改，只需要在resources下新建一个txt文件就可以，命名为banner.txt，那这种字符该怎么拼出来呢，下面推荐一个网址，有这种工具，链接传送门：[字母转字符](<a href="http://patorjk.com/software/taag/#p=display&amp;f=Graffiti&amp;t=Type">http://patorjk.com/software/taag/#p=display&amp;f=Graffiti&amp;t=Type</a> Something )。如下：</p>
<p><img src="https://img-blog.csdn.net/20180926172941481?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>直接输入要生成的字母，系统会自动转换，然后复制下面转换好的字符到新建的banner.txt文件中，重新启动项目就可以了。</p>
<p><img src="https://img-blog.csdn.net/20180927095715246?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lrdTUyMDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<hr>
<p>—路漫漫其修远兮，吾将上下而求索</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>MyBatis</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 配置静态资源的地址与访问路径（spring.mvc.static-path-pattern和spring.web.resources.static-locations）</title>
    <url>/2021/09/17/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/04-Spring%20Boot/Spring%20Boot%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%EF%BC%88spring-mvc-static-path-pattern%E5%92%8Cspring-web-resources-static-locations%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、原理解释"><a href="#一、原理解释" class="headerlink" title="一、原理解释"></a>一、原理解释</h1><p>静态资源过滤是说不做请求处理，直接能够打开访问！</p>
<p>静态资源路径是指系统可以直接访问的路径，且路径下的所有文件均可被用户通过浏览器直接读取。</p>
<h2 id="1-1静态资源的地址：“spring-mvc-static-path-pattern”"><a href="#1-1静态资源的地址：“spring-mvc-static-path-pattern”" class="headerlink" title="1.1静态资源的地址：“spring.mvc.static-path-pattern”"></a>1.1静态资源的地址：“spring.mvc.static-path-pattern”</h2><p>spring.mvc.static-path-pattern代表的含义是我们应该以什么样的路径来访问静态资源，换句话说，只有静态资源满足什么样的匹配条件，Spring Boot才会处理静态资源请求，以官方配置为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#   这表示只有静态资源的访问路径为&#x2F;resources&#x2F;**时，才会处理请求</span><br><span class="line">spring.mvc.static-path-pattern&#x3D;&#x2F;resources&#x2F;**，</span><br></pre></td></tr></table></figure>

<p>假定采用默认的配置端口，那么只有请求地址类似于“<a href="http://localhost:8080/resources/jquery.js%E2%80%9D%E6%97%B6%EF%BC%8CSpring">http://localhost:8080/resources/jquery.js”时，Spring</a>  Boot才会处理此请求，处理方式是将根据模式匹配后的文件名查找本地文件，那么应该在什么地方查找本地文件呢？这就是“spring.resources.static-locations”的作用了。</p>
<h2 id="1-2-访问路径：“spring-web-resources-static-locations”"><a href="#1-2-访问路径：“spring-web-resources-static-locations”" class="headerlink" title="1.2. 访问路径：“spring.web.resources.static-locations”"></a>1.2. 访问路径：“spring.web.resources.static-locations”</h2><p>“spring.resources.static-locations”用于告诉Spring Boot应该在何处查找静态资源文件，这是一个列表性的配置，查找文件时会依赖于配置的先后顺序依次进行，默认的官方配置如下：</p>
<p>spring.resources.static-locations=classpath:/static,classpath:/public,classpath:/resources,classpath:/META-INF/resources</p>
<p>继续以上面的请求地址为例，“<a href="http://localhost:8080/resources/jquery.js%E2%80%9D%E5%B0%B1%E4%BC%9A%E5%9C%A8%E4%B8%8A%E8%BF%B0%E7%9A%84%E5%9B%9B%E4%B8%AA%E8%B7%AF%E5%BE%84%E4%B8%AD%E4%BE%9D%E6%AC%A1%E6%9F%A5%E6%89%BE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E2%80%9Cjquery.js%E2%80%9D%E6%96%87%E4%BB%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%89%BE%E5%88%B0%E4%BA%86%EF%BC%8C%E5%88%99%E8%BF%94%E5%9B%9E%E6%AD%A4%E6%96%87%E4%BB%B6%EF%BC%8C%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E404%E9%94%99%E8%AF%AF%E3%80%82">http://localhost:8080/resources/jquery.js”就会在上述的四个路径中依次查找是否存在“jquery.js”文件，如果找到了，则返回此文件，否则返回404错误。</a></p>
<h2 id="1-3-静态资源的Bean配置"><a href="#1-3-静态资源的Bean配置" class="headerlink" title="1.3. 静态资源的Bean配置"></a>1.3. 静态资源的Bean配置</h2><p>从上面可以看出，“spring.mvc.static-path-pattern”与“spring.resources.static-locations”组合起来演绎了nginx的映射配置，如果熟悉Spring MVC，那么理解起来更加简单，它们的作用可以用Bean配置表示，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;&#x2F;resources&#x2F;**&quot;)</span><br><span class="line">                .addResourceLocations(&quot;&#x2F;public-resources&#x2F;&quot;)</span><br><span class="line">                .setCacheControl(CacheControl.maxAge(1, TimeUnit.HOURS).cachePublic());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者等同与以下的XML。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mvc:resources mapping&#x3D;&quot;&#x2F;resources&#x2F;**&quot; location&#x3D;&quot;&#x2F;public-resources&#x2F;&quot;&gt;</span><br><span class="line">    &lt;mvc:cache-control max-age&#x3D;&quot;3600&quot; cache-public&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mvc:resources&gt;</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们既可以直接通过application.properties的配置文件进行配置，也可以通过自己写静态资源的Bean配置文件。</p>
<p>“spring.mvc.static-path-pattern”用于阐述HTTP请求地址，而“spring.resources.static-locations”则用于描述静态资源的存放位置。</p>
<h2 id="二-示例配置静态资源的地址与访问路径配置"><a href="#二-示例配置静态资源的地址与访问路径配置" class="headerlink" title="二.示例配置静态资源的地址与访问路径配置"></a>二.示例配置静态资源的地址与访问路径配置</h2><h2 id="2-1-SpringBoot静态资源处理"><a href="#2-1-SpringBoot静态资源处理" class="headerlink" title="2.1.SpringBoot静态资源处理"></a>2.1.SpringBoot静态资源处理</h2><p>默认情况下Spring Boot 使用WebMvcAutoConfiguration中配置的各种属性。</p>
<p>默认映射的文件夹有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classpath:&#x2F;META-INF&#x2F;resources</span><br><span class="line">classpath:&#x2F;resources</span><br><span class="line">classpath:&#x2F;static</span><br><span class="line">classpath:&#x2F;public</span><br></pre></td></tr></table></figure>

<p>上面这几个都是静态资源的映射路径，优先级顺序为：META-INF/resources &gt; resources &gt; static &gt; public</p>
<h2 id="2-2修改默认访问路径"><a href="#2-2修改默认访问路径" class="headerlink" title="2.2修改默认访问路径"></a>2.2修改默认访问路径</h2><p>修改spring.mvc.static-path-pattern来修改默认的映射**，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># web.upload-url&#x3D;http:&#x2F;&#x2F;48.56.366.75:8100&#x2F;api&#x2F;</span><br><span class="line">web.vue-path&#x3D;D:&#x2F;Project&#x2F;myweb&#x2F;admin&#x2F;</span><br><span class="line">spring.mvc.static-path-pattern&#x3D;\&#x2F;**</span><br><span class="line">spring.web.resources.static-locations&#x3D;classpath:&#x2F;META-INF&#x2F;resources&#x2F;,classpath:&#x2F;resources&#x2F;,classpath:&#x2F;static&#x2F;,classpath:&#x2F;public&#x2F;,file:$&#123;web.vue-path&#125;</span><br></pre></td></tr></table></figure>

<p>spring.mvc.static-path-pattern=/**是这个，代码块是为了转义，否则影响下一行，不知道为啥还显示<del>~</del></p>
<p>程序的jar包放在了<br> D:/Project/myweb/</p>
]]></content>
  </entry>
  <entry>
    <title>Spring Boot系列 @ControllerAdvice拦截异常并统一处理</title>
    <url>/2021/09/18/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/04-Spring%20Boot/Spring-Boot%E7%B3%BB%E5%88%97-ControllerAdvice%E6%8B%A6%E6%88%AA%E5%BC%82%E5%B8%B8%E5%B9%B6%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>在spring 3.2中，新增了@ControllerAdvice  注解，可以用于定义@ExceptionHandler、@InitBinder、@ModelAttribute，并应用到所有@RequestMapping中。参考：@ControllerAdvice 文档</p>
<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><strong>创建 MyControllerAdvice，并添加 @ControllerAdvice注解。</strong><br> 第一种，返回map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.WebDataBinder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * controller 增强器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用到所有<span class="doctag">@RequestMapping</span>注解方法，在其执行之前初始化数据绑定器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> binder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把值绑定到Model中，使全局<span class="doctag">@RequestMapping</span>可以获取到该值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAttributes</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;author&quot;</span>, <span class="string">&quot;Magical Sam&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局异常捕捉处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">errorHandler</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种,返回ModelAndView</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.cngrain.gateway.util.ErrorResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.exception.ExceptionUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @类名 GlobalExceptionHandler</span></span><br><span class="line"><span class="comment"> * @描述 全局异常捕获</span></span><br><span class="line"><span class="comment"> * @作者 </span></span><br><span class="line"><span class="comment"> * @日期 </span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_ERROR_VIEW = <span class="string">&quot;error&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @名称 defaultErrorHandler</span></span><br><span class="line"><span class="comment">     * @描述</span></span><br><span class="line"><span class="comment">     *      我们只需要在Controller中抛出Exception，当然我们可能会有多种不同的Exception。</span></span><br><span class="line"><span class="comment">     *      然后在<span class="doctag">@ControllerAdvice</span>类中，根据抛出的具体Exception类型匹配<span class="doctag">@ExceptionHandler</span></span></span><br><span class="line"><span class="comment">     *      中配置的异常类型来匹配错误映射和处理。</span></span><br><span class="line"><span class="comment">     * @参数 [request, e]</span></span><br><span class="line"><span class="comment">     * @返回值 org.springframework.web.servlet.ModelAndView</span></span><br><span class="line"><span class="comment">     * @作者 </span></span><br><span class="line"><span class="comment">     * @时间 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">defaultErrorHandler</span><span class="params">(HttpServletRequest request, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mav.addObject(<span class="string">&quot;exception&quot;</span>, e);</span><br><span class="line">        mav.addObject(<span class="string">&quot;url&quot;</span>, request.getRequestURL());</span><br><span class="line">        mav.setViewName(DEFAULT_ERROR_VIEW);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @名称 jsonErrorHandler</span></span><br><span class="line"><span class="comment">     * @描述</span></span><br><span class="line"><span class="comment">     *      通过<span class="doctag">@ControllerAdvice</span>统一定义不同Exception映射到不同错误处理页面。</span></span><br><span class="line"><span class="comment">     *      而当我们要实现RESTful API时，返回的错误是JSON格式的数据，而不是HTML页面，这时候我们也能轻松支持。</span></span><br><span class="line"><span class="comment">     *      本质上，只需在<span class="doctag">@ExceptionHandler</span>之后加入<span class="doctag">@ResponseBody</span>，就能让处理函数return的内容转换为JSON格式。</span></span><br><span class="line"><span class="comment">     * @参数 [request, e]</span></span><br><span class="line"><span class="comment">     * @返回值 com.cngrain.gateway.exception.ErrorInfo&lt;java.lang.String&gt;</span></span><br><span class="line"><span class="comment">     * @作者 </span></span><br><span class="line"><span class="comment">     * @时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MyException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorInfo&lt;String&gt; <span class="title">jsonErrorHandler</span><span class="params">(HttpServletRequest request, MyException e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ErrorInfo&lt;String&gt; r = <span class="keyword">new</span> ErrorInfo&lt;&gt;();</span><br><span class="line">        r.setMessage(e.getMessage()==<span class="keyword">null</span>?<span class="string">&quot;空&quot;</span>:e.getMessage());</span><br><span class="line">        r.setCode(ErrorInfo.ERROR);</span><br><span class="line">        r.setData(<span class="string">&quot;Some Data&quot;</span>);</span><br><span class="line">        r.setUrl(request.getRequestURL().toString());</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ErrorResult <span class="title">buildError</span><span class="params">(Exception exception)</span> </span>&#123;</span><br><span class="line">        ErrorResult error = <span class="keyword">new</span> ErrorResult();</span><br><span class="line">        error.setType(exception.getClass().getName());</span><br><span class="line">        error.setMessage(ExceptionUtils.getMessage(exception)==<span class="keyword">null</span>?<span class="string">&quot;空&quot;</span>:ExceptionUtils.getMessage(exception));</span><br><span class="line">        error.setStackTrace(ExceptionUtils.getStackTrace(exception));</span><br><span class="line">        error.setDate(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>启动应用后，被 @ExceptionHandler、@InitBinder、@ModelAttribute 注解的方法，都会作用在 被 @RequestMapping 注解的方法上。<br> @ModelAttribute：在Model上设置的值，对于所有被 @RequestMapping 注解的方法中，都可以通过 ModelMap 获取，如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/home&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">(ModelMap modelMap)</span> </span>&#123;</span><br><span class="line">    System.out.println(modelMap.get(<span class="string">&quot;author&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者 通过@ModelAttribute获取</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/home&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">(<span class="meta">@ModelAttribute(&quot;author&quot;)</span> String author)</span> </span>&#123;</span><br><span class="line">    System.out.println(author);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@ExceptionHandler 拦截了异常，我们可以通过该注解实现自定义异常处理。其中，@ExceptionHandler 配置的 value 指定需要拦截的异常类型，上面拦截了 Exception.class 这种异常。</strong></p>
<h2 id="二、自定义异常处理（全局异常处理）"><a href="#二、自定义异常处理（全局异常处理）" class="headerlink" title="二、自定义异常处理（全局异常处理）"></a>二、自定义异常处理（全局异常处理）</h2><p>spring boot 默认情况下会映射到 /error 进行异常处理，但是提示并不十分友好，下面自定义异常处理，提供友好展示。<br> <strong>1、编写自定义异常类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter &amp; setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：spring 对于 RuntimeException 异常才会进行事务回滚。<br> <strong>2、编写全局异常处理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.WebDataBinder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局异常捕捉处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">errorHandler</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截捕捉自定义异常 MyException.class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MyException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">myErrorHandler</span><span class="params">(MyException ex)</span> </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>, ex.getCode());</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>, ex.getMsg());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、controller中抛出异常进行测试。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/home&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        throw new Exception(&quot;Sam 错误&quot;);</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">&quot;101&quot;</span>, <span class="string">&quot;Sam 错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>启动应用，访问：<a href="http://localhost:8080/home">http://localhost:8080/home</a> ，正常显示以下json内容，证明自定义异常已经成功被拦截。</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;msg&quot;</span>:<span class="string">&quot;Sam 错误&quot;</span>,<span class="attr">&quot;code&quot;</span>:<span class="string">&quot;101&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>*** 如果不需要返回json数据，而要渲染某个页面模板返回给浏览器，那么MyControllerAdvice中可以这么实现：**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(value = MyException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">myErrorHandler</span><span class="params">(MyException ex)</span> </span>&#123;</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;code&quot;</span>, ex.getCode());</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;msg&quot;</span>, ex.getMsg());</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 templates 目录下，添加 error.html ：</strong><br>注意：这里的html名称必须和 <code>modelAndView.setViewName(&quot;error&quot;);</code> 时设置的ViewName同名才可以定位到。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>错误页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>$&#123;code&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>$&#123;msg&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>重启应用，<a href="http://localhost:8080/home">http://localhost:8080/home</a> 就能显示自定的错误页面内容。<br> 补充：如果全部异常处理返回json，那么可以使用 @RestControllerAdvice 代替 @ControllerAdvice ，这样在方法上就可以不需要添加 @ResponseBody。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>Spring Boot：内置tomcat启动和外部tomcat部署总结：</title>
    <url>/2020/11/18/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/04-Spring%20Boot/Spring-Boot%EF%BC%9A%E5%86%85%E7%BD%AEtomcat%E5%90%AF%E5%8A%A8%E5%92%8C%E5%A4%96%E9%83%A8tomcat%E9%83%A8%E7%BD%B2%E6%80%BB%E7%BB%93%EF%BC%9A/</url>
    <content><![CDATA[<h1 id="Spring-Boot：内置tomcat启动和外部tomcat部署总结"><a href="#Spring-Boot：内置tomcat启动和外部tomcat部署总结" class="headerlink" title="Spring Boot：内置tomcat启动和外部tomcat部署总结"></a>Spring Boot：内置tomcat启动和外部tomcat部署总结</h1><p>springboot的web项目的启动主要分为：内置Tomcat启动和外部Tomcat启动。</p>
<h1 id="使用内置tomcat启动"><a href="#使用内置tomcat启动" class="headerlink" title="使用内置tomcat启动"></a>使用内置tomcat启动</h1><h2 id="启动方式："><a href="#启动方式：" class="headerlink" title="启动方式："></a>启动方式：</h2><p>1、IDEA中main函数启动</p>
<p>2、mvn springboot-run 命令</p>
<p>3、java -jar XXX.jar</p>
<h2 id="配置内置tomcat属性："><a href="#配置内置tomcat属性：" class="headerlink" title="配置内置tomcat属性："></a>配置内置tomcat属性：</h2><p>关于Tomcat的属性都在org.springframework.boot.autoconfigure.web.ServerProperties配置类中做了定义，我们只需在application.properties配置属性做配置即可。通用的Servlet容器配置都已”server”左右前缀，而Tomcat特有配置都以”server.tomcat”作为前缀。下面举一些常用的例子。</p>
<h3 id="配置Servlet容器："><a href="#配置Servlet容器：" class="headerlink" title="配置Servlet容器："></a>配置Servlet容器：</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置程序端口，默认为8080</span></span><br><span class="line"><span class="string">server.port=</span> <span class="number">8080</span></span><br><span class="line"><span class="comment">#用户绘画session过期时间，以秒为单位</span></span><br><span class="line"><span class="string">server.session.timeout=</span></span><br><span class="line"><span class="comment"># 配置默认访问路径，默认为/</span></span><br><span class="line"><span class="string">server.context-path=</span></span><br></pre></td></tr></table></figure>

<h3 id="配置Tomcat："><a href="#配置Tomcat：" class="headerlink" title="配置Tomcat："></a>配置Tomcat：</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置Tomcat编码,默认为UTF-8</span></span><br><span class="line"><span class="string">server.tomcat.uri-encoding=UTF-8</span></span><br><span class="line"><span class="comment"># 配置最大线程数</span></span><br><span class="line"><span class="string">server.tomcat.max-threads=1000</span></span><br></pre></td></tr></table></figure>



<h1 id="使用外置tomcat部署"><a href="#使用外置tomcat部署" class="headerlink" title="使用外置tomcat部署"></a>使用外置tomcat部署</h1><h2 id="配置步骤："><a href="#配置步骤：" class="headerlink" title="配置步骤："></a>配置步骤：</h2><h3 id="继承SpringBootServletInitializer"><a href="#继承SpringBootServletInitializer" class="headerlink" title="继承SpringBootServletInitializer"></a>继承SpringBootServletInitializer</h3><ul>
<li>外部容器部署的话，就不能依赖于Application的main函数了，而是要以类似于web.xml文件配置的方式来启动Spring应用上下文，此时我们需要在启动类中继承SpringBootServletInitializer并实现configure方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjt.chapter05;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.support.SpringBootServletInitializer;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chapter05Application</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(Chapter05Application.class);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Chapter05Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类的作用与在web.xml中配置负责初始化Spring应用上下文的监听器作用类似，只不过在这里不需要编写额外的XML文件了。</p>
<h3 id="pom-xml修改tomcat相关的配置"><a href="#pom-xml修改tomcat相关的配置" class="headerlink" title="pom.xml修改tomcat相关的配置"></a>pom.xml修改tomcat相关的配置</h3><p>　　<em>首先介绍下maven中scope依赖范围的概念，因为后续涉及到这个会有问题。</em></p>
<p>　　<em>依赖范围就是用来控制依赖和三种classpath(编译classpath，测试classpath、运行classpath)的关系，Maven有如下几种依赖范围：</em></p>
<ul>
<li><em>compile:编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-code,在编译、测试和运行的时候都需要使用该依赖。</em></li>
<li><em>test: 测试依赖范围。使用次依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此依赖。典型的例子是Jnuit,它只有在编译测试代码及运行测试的时候才需要。</em></li>
<li><em>provided:已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时候无效。典型的例子是servlet-api,编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器以及提供，就不需要Maven重复地引入一遍。</em></li>
</ul>
<p>如果要将最终的打包形式改为war的话，还需要对pom.xml文件进行修改，因为spring-boot-starter-web中包含内嵌的tomcat容器，所以直接部署在外部容器会冲突报错。这里有两种方法可以解决，如下</p>
<ol>
<li>方法一：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这里需要移除对嵌入式Tomcat的依赖，这样打出的war包中，在lib目录下才不会包含Tomcat相关的jar包，否则将会出现启动错误。</p>
<p>还有一个很关键的关键点，就是tomcat-embed-jasper中scope必须是provided。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为SpringBootServletInitializer需要依赖  javax.servlet，而tomcat-embed-jasper下面的tomcat-embed-core中就有这个javax.servlet，如果没用provided，最终打好的war里面会有servlet-api这个jar，这样就会跟tomcat本身的冲突了。这个关键点同样适应于下面说的第二种方法。</p>
<ol start="2">
<li>方法二：</li>
</ol>
<p>直接添加如下配置即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--部署成war包时开启↓↓↓↓--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--部署成war包时开启↑↑↑↑--&gt;</span></span><br></pre></td></tr></table></figure>

<p>provided的作用上面已经介绍的很透彻了，这里就不啰嗦了，这种方式的好处是，打包的war包同时适合java -jar命令启动以及部署到外部容器中。</p>
<h3 id="由jar变成war"><a href="#由jar变成war" class="headerlink" title="由jar变成war"></a>由jar变成war</h3><p><packaging>war</packaging></p>
<h3 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h3><p>此时打成的包的名称应该和application.properties的 </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.context-path</span>=<span class="string">/test</span></span><br></pre></td></tr></table></figure>

<p>保持一致</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>test<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果不一样发布到tomcat的webapps下上下文会变化</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot 打包成jar部署并运行</title>
    <url>/2020/11/18/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/04-Spring%20Boot/spring-boot-%E6%89%93%E5%8C%85%E6%88%90jar%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="spring-boot-打包成jar并部署运行"><a href="#spring-boot-打包成jar并部署运行" class="headerlink" title="spring boot 打包成jar并部署运行"></a>spring boot 打包成jar并部署运行</h1><p><strong>前言:spring boot 一般作为spring could 子项目，一般使用的是jar的方式进行部署，用war的方式很少，因为其本身集成了tomcat插件，也有使用哪种组合部署的方式，这里我们介绍jar的方式</strong></p>
<h2 id="maven-打包的形式"><a href="#maven-打包的形式" class="headerlink" title="maven 打包的形式"></a>maven 打包的形式</h2><ol>
<li><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-restful<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-restful :: Spsringboot 实现 Restful 服务，基于 HTTP / JSON 传输 Demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!---定义成jar的方式--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后再pom文件中定义启动的类的名称就是应用程序，启动的入口类</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>org.spring.springboot.Application<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>之后再定义spring boot 的入口类的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.spring.springboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.spring.springboot.dao.CityDao;</span><br><span class="line"><span class="keyword">import</span> org.spring.springboot.domain.City;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.support.SpringBootServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring Boot 应用启动类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by bysocket on 16/4/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// Spring Boot 应用的标识</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// mapper 接口类扫描包配置</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;org.spring.springboot.dao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 程序启动入口</span></span><br><span class="line">        <span class="comment">// 启动嵌入式的 Tomcat 并初始化 Spring 环境及其各 Spring 组件</span></span><br><span class="line">        SpringApplication.run(Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//为了打包springboot项目</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(<span class="keyword">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是继承SpringBootServletInitializer 和重写 configure方法</p>
<ol start="4">
<li><p>然后到项目的pom平级的目录下面</p>
<p>使用mvn clean package 命令打包成jar</p>
</li>
</ol>
<h2 id="执行项目"><a href="#执行项目" class="headerlink" title="执行项目"></a>执行项目</h2><p>到打包成的jar目录下面执行</p>
<p>java -jar xxx.jar</p>
<p>即可执行 项目了</p>
<p>​    </p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot +thymeleaf 实现本地图片显示，和数据库查询显示</title>
    <url>/2021/09/16/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/04-Spring%20Boot/springboot-thymeleaf-%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%EF%BC%8C%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>在页面显示静态资源，在程序中非常常见，当然也有很多种方式例如保存在resources/META-INF目录下或直接引用本地路径等。</p>
<h2 id="1、了解springboot的静态资源的地址与访问路径"><a href="#1、了解springboot的静态资源的地址与访问路径" class="headerlink" title="1、了解springboot的静态资源的地址与访问路径"></a>1、了解springboot的静态资源的地址与访问路径</h2><p>springboot自己是有默认的静态访问资源地址和路径（默认寻找static目录），如果你在配置文件中修改<br> 则会覆盖其默认配置。<br> 那先来了解一下在配置文件中想更改默认地址的代码：</p>
<h3 id="spring-mvc-static-path-pattern"><a href="#spring-mvc-static-path-pattern" class="headerlink" title="spring.mvc.static-path-pattern"></a>spring.mvc.static-path-pattern</h3><p>这句话的意思的你应该以什么路径来访问静态资源，也可以说静态资源满足这个配置路径才会处理此请求。</p>
<blockquote>
<p>#这种情况下只有请求路径满足img格式才可以处理此请求<br> #如果按照默认的8080端口的话那么路径就应该为localhost:8080/img/1.jpg<br> #此时我们想找寻1.jpg的图片,那么springboot就会默认在该路径下寻找对应的文件，<br> #而寻找对应文件的地址就应该由spring.resources.static-locations里决定<br> <code>spring.mvc.static-path-pattern=/img/**</code></p>
</blockquote>
<h3 id="spring-resources-static-locations"><a href="#spring-resources-static-locations" class="headerlink" title="spring.resources.static-locations"></a>spring.resources.static-locations</h3><blockquote>
<p>这行代码配置用来告诉springboot应该去什么路径下访问并寻找相应的文件</p>
</blockquote>
<p>默认的官方配置</p>
<blockquote>
<p><code>pring.resources.static-locations=classpath:/static,classpath:/public,classpath:/resources,classpath:/META-INF/resources</code><br> 这里的匹配机制是列表性的会依次寻找相应目录是否有对应的文件<br> 但是大家也都发现了，这些是项目里自带的资源目录如果我又想访问本地<br> 路径的资源呐？</p>
</blockquote>
<p>引用本地路径资源</p>
<blockquote>
<p><code>spring.resources.static-locations=file:F:/images/rotPhoto/</code><br> 这里我们引用的是F盘的路径，想要成功引用只需要在路径前面加上file即可，<br> 不过根据网上资料显示，不同操作系统之间file的写法好像并不相同，这里演示的&gt;Windows的写法。<br> 当然你如果觉得这样不好的话，也可以通过bean的方式来修改，这样的话需要你创建个extends WebMvcConfigurerAdapter 的类，类重写里面的addResourceHandlers方法来进行修改。<br> 通过查阅资料，也可以通过xml的格式来进行修改代码如下：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/resources/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/public-resources/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:cache-control</span> <span class="attr">max-age</span>=<span class="string">&quot;3600&quot;</span> <span class="attr">cache-public</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="总结：spring-mvc-static-path-pattern-更像是指定http请求访问的地址规范，spring-resources-static-locations则是请求之后访问文件的路径"><a href="#总结：spring-mvc-static-path-pattern-更像是指定http请求访问的地址规范，spring-resources-static-locations则是请求之后访问文件的路径" class="headerlink" title="总结：spring.mvc.static-path-pattern 更像是指定http请求访问的地址规范，spring.resources.static-locations则是请求之后访问文件的路径!"></a>总结：spring.mvc.static-path-pattern 更像是指定http请求访问的地址规范，spring.resources.static-locations则是请求之后访问文件的路径!</h4><h2 id="2、结合springboot，thymeleaf-来简单的实现访问本地路径图片到浏览器上！"><a href="#2、结合springboot，thymeleaf-来简单的实现访问本地路径图片到浏览器上！" class="headerlink" title="2、结合springboot，thymeleaf 来简单的实现访问本地路径图片到浏览器上！"></a>2、结合springboot，thymeleaf 来简单的实现访问本地路径图片到浏览器上！</h2><p><em>博主使用工具为sts，maven，boot版本都为截稿前官网最新（2020.6.30）</em></p>
<ol>
<li><p>创建项目</p>
<p> 1.修改静态资源的地址和访问路径的配置文件</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码如下:spring.resources.<span class="keyword">static</span>-locations=file:F:/images/rotPhoto/</span><br><span class="line">		spring.mvc.<span class="keyword">static</span>-path-pattern=<span class="comment">/**</span></span><br><span class="line"><span class="comment">博主使用的是自己F盘路径下的images文件夹里的rotPhoto文件夹下的目录</span></span><br><span class="line"><span class="comment">这里出示的为properties配置文件的代码。</span></span><br><span class="line"><span class="comment">      2.创建controller页面</span></span><br><span class="line"><span class="comment">	  3.创建thymeleaf页面</span></span><br></pre></td></tr></table></figure>

<p>需要的thymeleaf页面配置代码:<code>&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; lang=&quot;en&quot;&gt;</code></p>
<ol>
<li>添加代码<br> 博主创建的thymeleaf页面叫Demo<br> 控制controller代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@RequestMapping(&quot;/Demo&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">demo</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">		String img2 =<span class="string">&quot;/1.jpg&quot;</span>;</span><br><span class="line">		model.addAttribute(<span class="string">&quot;img2&quot;</span>, img2);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Demo&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">博主相应目录有一个jpg格式的图片名<span class="number">1</span>，这里定义一个文件名的字符串</span><br><span class="line">用model向前端页面传值</span><br><span class="line">Demo页面代码如下：</span><br><span class="line">&lt;img th:src=<span class="string">&quot;@&#123;$&#123;img2&#125;&#125;&quot;</span>&gt;</span><br><span class="line">用$&#123;img2&#125; 来接受后台传入的数据，这里用到了th:src</span><br></pre></td></tr></table></figure>

<ol>
<li><p>运行<br> 启动@SpringBootApplication类</p>
<p> 运行成功之后，去浏览器输入请求</p>
<p> 自此显示成功</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>利用start.spring.io网站快速创建Spring项目Demo</title>
    <url>/2020/11/18/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/04-Spring%20Boot/%E5%88%A9%E7%94%A8start-spring-io%E7%BD%91%E7%AB%99%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BASpring%E9%A1%B9%E7%9B%AEDemo/</url>
    <content><![CDATA[<h2 id="登录-start-spring-io网站可以快速创建Spring项目Demo"><a href="#登录-start-spring-io网站可以快速创建Spring项目Demo" class="headerlink" title="登录 start.spring.io网站可以快速创建Spring项目Demo"></a>登录 start.spring.io网站可以快速创建Spring项目Demo</h2><p><img src="/2020/11/18/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/04-Spring%20Boot/%E5%88%A9%E7%94%A8start-spring-io%E7%BD%91%E7%AB%99%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BASpring%E9%A1%B9%E7%9B%AEDemo/123.jpg"></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>web不允许页面直接读取本地硬盘资源</title>
    <url>/2021/09/16/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/%E6%9D%82%E6%96%87/web%E4%B8%8D%E5%85%81%E8%AE%B8%E9%A1%B5%E9%9D%A2%E7%9B%B4%E6%8E%A5%E8%AF%BB%E5%8F%96%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p>读取文件只能在项目下读取</p>
<p>如果你的页面html文件是放在本地的，比如用浏览器打开桌面上的html文件，是可以访问本地图片文件的。<br>如果你的html是在web服务器上的，即浏览器的地址是<code>http://xxx.xxx/xx.html</code>而不是<code>file:///C:/xxx.html</code>，那么是不允许打开file://开头的本地图片的，这是出于安全考虑的。这种情况下你可以按F12看看浏览器的错误信息是不是“not allowed to load local resource”。</p>
]]></content>
  </entry>
  <entry>
    <title>yml配置之static-path-pattern 与 static-locations，静态资源的访问</title>
    <url>/2021/09/17/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/%E6%9D%82%E6%96%87/yml%E9%85%8D%E7%BD%AE%E4%B9%8Bstatic-path-pattern-%E4%B8%8E-static-locations%EF%BC%8C%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p>“spring.mvc.static-path-pattern”用于阐述HTTP请求地址，请求非controller地址，如js,css,img等访问路径需要加上static.</p>
<p>而“spring.resources.static-locations”则用于描述静态资源的存放位置。多个路径（逗号隔开）中依次查找是否存在.mvc: 可以不配置也能访问图片</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvc:</span><br><span class="line"> <span class="keyword">static</span>-path-pattern: /<span class="keyword">static</span><span class="comment">/**</span></span><br><span class="line"><span class="comment">resources:</span></span><br><span class="line"><span class="comment"> static-locations: classpath:/static/,file:D:\\</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/17/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/%E6%9D%82%E6%96%87/yml%E9%85%8D%E7%BD%AE%E4%B9%8Bstatic-path-pattern-%E4%B8%8E-static-locations%EF%BC%8C%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/1075697-20191216222712907-942974671.png" alt="img"></p>
<p>方框1：url中访问路径，这里为：localhost:8080/static/…</p>
<p><img src="/2021/09/17/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/%E6%9D%82%E6%96%87/yml%E9%85%8D%E7%BD%AE%E4%B9%8Bstatic-path-pattern-%E4%B8%8E-static-locations%EF%BC%8C%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/1075697-20200116150925454-1370404471.png"></p>
<p>方框2：本地图片保存的路径，image会根据d:\和浏览器中输入的图片名字自动查找图片</p>
<p><img src="/2021/09/17/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/%E6%9D%82%E6%96%87/yml%E9%85%8D%E7%BD%AE%E4%B9%8Bstatic-path-pattern-%E4%B8%8E-static-locations%EF%BC%8C%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/1075697-20200116150947839-1888084575.png" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title>解决了Web项目查看本地文件的难题！</title>
    <url>/2021/09/16/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/%E6%9D%82%E6%96%87/%E8%A7%A3%E5%86%B3%E4%BA%86Web%E9%A1%B9%E7%9B%AE%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%BE%E9%A2%98%EF%BC%81/</url>
    <content><![CDATA[<h1 id="Spring-Boot：如何配置静态资源的地址与访问路径"><a href="#Spring-Boot：如何配置静态资源的地址与访问路径" class="headerlink" title="Spring Boot：如何配置静态资源的地址与访问路径"></a>Spring Boot：如何配置静态资源的地址与访问路径</h1><p>静态资源，例如HTML文件、JS文件，设计到的Spring  Boot配置有两项，一是“spring.mvc.static-path-pattern”，一是“spring.resources.static-locations”，很多人都难以分辨它们之间的差异，所以经常出现的结果就是404错误，无法找到静态资源。</p>
<h2 id="1-“spring-mvc-static-path-pattern”"><a href="#1-“spring-mvc-static-path-pattern”" class="headerlink" title="1. “spring.mvc.static-path-pattern”"></a>1. “spring.mvc.static-path-pattern”</h2><p>spring.mvc.static-path-pattern代表的含义是我们应该以什么样的路径来访问静态资源，换句话说，只有静态资源满足什么样的匹配条件，Spring Boot才会处理静态资源请求，以官方配置为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#   这表示只有静态资源的访问路径为&#x2F;resources&#x2F;**时，才会处理请求</span><br><span class="line">spring.mvc.static-path-pattern&#x3D;&#x2F;resources&#x2F;**，1</span><br></pre></td></tr></table></figure>

<p>假定采用默认的配置端口，那么只有请求地址类似于“<a href="http://localhost:8080/resources/jquery.js%E2%80%9D%E6%97%B6%EF%BC%8CSpring">http://localhost:8080/resources/jquery.js”时，Spring</a> Boot才会处理此请求，处理方式是将根据模式匹配后的文件名查找本地文件，那么应该在什么地方查找本地文件呢？这就是“spring.resources.static-locations”的作用了。</p>
<h2 id="2-“spring-resources-static-locations”"><a href="#2-“spring-resources-static-locations”" class="headerlink" title="2. “spring.resources.static-locations”"></a>2. “spring.resources.static-locations”</h2><p>“spring.resources.static-locations”用于告诉Spring Boot应该在何处查找静态资源文件，这是一个列表性的配置，查找文件时会依赖于配置的先后顺序依次进行，默认的官方配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.resources.static-locations&#x3D;classpath:&#x2F;static,classpath:&#x2F;public,classpath:&#x2F;resources,classpath:&#x2F;META-INF&#x2F;resources1</span><br></pre></td></tr></table></figure>

<p>继续以上面的请求地址为例，“<a href="http://localhost:8080/resources/jquery.js%E2%80%9D%E5%B0%B1%E4%BC%9A%E5%9C%A8%E4%B8%8A%E8%BF%B0%E7%9A%84%E5%9B%9B%E4%B8%AA%E8%B7%AF%E5%BE%84%E4%B8%AD%E4%BE%9D%E6%AC%A1%E6%9F%A5%E6%89%BE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E2%80%9Cjquery.js%E2%80%9D%E6%96%87%E4%BB%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%89%BE%E5%88%B0%E4%BA%86%EF%BC%8C%E5%88%99%E8%BF%94%E5%9B%9E%E6%AD%A4%E6%96%87%E4%BB%B6%EF%BC%8C%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E404%E9%94%99%E8%AF%AF%E3%80%82">http://localhost:8080/resources/jquery.js”就会在上述的四个路径中依次查找是否存在“jquery.js”文件，如果找到了，则返回此文件，否则返回404错误。</a></p>
<h2 id="3-静态资源的Bean配置"><a href="#3-静态资源的Bean配置" class="headerlink" title="3. 静态资源的Bean配置"></a>3. 静态资源的Bean配置</h2><p>从上面可以看出，“spring.mvc.static-path-pattern”与“spring.resources.static-locations”组合起来演绎了nginx的映射配置，如果熟悉Spring MVC，那么理解起来更加简单，它们的作用可以用Bean配置表示，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/resources/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;/public-resources/&quot;</span>)</span><br><span class="line">                .setCacheControl(CacheControl.maxAge(<span class="number">1</span>, TimeUnit.HOURS).cachePublic());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>或者等同与以下的XML。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/resources/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/public-resources/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:cache-control</span> <span class="attr">max-age</span>=<span class="string">&quot;3600&quot;</span> <span class="attr">cache-public</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:resources</span>&gt;</span>123</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>“spring.mvc.static-path-pattern”用于阐述HTTP请求地址，而“spring.resources.static-locations”则用于描述静态资源的存放位置。</p>
]]></content>
  </entry>
  <entry>
    <title>VMware 虚拟机NAT模式如何设置网络连接</title>
    <url>/2020/11/18/5-%E5%AE%B9%E5%99%A8/%E8%99%9A%E6%8B%9F%E6%9C%BA/VMware-%E8%99%9A%E6%8B%9F%E6%9C%BANAT%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="VMware-虚拟机NAT模式如何设置网络连接"><a href="#VMware-虚拟机NAT模式如何设置网络连接" class="headerlink" title="VMware 虚拟机NAT模式如何设置网络连接"></a>VMware 虚拟机NAT模式如何设置网络连接</h2><p><img src="/2020/11/18/5-%E5%AE%B9%E5%99%A8/%E8%99%9A%E6%8B%9F%E6%9C%BA/VMware-%E8%99%9A%E6%8B%9F%E6%9C%BANAT%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/123.png"></p>
]]></content>
      <categories>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware：主机找不到vmnet1和vmnet8解决方法</title>
    <url>/2020/11/18/5-%E5%AE%B9%E5%99%A8/%E8%99%9A%E6%8B%9F%E6%9C%BA/VMware%EF%BC%9A%E4%B8%BB%E6%9C%BA%E6%89%BE%E4%B8%8D%E5%88%B0vmnet1%E5%92%8Cvmnet8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><img src="/2020/11/18/5-%E5%AE%B9%E5%99%A8/%E8%99%9A%E6%8B%9F%E6%9C%BA/VMware%EF%BC%9A%E4%B8%BB%E6%9C%BA%E6%89%BE%E4%B8%8D%E5%88%B0vmnet1%E5%92%8Cvmnet8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/123.png"></p>
]]></content>
      <categories>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter-notebook文件默认存储路径以及更改方法</title>
    <url>/2020/11/17/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Jupyter%20notebook/Jupyter-notebook%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%94%B9%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Jupyter-notebook文件默认存储路径以及更改方法"><a href="#Jupyter-notebook文件默认存储路径以及更改方法" class="headerlink" title="Jupyter notebook文件默认存储路径以及更改方法"></a>Jupyter notebook文件默认存储路径以及更改方法</h1><h2 id="文件默认存储路径怎么查？"><a href="#文件默认存储路径怎么查？" class="headerlink" title="文件默认存储路径怎么查？"></a>文件默认存储路径怎么查？</h2><ul>
<li>安装Anaconda后，新建文件的默认存储路径一般在C系统盘，那么路径是什么呢？</li>
<li>首先，新建一个.ipynb文件，</li>
</ul>
<p><img src="/2020/11/17/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Jupyter%20notebook/Jupyter-notebook%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%94%B9%E6%96%B9%E6%B3%95/1197448-20190726221603426-804476305.png" alt="img"></p>
<ul>
<li><ul>
<li>输入以下脚本，运行出的结果即是当前jupyter文件默认保存路径</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">print(os.path.abspath(&#39;.&#39;))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/17/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Jupyter%20notebook/Jupyter-notebook%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%94%B9%E6%96%B9%E6%B3%95/1197448-20190726222110330-64960677.png" alt="img"></p>
<h2 id="文件默认存储路径怎么改？"><a href="#文件默认存储路径怎么改？" class="headerlink" title="文件默认存储路径怎么改？"></a>文件默认存储路径怎么改？</h2><ul>
<li>第一步：找到配置文件<ul>
<li>菜单中打开Anaconda Prompt</li>
<li>输入命令 <strong>jupyter notebook –generate-config</strong></li>
<li>根据上面运行处的路径打开C:\Users\HS.jupyter\jupyter_notebook_config.py文件</li>
</ul>
</li>
<li>第二步：更改配置<ul>
<li>找到 **#c.NotebookApp.notebook_dir = ‘’**，去掉该行前面的“#”；在打算存放文件的位置先新建一个文件夹（很重要，最好是英文的），然后将新的路径设置在单引号中，保存配置文件</li>
<li>在开始菜单找到“Jupyte Notebook”快捷键，鼠标右击 – 更多 – 打开文件位置</li>
<li>找到对应的“Jupyte Notebook”快捷图标，鼠标右击 – 属性 – 目标，去掉后面的 “%USERPROFILE%/“（很重要），然后点击“应用”，“确定”　　</li>
<li>重新启动Jupyte Notebook即可</li>
</ul>
</li>
</ul>
<p><em><img src="/2020/11/17/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Jupyter%20notebook/Jupyter-notebook%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%94%B9%E6%96%B9%E6%B3%95/1197448-20190726223157248-811206404.png" alt="img"></em></p>
<p><img src="/2020/11/17/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Jupyter%20notebook/Jupyter-notebook%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%94%B9%E6%96%B9%E6%B3%95/1197448-20190726223338682-2067818899.png" alt="img"></p>
<p> <img src="/2020/11/17/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Jupyter%20notebook/Jupyter-notebook%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%94%B9%E6%96%B9%E6%B3%95/1197448-20190726223442748-163849161.png" alt="img"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>【NLP】Bert中文文本分类实战01-简介（基础理论）</title>
    <url>/2021/02/06/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9801-%E7%AE%80%E4%BB%8B%EF%BC%88%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Bert中文文本分类实战-01-简介"><a href="#Bert中文文本分类实战-01-简介" class="headerlink" title="Bert中文文本分类实战 01 简介"></a>Bert中文文本分类实战 01 简介</h1><p><strong>课程大纲</strong></p>
<p><img src="/2021/02/06/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9801-%E7%AE%80%E4%BB%8B%EF%BC%88%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%EF%BC%89/Bert%E4%B8%AD%E6%96%87-%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98.png" alt="Bert中文-文本分类实战"></p>
<p>本课程需要有一点基础。</p>
<h2 id="自然语言处理简介"><a href="#自然语言处理简介" class="headerlink" title="自然语言处理简介"></a>自然语言处理简介</h2><h3 id="什么是自然语言处理？"><a href="#什么是自然语言处理？" class="headerlink" title="什么是自然语言处理？"></a>什么是自然语言处理？</h3><ul>
<li><p><input checked disabled type="checkbox">  自然语言~人类语言    ：区别于人工语言(比如编程语言C++, JAVA等)</p>
</li>
<li><p><input checked disabled type="checkbox">  自然语言处理:包括语言识别、自然语言理解、自然语言生成、人机交互所涉及的中间阶段</p>
</li>
<li><p><input checked disabled type="checkbox">  自然语言处理是 人工智能 和 计算机科学 的子学科;</p>
</li>
</ul>
<h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h3><p>规则驱动—-&gt;数据驱动</p>
<ul>
<li><p>90年之前，基于规则的方法。</p>
</li>
<li><p>90~2019年，基于统计学的方法 。 朴素贝叶斯，SVM ，  逻辑回归之类</p>
</li>
<li><p>2012年之后，基于深度学习的方法。（国内是16年才开始。  15年国内热衷移动互联网开发，16年深度学习火热）</p>
</li>
</ul>
<h3 id="自然语言处理的主要研究方向"><a href="#自然语言处理的主要研究方向" class="headerlink" title="自然语言处理的主要研究方向"></a>自然语言处理的主要研究方向</h3><p><img src="/2021/02/06/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9801-%E7%AE%80%E4%BB%8B%EF%BC%88%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%EF%BC%89/%E4%B8%BB%E8%A6%81%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91.png"></p>
<p>搜索引擎和推荐系统，都是无处不在的应用。工作中这两个方向涉及的知识点很广，很锻炼人。</p>
<p>智能客服和个人助理是未来可能出独角兽公司的方向。</p>
<p>知识图谱是有学识的AI 。 是一个很综合的学科。很有发展和研究的前景。可以重点关注。</p>
<h2 id="文本分类简介"><a href="#文本分类简介" class="headerlink" title="文本分类简介"></a>文本分类简介</h2><h3 id="文本分类概述"><a href="#文本分类概述" class="headerlink" title="文本分类概述"></a>文本分类概述</h3><ul>
<li><p>在NLP的很多子任务中,有绝大部分场景可以归结为文本分类任务,比如:</p>
<ul>
<li><p>情感分析(粗细粒度情感分析)</p>
</li>
<li><p>领域识别(Domain Detection)</p>
</li>
<li><p>意图识别(Intent Detection) 句子的意图。</p>
</li>
<li><p>文本摘要 判断句子是不是文本的摘要。</p>
</li>
</ul>
</li>
</ul>
<p>自然语言处理中 75% 的问题都是文本分类的问题，其他的问题 比如 聚类（干，我可以说就是聚类）</p>
<ul>
<li>文本分类定义<ul>
<li>在给定的分类体系中,将文本分到指定的某个或某几个类别当中<ul>
<li>分类对象:短文本(句子/标题/商品评论)【特征是文本量少，表示语义信息比较难】、长文本(文章)【内容多但噪音也多，也是难题】</li>
</ul>
</li>
<li>分类体系一般由<strong>人工</strong>构造指定<ul>
<li>新闻分类:政治、体育、军事、社会</li>
<li>情感分类:正能量、负能量</li>
<li>微博评论分类:好评、中性、差评</li>
</ul>
</li>
<li>分类模式<ul>
<li>binary: 2类问题, 属于或不属于,  positive, negative 【这里是我的主要研究点。】</li>
<li>multi-class:多分类问题 【本实战课，主要讲的就是这里，新闻的多分类问题】</li>
<li>multi-label:多标签问题, 一个文本可以属于多类, 多标签分类是文本分类的一大难点</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>要人工去构造分类的数据集！只有人工去构造好之后，把先验知识给他，模型 才能学的更好。</p>
<p><strong>有人会说，没有数据集合怎么办？我需要人工标注很麻烦的</strong>！</p>
<p>​    目前深度学习领域内，特别是NLP领域，大多数是监督学习啊。 必须要有训练数据。没有训练数据的话，模型是没法训练的，如果训练不出模型，模型是不能用的。</p>
<p>​    如果没有数据，是要自己构造！！！数据质量的好坏，直接决定着最终模型的效果！</p>
<p>（考虑一下自己来构造数据集，要先明白如何构建，构建的体量如何）</p>
</blockquote>
<h3 id="文本分类方法分类"><a href="#文本分类方法分类" class="headerlink" title="文本分类方法分类"></a>文本分类方法分类</h3><ul>
<li><p><input checked disabled type="checkbox">  人工方法</p>
</li>
<li><p><input checked disabled type="checkbox">  机器学习方法</p>
<ul>
<li>特征工程+算法 （朴素贝叶斯，SVM。。。）</li>
</ul>
</li>
<li><p><input checked disabled type="checkbox">  深度学习方法</p>
<ul>
<li>词向量+模型 （Bert+模型）<ul>
<li>FastText</li>
<li><em>TextCNN</em></li>
<li><em>TextRNN</em></li>
<li><em>TextRCNN</em></li>
<li><em>DPCNN</em></li>
<li>BERT</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文本分类流程"><a href="#文本分类流程" class="headerlink" title="文本分类流程"></a>文本分类流程</h2><p><img src="/2021/02/06/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9801-%E7%AE%80%E4%BB%8B%EF%BC%88%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%EF%BC%89/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E6%B5%81%E7%A8%8B.png" alt="文本分类流程"></p>
<p>文本预处理是普通同学未来进入工作最可能做的工作。</p>
<p>文本去噪（利用正则等。。。）</p>
<p>文本分词（结巴分词，，词典，，）</p>
<p>去停用词（某词出现次数特别多  的，了 ）</p>
<p>文本还原 （ 把同义词做合并）</p>
<p>深度学习一般很少特征提取，传统机器学习用的多。</p>
<p>Bert是一个文本表示的东西， 出来之后就是一堆向量。</p>
<h2 id="【重要】神经网络中的数据格式"><a href="#【重要】神经网络中的数据格式" class="headerlink" title="【重要】神经网络中的数据格式"></a>【重要】神经网络中的数据格式</h2><blockquote>
<p>神经网络中只能识别数字型数据， int float 。<br>任何原始数据都要变成数字形式，针对不同的原始数据，神经网络中的数据格式是不一样的。</p>
</blockquote>
<ul>
<li><p>现实生活中遇到的数据:</p>
<ul>
<li>结构化数据 (数据表,例如班级名单,股票价格等等)</li>
<li>非结构化数据(序列(文本) 、图片、视频)</li>
</ul>
</li>
<li><p>神经网络中可以使用的数据:</p>
<ul>
<li>数据表-2D数据    形状=(样本数,特征数)  </li>
<li>序列类-3D数据    <strong>形状=(样本数,步长,特征数)</strong>   文本</li>
<li>图像类-4D数据    形状=(样本数,宽,高,通道数)  通道表示色彩。</li>
<li>视频类-5D数据    形状-(样本数,帧数,宽,高,通道数)   每个帧 就是图片。</li>
</ul>
</li>
</ul>
<ol>
<li><p>数据表：2D数据，一般称为2D张量。其实就是矩阵，一般可存储为CSV或者excel。</p>
<ol>
<li>样本数即行数，特征数即列数。</li>
</ol>
</li>
<li><p>序列类：3D数据，一般称为3D张量。通常用来表示文本。</p>
<ol>
<li>每一个推文最长280个字符，所以可以设置序列数为280，不足的用空格填充。</li>
<li>根据ASCII表将字符用数字代替。 ASCII 共有128种。 <strong>即每条序列都有128个特征。</strong></li>
<li>用one-hot编码（独热编码）    将一条推文变成 280x128的矩阵。 每一个列向量代表一个字母。  </li>
</ol>
<p>假设有1000条推文，那么整个数据集的形状为 （1000，280，128） （ 样本数，<strong>序列数</strong>，特征数）  </p>
</li>
<li><p>图像类：4D数据，一般称为4D张量，通常用来表示图像。</p>
<ol>
<li>一张RGB的图片，三原色，所以有三个通道。</li>
<li>128张图片，3个通道，每个通道（每种颜色）宽256，高256 。    表示为： （128，256，256，3）  </li>
</ol>
</li>
<li><p>视频类数据：5D数据，一般称为5D张量。</p>
<ol>
<li>视频分为一幅幅帧（frame）</li>
<li>存储在3D张量中，  （样本数，帧数，宽，高，通道数  ）</li>
</ol>
</li>
</ol>
<p>处理原始材料，一定要知道数据的结构是什么样的。输入模型时候的维度是需要重点考虑的。</p>
<h2 id="文本分类模型"><a href="#文本分类模型" class="headerlink" title="文本分类模型"></a>文本分类模型</h2><ol>
<li>理论部分（认识Bert）<ol>
<li>RNN模型</li>
<li>Seq2Seq模型</li>
<li>Attention + Seq2Seq</li>
<li>Transformer模型</li>
<li>Bert模型</li>
</ol>
</li>
<li>实战部分（学会现场改BUG！！）<ol>
<li>基于Bert+（RNN,CNN,DPCNN,RCNN)的文本分类实战。</li>
<li>基于ERNIE的文本分类实战。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>NLP</category>
        <category>Bert</category>
      </categories>
      <tags>
        <tag>科研</tag>
        <tag>NLP</tag>
        <tag>Bert</tag>
      </tags>
  </entry>
  <entry>
    <title>【NLP】Bert中文文本分类实战02-RNN的变体-Seq2Seq理论</title>
    <url>/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="技术发展历程"><a href="#技术发展历程" class="headerlink" title="技术发展历程"></a>技术发展历程</h1><p>从Seq2Seq诞生到目前的 基于序列模型的NLP发展</p>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0Bert%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB_19.png" alt="动手学习Bert文本分类_19"></p>
<ul>
<li><p>2014 正式提出Seq2Seq，同一年 顶会上有两篇文章都用到了  序列到序列， 编码器-解码器模型，用来解决机器翻译的问题。</p>
<p>RNN和LSTM出现的都比较早，但是<strong>GRU</strong> 2014年才出现。</p>
</li>
<li><p>2015年 针对Seq2Seq的缺点，Attention 注意力机制出现。</p>
</li>
<li><p>2017年Attention真正爆发，有一部分人用Cnn取代RNN，Attention。</p>
<p>谷歌的论文<code>Attention is all your need</code>  将Attention推向顶峰。用Self-Attention取代了Cnn，Rnn。 各式各样的Attention出现。</p>
<p>Transformer是基于Self-Attention的，是多头的注意力，</p>
<p>Bert是基于Transformer的encoder 编码部分</p>
</li>
</ul>
<p>Attention 是关键的知识点。</p>
<h1 id="RNN相关理论及变体讲解"><a href="#RNN相关理论及变体讲解" class="headerlink" title="RNN相关理论及变体讲解"></a>RNN相关理论及变体讲解</h1><h2 id="单层神经网络"><a href="#单层神经网络" class="headerlink" title="单层神经网络"></a>单层神经网络</h2><p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0Bert%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB_20.png" alt="动手学习Bert文本分类_20"></p>
<p>线性模型</p>
<h2 id="经典的RNN网络"><a href="#经典的RNN网络" class="headerlink" title="经典的RNN网络"></a>经典的RNN网络</h2><p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0Bert%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB_22.png" alt="动手学习Bert文本分类_22"></p>
<p>左边是简单的画法，右边是循环神经网络的展开</p>
<p>每一层的输入依赖于上一层 隐藏层的状态 和 当前层的输入。</p>
<h2 id="RNN的变体（NV1：多个输入一个输出）"><a href="#RNN的变体（NV1：多个输入一个输出）" class="headerlink" title="RNN的变体（NV1：多个输入一个输出）"></a>RNN的变体（NV1：多个输入一个输出）</h2><p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0Bert%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB_23.png" alt="动手学习Bert文本分类_23"></p>
<p>每一层依赖于上一层的状态和这一层的新的输入。</p>
<p>最后一层h5输出之后，过一个Softmax 可以输出分类。</p>
<p>多个输入，一个输出 （文本分类的任务。）</p>
<h2 id="RNN的变体（1VN：一个输入多个输出-）"><a href="#RNN的变体（1VN：一个输入多个输出-）" class="headerlink" title="RNN的变体（1VN：一个输入多个输出 ）"></a>RNN的变体（1VN：一个输入多个输出 ）</h2><p><strong>&lt;14年的两篇顶会文章就是分别做了这两个变体&gt;</strong> </p>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0Bert%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB_24.png" alt="动手学习Bert文本分类_24"></p>
<p>一个输入，多个输出。 </p>
<p>典型应用：看图说话，图像描述。</p>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0Bert%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB_25.png" alt="动手学习Bert文本分类_25">将x 每一个时刻都输入。（输入的都是一个x)</p>
<h2 id="RNN变体-（NVN）多输入多输出"><a href="#RNN变体-（NVN）多输入多输出" class="headerlink" title="RNN变体 （NVN）多输入多输出"></a>RNN变体 （NVN）多输入多输出</h2><p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0Bert%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB_26.png" alt="动手学习Bert文本分类_26"></p>
<p>对联生成，输入上联，得出下联。  做机器翻译，但是只能做对齐的机器翻译。</p>
<h2 id="RNN变体（NVM-N个输入，M个输出"><a href="#RNN变体（NVM-N个输入，M个输出" class="headerlink" title="RNN变体（NVM)  N个输入，M个输出"></a>RNN变体（NVM)  N个输入，M个输出</h2><p><strong>RNN变体（NVM)</strong>   =  <strong>Seq2Seq</strong>  =  <strong>Encoder-Decoder 模型  =  编码器解码器模型</strong></p>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0Bert%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB_27.png" alt="动手学习Bert文本分类_27"></p>
<p>Seq2Seq是两个RNN网络 ， Encoder部分处理输入，形成语义编码c输入Decoder处理输出。</p>
<p>语义编码c 有两种不同输入</p>
<p><strong>1：直接输入隐藏层中，做为h0</strong>  ；   2：<strong>接入到每一个输入</strong></p>
<p>有两种不同的方式，产生了两篇不同的论文。（便是RNN变体 1VN）</p>
<h1 id="Seq2Seq模型"><a href="#Seq2Seq模型" class="headerlink" title="Seq2Seq模型"></a>Seq2Seq模型</h1><p>Seq2Seq模型 又叫 Encoder-Decoder 模型，简单分为三部分 ：</p>
<p>​    Encoder，Decoder，State Vector C（中间件状态向量c）</p>
<p>只看Decoder部分，相当与RNN的1VN的两种变体。</p>
<h2 id="Encoder部分（以机器翻译为例子）"><a href="#Encoder部分（以机器翻译为例子）" class="headerlink" title="Encoder部分（以机器翻译为例子）"></a>Encoder部分（以机器翻译为例子）</h2><p>上文两篇论文是机器翻译的，Seq2Seq可以完成很多任务，序列生成。</p>
<p>因为Seq2Seq是NVM，n个输入，m个输出。</p>
<p>给定句子对<code>&lt;x,y&gt;</code> ，给定输入x，通过Encoder-Decoder模型来翻译成为目标句子y。</p>
<p>x和y分别由各自的单词序列构成  <code>X=&lt;x1,x2,x3,x4,x5&gt;</code>  , <code>Y=&lt;y1,y2,y3&gt;</code></p>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0Bert%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB_30.png" alt="动手学习Bert文本分类_30"></p>
<p>C 得到的方式如上图方框。Encoder输出时，把所有的输入信息都压缩到向量C中了。是Encoder部分的精华。</p>
<h2 id="Decoder部分（以机器翻译为例子）"><a href="#Decoder部分（以机器翻译为例子）" class="headerlink" title="Decoder部分（以机器翻译为例子）"></a>Decoder部分（以机器翻译为例子）</h2><ol>
<li>变体一<img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/1607400108(1).png" alt="1607400108(1)"></li>
</ol>
<p>y0可能是<code>end of sentence</code> ,<code>&lt;START&gt;</code> 是我自己可以随意定义， 就是一个触发词，告诉模型我要开始解码了。如：”小爱同学”   </p>
<p> 因为是一个RNN，将h1输出的y1作为h2的输入。 </p>
<ol start="2">
<li>变体二</li>
</ol>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/1607407008(1).png" alt="1607407008(1)"></p>
<p>c 和 y0 ，c和y1 .。。。 同时作为每一时刻的输入。</p>
<h1 id="从论文里理解Seq2Seq"><a href="#从论文里理解Seq2Seq" class="headerlink" title="从论文里理解Seq2Seq"></a>从论文里理解Seq2Seq</h1><h2 id="论文框架1"><a href="#论文框架1" class="headerlink" title="论文框架1"></a>论文框架1</h2><p>该框架由这篇论文提出: Cho et al.(2014) Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation （做统计机器翻译的）</p>
<p>该论文一大贡献是提出了GRU，论文中 Encoder和Decoder都是GRU，为了学习，可以假设Encoder和Decoder 都是RNN。</p>
<p>注意 红色c是语义变量，黑色c是偏置。</p>
<h3 id="Encoder部分"><a href="#Encoder部分" class="headerlink" title="Encoder部分"></a>Encoder部分</h3><p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/1607407812(1).png" alt="1607407812(1)"></p>
<p>关注 隐藏层状态h， 语义向量直接拿最后的隐藏层加了个tanh函数，相当于 <code>c=q（h）</code> </p>
<p>这个Encoder部分就是简单的RNN的隐藏层+tanh，得到与语义变量c</p>
<h3 id="Decoder部分"><a href="#Decoder部分" class="headerlink" title="Decoder部分"></a>Decoder部分</h3><p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/1607408473(1).png" alt="1607408473(1)"></p>
<p>Decoder部分的隐藏层状态依赖于 （上一层隐藏层状态，上一层隐藏层的输出，语义变量C) (h[t-1], y[t-1] , c)</p>
<p>Ot就是每一个时刻的输出， yt 即 Ot</p>
<h2 id="论文框架2"><a href="#论文框架2" class="headerlink" title="论文框架2"></a>论文框架2</h2><p>该框架由这篇论文提出: Sutskever et al.(2014) Sequence to Sequence Learning with NeuralNetworks,这个框架也是最常用的一种：结构图如下：</p>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/1607410089(1).png" alt="1607410089(1)"></p>
<p>Encoder 输入序列A B C,生成语义向量 c 作为Decoder的初始隐藏状态, Decoder中初始时刻输入<code>&lt;EOS&gt;</code>作为开始标志,直至输出<code>&lt;EOS&gt;</code>结束预测。</p>
<p>和框架1不同的是,该框架Encoder输出的语义向量c 直接<strong>作为Decoder的初始隐藏状态</strong>,并不作用于之后的时刻。</p>
<p>这篇论文中使用LSTM作为Encoder和Decoder,为方便描述这里用RNN作为示范。</p>
<h3 id="Encoder部分-1"><a href="#Encoder部分-1" class="headerlink" title="Encoder部分"></a>Encoder部分</h3><p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/1607410160(1).png" alt="1607410160(1)"></p>
<h3 id="Decoder部分-1"><a href="#Decoder部分-1" class="headerlink" title="Decoder部分"></a>Decoder部分</h3><p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/1607410477(1).png" alt="1607410477(1)"></p>
<p>ht 依赖于 （上一时刻的状态 ，上一时刻的输出）<br>h0 = 语义变量C </p>
<p>论创新点来说，论文1可以包含论文2了。 论文2是论文1的一种情况。</p>
<h1 id="Encoder-Decoder模型的局限性"><a href="#Encoder-Decoder模型的局限性" class="headerlink" title="Encoder-Decoder模型的局限性"></a>Encoder-Decoder模型的局限性</h1><ul>
<li><p><input disabled type="checkbox">  从下图中可以看出 Encoder 和 Decoder 的唯一联系只有语义编码<strong>c</strong>, 即将整个输入序列的信息编码成一个<strong>固定大小</strong>的状态向量再解码,相当于将信息”有损压缩” 。</p>
</li>
<li><p><input disabled type="checkbox">  很明显这样做有两个缺点:</p>
<ul>
<li>中间语义向量无法完全表达整个输入序列的信息。</li>
<li>随着输入信息长度的增加,由于向量c长度固定,先前编码好的信息会被后来的信息<strong>覆盖</strong>,导致<strong>丢失</strong>很多信息。</li>
</ul>
</li>
</ul>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/1607410986(1).png" alt="1607410986(1)"></p>
<ul>
<li><input disabled type="checkbox"> 从下图中可以明显可以发现在生成y1,y2,y3时,<strong>语义编码C</strong>对它们所产生的贡献都是一样的。<ul>
<li>例如翻译: Cat chase mouse ,模型逐字生成: “猫””捉””老鼠”。在翻译mouse单词时,每一个英语单词对“老鼠”的贡献都是相同的。但mouse对于它的影响应该是最大的。引入Attention模型可解决这个问题。</li>
</ul>
</li>
</ul>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/1607411218(1).png" alt="1607411218(1)"></p>
<h2 id="引入Attention"><a href="#引入Attention" class="headerlink" title="引入Attention"></a>引入Attention</h2><p>Attention 其实就是根据语义编码C做了一些复杂的运算。把 C 在不同时刻搞得不一样了。</p>
<p>Attention模型的特点:</p>
<ul>
<li>是Decoder不再将整个输入序列编码为<strong>固定长度</strong>的中间语义向量C, 而是根据<strong>当前生成</strong>的<strong>新单词</strong>计算新的C(i),使得每个时刻输入不同的C;</li>
<li>这样就解决了单词信息丢失的问题。引入了Attentien的Encoder-Decoder模型如下图:</li>
</ul>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9802-RNN-Seq2Seq%E7%90%86%E8%AE%BA/1607411642(1).png" alt="1607411642(1)"></p>
<p>Decoder部分解码的时候，每一个时刻 c是不同的。根据前面输入不同，后面C不同。C的计算方法有很多，具体方法见下一篇Blog。</p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>Bert</category>
      </categories>
      <tags>
        <tag>科研</tag>
        <tag>NLP</tag>
        <tag>Bert</tag>
      </tags>
  </entry>
  <entry>
    <title>【NLP】Bert中文文本分类实战03-Attention机制</title>
    <url>/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9803-Attention%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Seq2Seq模型的一个实例"><a href="#Seq2Seq模型的一个实例" class="headerlink" title="Seq2Seq模型的一个实例"></a>Seq2Seq模型的一个实例</h1><p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9803-Attention%E6%9C%BA%E5%88%B6/1607415126(1).png" alt="1607415126(1)"></p>
<p>h0 是初始化， z0 都是可以学习的。  <code>&lt;bos&gt;</code>唤醒词。</p>
<h1 id="Attention机制（图形化讲解）"><a href="#Attention机制（图形化讲解）" class="headerlink" title="Attention机制（图形化讲解）"></a>Attention机制（图形化讲解）</h1><p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9803-Attention%E6%9C%BA%E5%88%B6/1607415308(1).png" alt="1607415308(1)"></p>
<p>将h1，h2 变为c1.</p>
<p>具体来说： </p>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9803-Attention%E6%9C%BA%E5%88%B6/1607415627(1).png" alt="1607415627(1)"></p>
<p>Z0 和 h1 做 match （就是一个计算，可以用点乘，普通乘，甚至放进一个简单的神经网络进行训练。）生成a01</p>
<p>match 是自己设计的：</p>
<ul>
<li> 可以做Cos值， </li>
<li>可以做一个很小的神经网络，输入z和h，输出a</li>
<li>可以做一个转置。W是可以学习的。</li>
</ul>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9803-Attention%E6%9C%BA%E5%88%B6/1607415726(1).png" alt="1607415726(1)"></p>
<p>这个小的match network是无感的 ，整个还是Encoder-Decoder，没有单独的另外一个结构。</p>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9803-Attention%E6%9C%BA%E5%88%B6/1607416192(1).png" alt="1607416192(1)"></p>
<p>α01 是 Z0和h1 做出来的， 将z0同所有的h 得到αt，softmax之后，得到c0</p>
<p>权重更大了。所以C0就可能跟机器这两个字关系密切，得到正确的翻译结果概率更大。</p>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9803-Attention%E6%9C%BA%E5%88%B6/1607416360(1).png" alt="1607416360(1)"></p>
<p>得到Z1之后，重复操作，又得到C1。然后输入Z2 输出翻译结果。</p>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9803-Attention%E6%9C%BA%E5%88%B6/1607416831(1).png" alt="1607416831(1)"></p>
<p>这个过程将一直持续下去，直到遇到EOS （End Of Sentence）</p>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9803-Attention%E6%9C%BA%E5%88%B6/1607416877(1).png" alt="1607416877(1)"></p>
<p>总结： Decoder的隐藏层状态，和Encoder的隐藏层状态去做Attention 得到结果α，最终再<code>softmax</code> 得到权重的分布。</p>
<h1 id="Attention-公式形式讲解"><a href="#Attention-公式形式讲解" class="headerlink" title="Attention 公式形式讲解"></a>Attention 公式形式讲解</h1><p>上面提到的两个Attention 在框架中都有封装。</p>
<h2 id="第一种Attention结构"><a href="#第一种Attention结构" class="headerlink" title="第一种Attention结构"></a>第一种Attention结构</h2><h3 id="Encoder部分（都是类似的。）"><a href="#Encoder部分（都是类似的。）" class="headerlink" title="Encoder部分（都是类似的。）"></a>Encoder部分（都是类似的。）</h3><p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9803-Attention%E6%9C%BA%E5%88%B6/1607512678(1).png" alt="1607512678(1)"></p>
<p>当前层的隐藏层状态依赖于上一层隐藏层状态和当前的输入。都是典型的RNN</p>
<h3 id="Decoder部分"><a href="#Decoder部分" class="headerlink" title="Decoder部分"></a>Decoder部分</h3><p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9803-Attention%E6%9C%BA%E5%88%B6/1607584875(1).png" alt="1607584875(1)"></p>
<p>第一部分，从下往上看，et认为是  解码器隐藏层状态s和编码器隐藏层状态h设计的一个函数，W和V都是可以学习到的。 et就相当于前面的 α冒。</p>
<p>第二部，将ct传入，形成st （当前时刻的隐藏层状态）</p>
<p>（ st-1 上一时刻的隐藏层状态，yt-1 上一个时刻的生成（输出） ct（当前时刻的语义编码c））</p>
<h2 id="第二种Attention结构，Luong-Attention"><a href="#第二种Attention结构，Luong-Attention" class="headerlink" title="第二种Attention结构，Luong Attention"></a>第二种Attention结构，Luong Attention</h2><p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9803-Attention%E6%9C%BA%E5%88%B6/1607585308(1).png" alt="1607585308(1)"></p>
<p>这里的S 就相当于 图解里面的 Z。W是权重</p>
<p>这个和第一个Attention不同的地方就是，这里先计算出隐藏层的状态St，再计算注意力层的隐藏层状态，最后送入Softmax</p>
<p>（论文的创新点要很独特，一定要从数学上面去玩，千万不能做太Low的， 领域迁移比较low，要有自己的改变。从公式角度来改变一下。）</p>
<p>Attention方面来发期刊和论文已经不行了。</p>
<p>一定要确定实验数据要好，不能被别人搞！</p>
<blockquote>
<p>看论文看多了之后，不要对数学公式有抗拒心理，而且数学公式一定要对，要经得过推敲才行。</p>
<p>数学公式是基本功，多看即可。没必要去特意看数学的东西，如果看不懂的话，再去补，再查。</p>
<p>每个领域能用到的数学的东西就一点点，搞明白了就行了。</p>
</blockquote>
<h1 id="序列网络的问题（引子）"><a href="#序列网络的问题（引子）" class="headerlink" title="序列网络的问题（引子）"></a>序列网络的问题（引子）</h1><p>工作中，要用RNN 要不是用GRU，要不就是用LSTM。 可以统一称为序列网络。</p>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9803-Attention%E6%9C%BA%E5%88%B6/1607587136(1).png" alt="1607587136(1)"></p>
<p>问题： 是依赖于上一时刻的输入的。 是一个环环相扣的状态。依赖于之前的序列。所以就很难并行化。用GPU加速最好是可以并行化，这样就会更快。所以同一个任务 序列网络RNN可能就没有CNN快。</p>
<p>下一个能看到前面的所有的信息。这也是序列网络的一个优势。</p>
<p>为了并行化，尝试CNN ，因为CNN的每个滤波器可以独自工作，不会有影响。但是很难看到全部的信息，想看到全部信息，就要叠加很多层，这样网络的结构又会很复杂，非常不现实。</p>
<p><img src="/2021/02/08/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9803-Attention%E6%9C%BA%E5%88%B6/1607588060(1).png" alt="1607588060(1)"></p>
<p>为了能并行化且能看到所有的信息，就引出了Self-Attention。</p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>Bert</category>
      </categories>
      <tags>
        <tag>科研</tag>
        <tag>NLP</tag>
        <tag>Bert</tag>
      </tags>
  </entry>
  <entry>
    <title>【NLP】Bert中文文本分类实战04-Self-Attention</title>
    <url>/2021/02/10/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/NLP/Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/%E3%80%90NLP%E3%80%91Bert%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%9804-Self-Attention/</url>
    <content><![CDATA[<h1 id="Self-Attention理论"><a href="#Self-Attention理论" class="headerlink" title="Self-Attention理论"></a>Self-Attention理论</h1><p>![1607602609(1)](D:\Data\My Blog\blog\source_posts\NLP\Bert中文文本分类实战\【NLP】Bert中文文本分类实战04-Self-Attention\1607602609(1).png)</p>
<p>可以将Self-Attention看做一个黑盒子，不用管里面的东西。 b1可以看到所有的a，b2也是，并且b们可以并行进行计算。</p>
<p>Self-Attention是来自于谷歌论文“Attention is all your need”</p>
<p>每一个q和每一个k做Attention</p>
<p>Attention 就是指 一个变化，生成新的信息。</p>
<h1 id="Self-Attentin数学理论"><a href="#Self-Attentin数学理论" class="headerlink" title="Self-Attentin数学理论"></a>Self-Attentin数学理论</h1><h1 id="Multi-head-self-Attention理论"><a href="#Multi-head-self-Attention理论" class="headerlink" title="Multi-head-self-Attention理论"></a>Multi-head-self-Attention理论</h1>]]></content>
      <categories>
        <category>NLP</category>
        <category>Bert</category>
      </categories>
      <tags>
        <tag>科研</tag>
        <tag>NLP</tag>
        <tag>Bert</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程基础</title>
    <url>/2020/11/22/1-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Java多线程基础篇"><a href="#Java多线程基础篇" class="headerlink" title="Java多线程基础篇"></a>Java多线程基础篇</h1><h2 id="多线程中的一些名词概念"><a href="#多线程中的一些名词概念" class="headerlink" title="多线程中的一些名词概念"></a>多线程中的一些名词概念</h2><h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h4><p>1）进程：</p>
<ul>
<li>进程就是程序在并发环境中的执行过程，也就是一个正在运行的程序。所谓正在运行的程序，就少不了三个东西，一个是cpu，一个是程序本身（代码什么的），还有一个运行环境。比如说：一个人正在做饭（进程），首先要有一个人（CPU），还要有一个菜谱（代码），最后要有一个厨房（运行环境）。</li>
<li>进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。</li>
</ul>
<p>2）线程：</p>
<ul>
<li>所谓线程，就是程序的一个个子模块。比如说：一个人正在做饭（进程），他要洗菜（线程），他也要切菜（线程），他还要和面（也是线程），把做饭这个事情，分成一个个小的模块，再有这个人（CPU）去一一处理。</li>
<li>线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。</li>
</ul>
<p>3）进程与线程的区别</p>
<ul>
<li>进程是资源分配的最小单位，线程是程序执行的最小单位。一个程序要运行，给你cpu让你运行，但是要具体怎么运行，就看程序是如何分配的了。</li>
<li>线程之间的通信更方便，<strong>同一进程下的线程共享全局变量、静态变量等数据</strong>，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。这也就是后面为什么要用锁的原因了。</li>
<li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li>
<li>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</li>
</ul>
<h4 id="同步与异步的区别"><a href="#同步与异步的区别" class="headerlink" title="同步与异步的区别"></a>同步与异步的区别</h4><blockquote>
<p>多线程并发时，多个线程同时请求同一个资源，必然导致此资源的数据不安全，A线程修改了B线程的处理的数据，而B线程又修改了A线程处理的数理。显然这是由于全局源造成的，有时为了解决此问题，优先考虑使用局部变量，退而求其次使用同步代码块，出于这样的安全考虑就必须牺牲系统处理性能，加在多线程并发时资源挣夺最激烈的地方，这就实现了线程的同步机制</p>
</blockquote>
<ul>
<li>同步：A线程要请求某个资源，但是此资源正在被B线程使用中，因为同步机制存在，A线程请求不到，怎么办，A线程只能等待下去</li>
<li>异步：A线程要请求某个资源，但是此资源正在被B线程使用中，因为没有同步机制存在，A线程仍然请求的到，A线程无需等待</li>
</ul>
<p>显然，同步最最安全，最保险的。而异步不安全，容易导致死锁，这样一个线程死掉就会导致整个进程崩溃，但没有同步机制的存在，性能会有所提升</p>
<h4 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h4><ul>
<li>并发：就是让一个处理器处理多个任务，但这些任务不一定要同时进行。比如说：一个人吃三个馒头，他可以一个一个的吃，并不一定要一口吃完。</li>
<li>并行：同时发生的两个并发事件，也就是多个处理器同时处理多个任务。比如说：三个人同时吃三个馒头。</li>
</ul>
<h4 id="什么是锁、什么是死锁"><a href="#什么是锁、什么是死锁" class="headerlink" title="什么是锁、什么是死锁"></a>什么是锁、什么是死锁</h4><ul>
<li>锁：可以理解为普通意义上的一把锁，不过他是用来锁资源的。比如给一段资源（方法、代码块）加上一把锁，则这段资源同一时间，只能有一个线程对他访问，只有等这个线程访问完了，其他的线程才能访问。这不就是同步机制吗？？？没错，锁存在的意义，就是让他产生同步机制的。</li>
<li>死锁：是指同一个进程集合中的每个进程都在等待仅有该集合中的另一个进程才能引发的事件而无限期地僵持下去的局面，也就是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。比如说：在一条单车道的路上，双向各来一辆车，这两个车都在等对方给自己让路，就会形成一种僵局，也就是死锁。</li>
</ul>
<h2 id="线程中的五种基本状态"><a href="#线程中的五种基本状态" class="headerlink" title="线程中的五种基本状态"></a>线程中的五种基本状态</h2><p><img src="/2020/11/22/1-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="在这里插入图片描述"></p>
<h4 id="新建状态（New）"><a href="#新建状态（New）" class="headerlink" title="新建状态（New）"></a>新建状态（New）</h4><p>当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</p>
<h4 id="就绪状态（Runnable）"><a href="#就绪状态（Runnable）" class="headerlink" title="就绪状态（Runnable）"></a>就绪状态（Runnable）</h4><p>当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p>
<h4 id="运行状态（Running）"><a href="#运行状态（Running）" class="headerlink" title="运行状态（Running）"></a>运行状态（Running）</h4><p>当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>
<h4 id="阻塞状态（Blocked）"><a href="#阻塞状态（Blocked）" class="headerlink" title="阻塞状态（Blocked）"></a>阻塞状态（Blocked）</h4><p>处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p>
<ul>
<li>1）等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</li>
<li>2）同步阻塞： 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</li>
<li>3）其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ul>
<h4 id="死亡状态（Dead）"><a href="#死亡状态（Dead）" class="headerlink" title="死亡状态（Dead）"></a>死亡状态（Dead）</h4><p>线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>
<h2 id="线程的创建于启动"><a href="#线程的创建于启动" class="headerlink" title="线程的创建于启动"></a>线程的创建于启动</h2><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><p>1）重写该类的run()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">30</span>) &#123;</span><br><span class="line">                Thread myThread1 = <span class="keyword">new</span> MyThread();     <span class="comment">// 创建一个新的线程  myThread1  此线程进入新建状态</span></span><br><span class="line">                Thread myThread2 = <span class="keyword">new</span> MyThread();     <span class="comment">// 创建一个新的线程 myThread2 此线程进入新建状态</span></span><br><span class="line">                myThread1.start();                     <span class="comment">// 调用start()方法使得线程进入就绪状态</span></span><br><span class="line">                myThread2.start();                     <span class="comment">// 调用start()方法使得线程进入就绪状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>继承Thread类，通过重写run()方法定义了一个新的线程类MyThread，其中run()方法的方法体代表了线程需要完成的任务，称之为线程执行体。当创建此线程类对象时一个新的线程得以创建，并进入到线程新建状态。通过调用线程对象引用的start()方法，使得该线程进入到就绪状态，此时此线程并不一定会马上得以执行，这取决于CPU调度时机。</li>
</ul>
<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><p>-1）实现Runnable接口，并重写该接口的run()方法，该run()方法同样是线程执行体，创建Runnable实现类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread对象才是真正的线程对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">30</span>) &#123;</span><br><span class="line">                Runnable myRunnable = <span class="keyword">new</span> MyRunnable(); <span class="comment">// 创建一个Runnable实现类的对象</span></span><br><span class="line">                Thread thread1 = <span class="keyword">new</span> Thread(myRunnable); <span class="comment">// 将myRunnable作为Thread target创建新的线程</span></span><br><span class="line">                Thread thread2 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">                thread1.start(); <span class="comment">// 调用start()方法使得线程进入就绪状态</span></span><br><span class="line">                thread2.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）或者说，直接通过lamda表达式也是可以的实现的，因为Runnable接口只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Runnable mt = () -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;    &quot;</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）Thread和Runnable之间到底是什么关系？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;in MyRunnable run&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Runnable runnable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;in MyThread run&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">30</span>) &#123;</span><br><span class="line">                Runnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">                <span class="comment">//这里没有用Thread类，二是继承了Thread的MyThread类</span></span><br><span class="line">                Thread thread = <span class="keyword">new</span> MyThread(myRunnable);</span><br><span class="line">                thread.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先，可以肯定的是，这种方式是没有问题的。</p>
</li>
<li><p>至于此时的线程执行体到底是MyRunnable接口中的run()方法还是MyThread类中的run()方法呢？通过输出我们知道线程执行体是MyThread类中的run()方法。</p>
</li>
<li><p>为什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Runnable源码是这样写的</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//Thread源码中是这样写的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Runnable target;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们使用<code>Thread thread = new Thread (myRunnable);</code>则由源码可知：当启动这个线程，经过初始化，在运行<code>run（）</code>方法的时候，会先判断 <code>target</code> 是否为空，这里是不为空的，因为Thread是继承Runnable的，这里也对其初始化过。</p>
<p>如果使用<code>Thread thread = new MyThread(myRunnable);</code>，因为没有<code>target</code> 这个变量，重写的run()也没有对他判null，又由多态可知，这里没有机会执行Thread中的run()方法，所以输出的是：MyThread类中的run()方法。</p>
</li>
</ul>
<h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><p>1）具体是创建Callable接口的实现类，并实现clall()方法。并使用FutureTask类来包装Callable实现类的对象，且以此FutureTask对象作为Thread对象的target来创建线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Callable&lt;Integer&gt; myCallable = <span class="keyword">new</span> MyCallable();    <span class="comment">// 创建MyCallable对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(myCallable); <span class="comment">//使用FutureTask来包装MyCallable对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">30</span>) &#123;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(ft);   <span class="comment">//FutureTask对象作为Thread对象的target创建新的线程</span></span><br><span class="line">                thread.start();                      <span class="comment">//线程进入到就绪状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程for循环执行完毕..&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = ft.get();            <span class="comment">//取得新创建的新线程中的call()方法返回的结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;sum = &quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与run()方法不同的是，call()方法具有返回值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在实现Callable接口中，此时不再是run()方法了，而是call()方法，此call()方法作为线程执行体，同时还具有返回值！在创建新的线程时，是通过FutureTask来包装MyCallable对象，同时作为了Thread对象的target。那么看下FutureTask类的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>我们发现FutureTask类实际上是同时实现了Runnable和Future接口，由此才使得其具有Future和Runnable双重特性。通过Runnable特性，可以作为Thread对象的target，而Future特性，使得其可以取得新创建线程中的call()方法的返回值。</p>
<p>执行下此程序，我们发现sum =  4950永远都是最后输出的。而“主线程for循环执行完毕…”则很可能是在子线程循环中间输出。由CPU的线程调度机制，我们知道，“主线程for循环执行完毕…”的输出时机是没有任何问题的，那么为什么sum =4950会永远最后输出呢？</p>
<p>原因在于通过ft.get()方法获取子线程call()方法的返回值时，当子线程此方法还未执行完毕，ft.get()方法会一直阻塞，直到call()方法执行完毕才能取到返回值。</p>
<h2 id="多线程重要-API-以及其背后的意义"><a href="#多线程重要-API-以及其背后的意义" class="headerlink" title="多线程重要 API 以及其背后的意义"></a>多线程重要 API 以及其背后的意义</h2><h4 id="yield-——线程让步"><a href="#yield-——线程让步" class="headerlink" title="yield()——线程让步"></a>yield()——线程让步</h4><p>1）当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程还是与线程的优先级紧密相关，CPU从就绪状态线程队列中只会选择与该线程优先级相同或优先级更高的线程去执行。</p>
<p>2）<strong>这个方法会释放CPU资源，但是不会释放锁资源</strong>，只有他访问的带锁资源执行完之后，锁资源才会释放。（如果刚看不理解没关系，记住这是一个超级重要的知识点就行）</p>
<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>1）让一个线程等待另一个线程完成才继续执行。如A线程线程执行体中调用B线程的join()方法，则A线程被阻塞，直到B线程执行完为止，A才能得以继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Runnable r = () -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">30</span>) &#123;</span><br><span class="line">				thread1.start();</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">//在thread1线程启动后才能才能使用这个方法</span></span><br><span class="line">					thread1.join(); <span class="comment">// main线程需要等待thread线程执行完后才能继续执行</span></span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4><p>1）让当前的正在执行的线程暂停指定的时间，并进入阻塞状态。在其睡眠的时间段内，该线程由于不是处于就绪状态，因此不会得到执行的机会。即使此时系统中没有任何其他可执行的线程，出于sleep()中的线程也不会执行。因此sleep()方法常用来暂停线程执行。</p>
<p>2）当调用了新建的线程的start()方法后，线程进入到就绪状态，可能会在接下来的某个时间获取CPU时间片得以执行，如果希望这个新线程必然性的立即执行，直接调用原来线程的sleep(1)即可。</p>
<p>3）这是一个静态方法，在哪个线程的执行体里面调用它，就让那个线程暂停指定的时间。</p>
<p>4）<strong>在调用sleep()方法的过程中，线程不会释放对象锁。</strong> 但是会让出自己所占用的CPU资源，自身进入阻塞状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Runnable r = () -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">30</span>) &#123;</span><br><span class="line">				thread1.start();</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1</span>); <span class="comment">// 使得thread必然能够马上得以执行</span></span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>1）后台线程主要是为其他线程（相对可以称之为前台线程）提供服务，或“守护线程”。如JVM中的垃圾回收线程。</p>
<p>2）生命周期：后台线程的生命周期与前台线程生命周期有一定关联。主要体现在：当所有的前台线程都进入死亡状态时，后台线程会自动死亡(其实这个也很好理解，因为后台线程存在的目的在于为前台线程服务的，既然所有的前台线程都死亡了，那它自己还留着有什么用…伟大啊 ! !)。</p>
<p>3）设置后台线程：调用Thread对象的setDaemon(true)方法可以将指定的线程设置为后台线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Runnable r = () -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">30</span>) &#123;</span><br><span class="line">				thread1.start();</span><br><span class="line">				thread1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="setPriority-getPriority-——线程优先级"><a href="#setPriority-getPriority-——线程优先级" class="headerlink" title="setPriority() / getPriority()——线程优先级"></a>setPriority() / getPriority()——线程优先级</h4><p>1）每个线程在执行时都具有一定的优先级，优先级高的线程具有较多的执行机会。每个线程默认的优先级都与创建它的线程的优先级相同。main线程默认具有普通优先级。</p>
<ul>
<li>改变线程的优先级/setPriority()：</li>
<li>获取线程优先级：getPriority()。</li>
</ul>
<p>设置线程优先级：setPriority(int priorityLevel)。参数priorityLevel范围在1-10之间，常用的有如下三个静态常量值：</p>
<ul>
<li>MAX_PRIORITY:10</li>
<li>MIN_PRIORITY:1</li>
<li>NORM_PRIORITY:5</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Runnable r = () -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">		thread1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line"></span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">		thread2.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line"></span><br><span class="line">		Thread thread3 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">		thread3.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">30</span>) &#123;</span><br><span class="line">				thread1.start();</span><br><span class="line">				thread2.start();</span><br><span class="line">				thread3.start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="interrupt-——中断线程"><a href="#interrupt-——中断线程" class="headerlink" title="interrupt()——中断线程"></a>interrupt()——中断线程</h4><p>1）向线程发送中断请求。线程的中断状态将被设置为true。如果目前该线程被一个sleep调用阻塞，那么，InterruptedException异常将会抛出。</p>
<p>2）它基于一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止的思想（我命由我不由天）。是一个比较温柔的做法，它更类似一个标志位。其实作用不是中断线程，而是通知线程应该中断了，具体到底中断还是继续运行，应该由被通知的线程自己处理。</p>
<p>3）并不能真正的中断线程，这点要谨记。需要被调用的线程自己进行配合才行。也就是说，一个线程如果有被中断的需求，那么就需要这样做：</p>
<ul>
<li>在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。</li>
<li>在调用阻塞方法时正确处理InterruptedException异常。（例如：catch异常后就结束线程。）</li>
</ul>
<p>4）<code>static boolean interrupted()</code>：测试当前线程（正在执行这一命令的线程）是否被中断。这是一个静态方法，会产生一个副作用——**将当前线程的中断状态重置为<code>false</code>**。</p>
<p>5）<code>boolean isInterrupted()</code>测试线程是否被终止。这一个调用不会改变线程的中断状态。</p>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>1）<strong>static Thread currentThread()——当前线程</strong>：返回对当前正在执行的线程对象的引用。</p>
]]></content>
      <categories>
        <category>Java面试准备</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程同步机制</title>
    <url>/2020/11/22/1-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Java多线程同步机制"><a href="#Java多线程同步机制" class="headerlink" title="Java多线程同步机制"></a>Java多线程同步机制</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h4 id="一个简单的线程安全例子"><a href="#一个简单的线程安全例子" class="headerlink" title="一个简单的线程安全例子"></a>一个简单的线程安全例子</h4><p>1）下面的例子是，有一张银行卡，里面有1000的余额，两个人同时在取款机上取钱。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package thread;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Account account &#x3D; new Account(&quot;123456&quot;, 1000);</span><br><span class="line">		DrawMoneyRunnable drawMoneyRunnable &#x3D; new DrawMoneyRunnable(account, 700);</span><br><span class="line">		Thread myThread1 &#x3D; new Thread(drawMoneyRunnable);</span><br><span class="line">		Thread myThread2 &#x3D; new Thread(drawMoneyRunnable);</span><br><span class="line">		myThread1.start();</span><br><span class="line">		myThread2.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DrawMoneyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">	private Account account;</span><br><span class="line">	private double drawAmount;</span><br><span class="line">	</span><br><span class="line">	public DrawMoneyRunnable(Account account, double drawAmount) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.account &#x3D; account;</span><br><span class="line">		this.drawAmount &#x3D; drawAmount;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public  void run() &#123;</span><br><span class="line">		if (account.getBalance() &gt;&#x3D; drawAmount) &#123; &#x2F;&#x2F; 1</span><br><span class="line">			System.out.println(&quot;取钱成功， 取出钱数为：&quot; + drawAmount);</span><br><span class="line">			double balance &#x3D; account.getBalance() - drawAmount;</span><br><span class="line">			account.setBalance(balance);</span><br><span class="line">			System.out.println(&quot;余额为：&quot; + balance + &quot;\n&quot;);</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			System.out.println(&quot;取钱失败！&quot;);</span><br><span class="line">			System.out.println(&quot;余额为：&quot; + account.getBalance()+&quot;,不够你要取出的数目。&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Account &#123;</span><br><span class="line"></span><br><span class="line">	private String accountNo;</span><br><span class="line">	private double balance;</span><br><span class="line">	</span><br><span class="line">	public Account() &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Account(String accountNo, double balance) &#123;</span><br><span class="line">		this.accountNo &#x3D; accountNo;</span><br><span class="line">		this.balance &#x3D; balance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public String getAccountNo() &#123;</span><br><span class="line">		return accountNo;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void setAccountNo(String accountNo) &#123;</span><br><span class="line">		this.accountNo &#x3D; accountNo;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public double getBalance() &#123;</span><br><span class="line">		return balance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void setBalance(double balance) &#123;</span><br><span class="line">		this.balance &#x3D; balance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）程序的输出结果：</p>
<p><img src="/2020/11/22/1-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/1" alt="在这里插入图片描述"></p>
<p>也就是说，对于一张只有1000余额的银行卡，两个人一共可以取出1400，这显然是有问题的。</p>
<h4 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h4><ul>
<li>线程安全，其实是指多线程环境下对<strong>共享资源</strong>的访问可能会引起此共享资源的不一致性。因此，为避免线程安全问题，应该避免多线程环境下对此共享资源的并发访问。</li>
<li>“非线程安全”问题存在于“实例变量”中，如果是方法内部的私有变量，则不存在“非线程安全”问题，所得结果也就是“线程安全”的了。</li>
<li>如果两个线程同时操作对象中的实例变量，则会出现“非线程安全”，解决办法就是在方法前加上synchronized关键字即可。</li>
</ul>
<h2 id="synchronized——同步锁"><a href="#synchronized——同步锁" class="headerlink" title="synchronized——同步锁"></a>synchronized——同步锁</h2><ul>
<li>如果不知道什么是锁，查询本站 多线程基础篇</li>
</ul>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>1）什么是同步方法：</p>
<ul>
<li>对共享资源进行访问的方法定义中加上synchronized关键字修饰，使得此方法称为同步方法。可以简单理解成对此方法进行了加锁，<strong>其锁对象为当前方法所在的对象自身</strong>。多线程环境下，当执行此方法时，首先都要获得此同步锁（且同时最多只有一个线程能够获得），只有当线程执行完此同步方法后，才会释放锁对象，其他的线程才有可能获取此同步锁，访问此方法，以此类推…</li>
</ul>
<p>2）将上面代码中的run（）方法改为同步方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (account.getBalance() &gt;= drawAmount) &#123; <span class="comment">// 1</span></span><br><span class="line">		System.out.println(<span class="string">&quot;取钱成功， 取出钱数为：&quot;</span> + drawAmount);</span><br><span class="line">		<span class="keyword">double</span> balance = account.getBalance() - drawAmount;</span><br><span class="line">		account.setBalance(balance);</span><br><span class="line">		System.out.println(<span class="string">&quot;余额为：&quot;</span> + balance + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;取钱失败！&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;余额为：&quot;</span> + account.getBalance()+<span class="string">&quot;,不够你要取出的数目。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：<img src="/2020/11/22/1-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/2" alt="在这里插入图片描述"></p>
<p><strong>3）synchronized同步方法与锁对象（重点）</strong></p>
<ul>
<li><p>synchronized本身没有锁的功能，但是他能获取对象锁，何为对象锁？Java的每个对象都有一个内置锁，简称对象锁。synchronized同步方法就是给这个方法加了一个对象锁，其锁对象为当前方法所在的对象自身，也就是哪个对象调用这个方法，就给这个方法加那个对象的锁。</p>
</li>
<li><p><strong>思考这个问题</strong>：在一个类中，有两个同步方法a() 和 b()（方法前面有synchronized修饰），这两个方法没有任何关系。如果说现在有一个线程A正在访问其中一个方法a()，在访问的这段时间，又来了一个线程B，那么线程B能不能访问方法b()呢？</p>
</li>
<li><p>肯定是不行的。为什么呢，因为同步方法的锁是调用这个方法的对象的内置锁，两个方法在同一个类，肯定是同一个对象调用这两个方法，也就是同一个对象锁，既然是同一个对象锁，肯定是不可以的。</p>
</li>
<li><p>上面说的这个性质，其实也就是锁的<strong>互斥性</strong>。看下面代码：如果线程A先执行，则会进去死循环，线程B一直处于同步阻塞的状态，因为线程A一直没有释放锁资源；如果线程B先执行，则会输出这个”B进入test2方法”,然后释放锁资源，这时候线程A才可以执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadX</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;B&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B进入test2方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;A&quot;</span>))&#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThreadX mt=<span class="keyword">new</span> MyThreadX();</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(mt,<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        Thread thread1=<span class="keyword">new</span> Thread(mt,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>4）synchronized锁的可重入性（重点）</strong></p>
<ul>
<li><p>可重入锁就是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadX</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入test2方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">&quot;A&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;A进入test1方法&quot;</span>);</span><br><span class="line">            test2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThreadX mt = <span class="keyword">new</span> MyThreadX();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(mt, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可重入锁也支持在父子类继承的环境中，说明当存在父子类继承关系时，子类是完全可以通过“可重入锁”调用父类的同步方法。</p>
</li>
</ul>
<p><strong>5）同步方法不具有继承性（重点）</strong></p>
<ul>
<li>如果父类有一个带synchronized关键字的方法，子类继承并重写了这个方法。<br> 但是同步不能继承，所以还是需要在子类方法中添加synchronized关键字。</li>
</ul>
<p>6）synchronized同步方法的缺点</p>
<ul>
<li>使用synchronized关键字声明方法有些时候是有很大的弊端的，比如我们有两个线程一个线程A调用同步方法后获得锁，那么另一个线程B就需要等待A执行完，但是如果说A执行的是一个很费时间的任务的话这样就会很耗时。</li>
<li>也就是说，同步方法锁定的范围太大了，这个时候，我们就可以考虑使用 <strong>同步代码块</strong>。</li>
</ul>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>1）什么是同步代码块：</p>
<ul>
<li><p>正如上面所分析的那样，解决线程安全问题其实只需限制对共享资源访问的不确定性即可。使用同步方法时，使得整个方法体都成为了同步执行状态，会使得可能出现同步范围过大的情况，于是，针对需要同步的代码可以直接另一种同步方式——同步代码块来解决。</p>
</li>
<li><p>同步代码块就是个一段代码，加一个对象锁，和同步方法效果一样，只不过是范围更加小了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>2）将上面的安全例子改成同步代码块的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">		<span class="keyword">if</span> (account.getBalance() &gt;= drawAmount) &#123; <span class="comment">// 1</span></span><br><span class="line">			System.out.println(<span class="string">&quot;取钱成功， 取出钱数为：&quot;</span> + drawAmount);</span><br><span class="line">			<span class="keyword">double</span> balance = account.getBalance() - drawAmount;</span><br><span class="line">			account.setBalance(balance);</span><br><span class="line">			System.out.println(<span class="string">&quot;余额为：&quot;</span> + balance + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;取钱失败！&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;余额为：&quot;</span> + account.getBalance() + <span class="string">&quot;,不够你要取出的数目。&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果：<br> <img src="/2020/11/22/1-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/3" alt="在这里插入图片描述"></li>
</ul>
<p><strong>3）同步代码块的锁对象（重点）：</strong></p>
<ul>
<li>同步代码后面跟着一个对象obj，<code>synchronized (obj)</code>，obj是哪个对象，就代表着，这个代码块使用的是那个对象的锁，选择哪一个对象作为锁是至关重要的。</li>
<li>如果使用 <code>this</code>，就代表锁对象是执行这个代码块的对象的锁，其实也就是和同步方法的锁对象是一个道理。</li>
<li>一般情况下：都是选择此共享资源对象作为锁对象。如上例中，最好选用account对象作为锁对象。（当然，选用this也是可以的，那是因为创建线程使用了runnable方式，如果是直接继承Thread方式创建的线程，使用this对象作为同步锁会其实没有起到任何作用，因为是不同的对象了。因此，选择同步锁时需要格外小心…）</li>
</ul>
<p><strong>4）同步代码块间的同步性（重点）：</strong></p>
<ul>
<li>当一个对象访问synchronized(this)代码块时，其他线程对同一个对象中所有其他synchronized(this)代码块代码块的访问将被阻塞，这说明synchronized(this)代码块使用的“对象监视器”是一个。<br> 也就是说和synchronized方法一样，synchronized(this)代码块也是锁定当前对象的。</li>
<li>另外通过上面的学习我们可以得出两个结论。<ul>
<li>其他线程执行对象中synchronized同步方法（上一节我们介绍过，需要回顾的可以看上一节的文章）和synchronized(this)代码块时呈现一样的同步效果，只不过后者的作用范围跟小一些;</li>
<li>如果两个线程使用了同一个“对象监视器”,运行结果同步，否则不同步.</li>
</ul>
</li>
</ul>
<h4 id="静态同步方法-代码块"><a href="#静态同步方法-代码块" class="headerlink" title="静态同步方法/代码块"></a>静态同步方法/代码块</h4><ul>
<li><p>synchronized关键字加到static静态方法和synchronized(class)代码块上都是是给Class类上锁，而synchronized关键字加到非static静态方法上是给对象上锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享资源</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">	<span class="comment">//静态方法，获取的Class锁</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (Service.class) &#123;	<span class="comment">//这里要用类的class对象</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(</span><br><span class="line">						<span class="string">&quot;线程名称为：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;在&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;进入printA&quot;</span>);</span><br><span class="line">				Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">				System.out.println(</span><br><span class="line">						<span class="string">&quot;线程名称为：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;在&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;离开printA&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;线程名称为：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;在&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;进入printB&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;线程名称为：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;在&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;离开printB&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;线程名称为：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;在&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;进入printC&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;线程名称为：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;在&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;离开printC&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.service = service;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Service.printA();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.service = service;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Service.printB();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadC</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.service = service;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		service.printC();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Service service = <span class="keyword">new</span> Service();</span><br><span class="line">		ThreadA a = <span class="keyword">new</span> ThreadA(service);</span><br><span class="line">		a.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">		a.start();</span><br><span class="line"></span><br><span class="line">		ThreadB b = <span class="keyword">new</span> ThreadB(service);</span><br><span class="line">		b.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">		b.start();</span><br><span class="line"></span><br><span class="line">		ThreadC c = <span class="keyword">new</span> ThreadC(service);</span><br><span class="line">		c.setName(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">		c.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>运行结果：<br>   <img src="/2020/11/22/1-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/4" alt="在这里插入图片描述"></p>
<ul>
<li><p>从运行结果可以看出:线程A,B和线程C持有的锁不一样，所以A和B运行同步，但是和C运行不同步。</p>
</li>
<li><p>静态同步synchronized方法与synchronized(class)代码块持有的锁一样，都是Class锁，Class类锁对所有的使用<code>Class.class</code>对象锁的方法或代码块起作用。synchronized关键字加到非static静态方法上持有的是对象锁，与Class类锁不会产生同步。</p>
</li>
</ul>
<h4 id="synchronized释放锁的时机"><a href="#synchronized释放锁的时机" class="headerlink" title="synchronized释放锁的时机"></a>synchronized释放锁的时机</h4><ul>
<li>当方法(代码块)执行完毕后会自动释放锁，不需要做任何的操作。</li>
<li>当一个线程执行的代码出现异常时，其所持有的锁会自动释放。不会由于异常导致出现死锁现象~</li>
<li>如果只是进入阻塞状态，不会释放锁，比如调用sleep方法。</li>
</ul>
<h2 id="Lock——显式锁"><a href="#Lock——显式锁" class="headerlink" title="Lock——显式锁"></a>Lock——显式锁</h2><h4 id="Lock锁概述"><a href="#Lock锁概述" class="headerlink" title="Lock锁概述"></a>Lock锁概述</h4><blockquote>
<p>Lock锁，可以得到和 synchronized一样的效果，即实现原子性、有序性和可见性。</p>
<p>相较于synchronized，Lock锁可手动获取锁和释放锁、可中断的获取锁、超时获取锁。</p>
<p>Lock 是一个接口，两个直接实现类：</p>
<ul>
<li>ReentrantLock（重入锁）</li>
<li>ReentrantReadWriteLock（读写锁）。</li>
</ul>
</blockquote>
<p>1）有什么办法方便同步锁对象与共享资源解耦，同时又能很好的解决线程安全问题？</p>
<ul>
<li><p>使用Lock对象同步锁可以方便的解决此问题，唯一需要注意的一点是Lock对象需要与资源对象同样具有一对一的关系。Lock对象同步锁一般格式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示定义Lock同步锁对象，此对象与共享资源具有一对一关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 加锁</span></span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// ... 需要进行线程安全同步的代码</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 释放Lock锁</span></span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>2）给上面的线程安全问题加上Lock锁：</p>
<ul>
<li><p>l.lock()方法进行上锁， l.unlock()方法进行解锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrawMoneyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Account account;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> drawAmount;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DrawMoneyRunnable</span><span class="params">(Account account, <span class="keyword">double</span> drawAmount)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.account = account;</span><br><span class="line">		<span class="keyword">this</span>.drawAmount = drawAmount;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (account.getBalance() &gt;= drawAmount) &#123; <span class="comment">// 1</span></span><br><span class="line">				System.out.println(<span class="string">&quot;取钱成功， 取出钱数为：&quot;</span> + drawAmount);</span><br><span class="line">				<span class="keyword">double</span> balance = account.getBalance() - drawAmount;</span><br><span class="line">				account.setBalance(balance);</span><br><span class="line">				System.out.println(<span class="string">&quot;余额为：&quot;</span> + balance + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;取钱失败！&quot;</span>);</span><br><span class="line">				System.out.println(<span class="string">&quot;余额为：&quot;</span> + account.getBalance() + <span class="string">&quot;,不够你要取出的数目。&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Lock锁-与-synchronized锁比较"><a href="#Lock锁-与-synchronized锁比较" class="headerlink" title="Lock锁 与 synchronized锁比较"></a>Lock锁 与 synchronized锁比较</h4><p>1）两者的区别：</p>
<ul>
<li>首先synchronized是java内置关键字，在jvm层面，Lock是个java接口，他有实现类；</li>
<li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</li>
<li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</li>
<li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</li>
<li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</li>
<li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</li>
</ul>
<h2 id="wait-notify-notifyAll-线程通信"><a href="#wait-notify-notifyAll-线程通信" class="headerlink" title="wait()/notify()/notifyAll()线程通信"></a>wait()/notify()/notifyAll()线程通信</h2><blockquote>
<p>虽然这三个方法主要都是用于多线程中，但实际上都是Object类中的本地方法。因此，理论上，任何Object对象都可以作为这三个方法的主调，在实际的多线程编程中，<strong>只有同步锁对象调这三个方法，才能完成对多线程间的线程通信</strong>。</p>
</blockquote>
<p>1）三个方法的api</p>
<ul>
<li>wait()：导致当前线程等待并使其进入到等待阻塞状态。直到其他线程调用该同步锁对象的notify()或notifyAll()方法来唤醒此线程。</li>
<li>notify()：唤醒在此同步锁对象上等待的单个线程，如果有多个线程都在此同步锁对象上等待，则会任意选择其中某个线程进行唤醒操作，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。</li>
<li>notifyAll()：唤醒在此同步锁对象上等待的所有线程，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qqyumidi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="string">&quot;123456&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Thread drawMoneyThread = <span class="keyword">new</span> DrawMoneyThread(<span class="string">&quot;取钱线程&quot;</span>, account, <span class="number">700</span>);</span><br><span class="line">        Thread depositeMoneyThread = <span class="keyword">new</span> DepositeMoneyThread(<span class="string">&quot;存钱线程&quot;</span>, account, <span class="number">700</span>);</span><br><span class="line"></span><br><span class="line">        drawMoneyThread.start();</span><br><span class="line">        depositeMoneyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrawMoneyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawMoneyThread</span><span class="params">(String threadName, Account account, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(threadName);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            account.draw(amount, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DepositeMoneyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepositeMoneyThread</span><span class="params">(String threadName, Account account, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(threadName);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            account.deposite(amount, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">    <span class="comment">// 标识账户中是否已有存款</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String accountNo, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccountNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountNo</span><span class="params">(String accountNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存钱</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> depositeAmount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposite</span><span class="params">(<span class="keyword">double</span> depositeAmount, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">// 账户中已有人存钱进去，此时当前线程需要等待阻塞</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始要执行wait操作&quot;</span> + <span class="string">&quot; -- i=&quot;</span> + i);</span><br><span class="line">                wait();</span><br><span class="line">                <span class="comment">// 1</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行了wait操作&quot;</span> + <span class="string">&quot; -- i=&quot;</span> + i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 开始存钱</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 存款:&quot;</span> + depositeAmount + <span class="string">&quot; -- i=&quot;</span> + i);</span><br><span class="line">            setBalance(balance + depositeAmount);</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒其他线程</span></span><br><span class="line">            notifyAll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-- 存钱 -- 执行完毕&quot;</span> + <span class="string">&quot; -- i=&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取钱</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> drawAmount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawAmount, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="comment">// 账户中还没人存钱进去，此时当前线程需要等待阻塞</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始要执行wait操作&quot;</span> + <span class="string">&quot; 执行了wait操作&quot;</span> + <span class="string">&quot; -- i=&quot;</span> + i);</span><br><span class="line">                wait();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行了wait操作&quot;</span> + <span class="string">&quot; 执行了wait操作&quot;</span> + <span class="string">&quot; -- i=&quot;</span> + i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 开始取钱</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 取钱：&quot;</span> + drawAmount + <span class="string">&quot; -- i=&quot;</span> + i);</span><br><span class="line">            setBalance(getBalance() - drawAmount);</span><br><span class="line"></span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒其他线程</span></span><br><span class="line">            notifyAll();</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-- 取钱 -- 执行完毕&quot;</span> + <span class="string">&quot; -- i=&quot;</span> + i); <span class="comment">// 3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）要注意的点：</p>
<ul>
<li>1.wait()方法执行后，当前线程立即进入到等待阻塞状态，其后面的代码不会执行；</li>
<li>2.notify()/notifyAll()方法执行后，将唤醒此同步锁对象上的（任意一个-notify()/所有-notifyAll()）线程对象，但是，此时还并没有释放同步锁对象，也就是说，如果notify()/notifyAll()后面还有代码，还会继续进行，知道当前线程执行完毕才会释放同步锁对象；</li>
<li>3.notify()/notifyAll()执行后，如果右面有sleep()方法，则会使当前线程进入到阻塞状态，但是同步对象锁没有释放，依然自己保留，那么一定时候后还是会继续执行此线程，接下来同2；</li>
<li>4.wait()/notify()/nitifyAll()完成线程间的通信或协作都是基于不同对象锁的，因此，如果是不同的同步对象锁将失去意义，同时，同步对象锁最好是与共享资源对象保持一一对应关系；</li>
<li>5.当wait线程唤醒后并执行时，是接着上次执行到的wait()方法代码后面继续往下执行的。</li>
</ul>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><blockquote>
<ul>
<li>修饰变量，保证变量的可见性，不保证原子性。</li>
</ul>
</blockquote>
<h4 id="volatile关键字的可见性"><a href="#volatile关键字的可见性" class="headerlink" title="volatile关键字的可见性"></a>volatile关键字的可见性</h4><p>1） 补个下面用到的知识点：</p>
<ul>
<li>主存是公共空间，基本可以类比为虚拟机模型中的堆，对象创建好了都是在主存里，所有线程都可以访问（共享）。</li>
<li>工作内存（下文所说的本地内存）是线程的私有内存，只有本线程可以访问，如果线程要操作主存中的某个对象，必须从主存中拷贝到工作内存，在对工作内存中的副本进行操作，操作后再写入主存，而不能对主存的对象直接操作 。</li>
</ul>
<p>2） <strong>volatile 修饰的成员变量</strong>在每次被线程访问时，都强迫从<strong>主存（共享内存）中重读该成员变量的值</strong>。而且，<strong>当成员变量发生变化时，强迫线程将变化值回写到主存（共享内存）</strong>。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值，这样也就保证了同步数据的可见性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> thread.syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		RunThread thread = <span class="keyword">new</span> RunThread();</span><br><span class="line"></span><br><span class="line">		thread.start();</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		thread.setRunning(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;已经赋值为false&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> isRunning;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunning</span><span class="params">(<span class="keyword">boolean</span> isRunning)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.isRunning = isRunning;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;进入run了&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span> (isRunning == <span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">int</span> c = a + b;</span><br><span class="line">			m = c;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(m);</span><br><span class="line">		System.out.println(<span class="string">&quot;线程被停止了！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：死循环<br> <img src="/2020/11/22/1-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/5" alt="在这里插入图片描述"></p>
<ul>
<li>RunThread类中的isRunning变量没有加上volatile关键字时，运行以上代码会出现死循环，这是因为isRunning变量虽然被修改但是没有被写到主存中，这也就导致该线程在本地内存中的值一直为true，这样就导致了死循环的产生。</li>
<li>解决办法也很简单：isRunning变量前加上volatile关键字即可。<br> <img src="/2020/11/22/1-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/6" alt="在这里插入图片描述"></li>
</ul>
<p>3）注意下面这个问题：<br> 假如你把while循环代码里加上任意一个输出语句或者sleep方法你会发现死循环也会停止，不管isRunning变量是否被加上了上volatile关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (isRunning == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> b=<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> c=a+b;</span><br><span class="line">            m=c;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//或者：</span></span><br><span class="line">        <span class="keyword">while</span> (isRunning == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> b=<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> c=a+b;</span><br><span class="line">            m=c;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是为什么？</li>
</ul>
<p>JVM会尽力保证内存的可见性，即便这个变量没有加同步关键字。换句话说，只要CPU有时间，JVM会尽力去保证变量值的更新。这种与volatile关键字的不同在于，volatile关键字会强制的保证线程的可见性。而不加这个关键字，JVM也会尽力去保证可见性，但是如果CPU一直有其他的事情在处理，它也没办法。最开始的代码，一直处于死循环中，CPU处于一直占用的状态，这个时候CPU没有时间，JVM也不能强制要求CPU分点时间去取最新的变量值。而加了输出或者sleep语句之后，CPU就有可能有时间去保证内存的可见性，于是while循环可以被终止。</p>
<h4 id="volatile关键字能保证原子性吗？"><a href="#volatile关键字能保证原子性吗？" class="headerlink" title="volatile关键字能保证原子性吗？"></a>volatile关键字能保证原子性吗？</h4><blockquote>
<p>volatile是无法保证原子性的，要保证数据的原子性还是要使用synchronized关键字。</p>
</blockquote>
<h4 id="synchronized关键字和volatile关键字比较"><a href="#synchronized关键字和volatile关键字比较" class="headerlink" title="synchronized关键字和volatile关键字比较"></a>synchronized关键字和volatile关键字比较</h4><ul>
<li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是<strong>volatile关键字只能用于变量</strong>而<strong>synchronized关键字可以修饰方法以及代码块</strong>。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用synchronized关键字还是更多一些。</li>
<li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</li>
<li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</li>
<li>volatile关键字用于解决变量在多个线程之间的可见性，而ynchronized关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
]]></content>
      <categories>
        <category>Java面试准备</category>
        <category>多线程</category>
        <category>线程同步</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客本地部署流程</title>
    <url>/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="hexo博客本地部署流程"><a href="#hexo博客本地部署流程" class="headerlink" title="hexo博客本地部署流程"></a>hexo博客本地部署流程</h1><p>一年前用hexo部署过博客，由于其他事情导致长时间未使用，后来又尝试了wordpress与typecho，但个人比较喜欢修改主题样式，感觉wordpress与typecho的封装性太强，于是又回来继续使用hexo。记录自己重新部署hexo的过程，更新以前的部署笔记，故有的时间显示为2019年，但流程都是一样的。</p>
<hr>
<h2 id="本地部署过程"><a href="#本地部署过程" class="headerlink" title="本地部署过程"></a>本地部署过程</h2><p>需要安装的东西：git、Node.js、hexo。</p>
<p>其中git安装完成后的Git Bash，其作用与系统自带的CMD命令行相同，系统中的CMD命令同样可以在Git Bash中完成。</p>
<p>链接：</p>
<ul>
<li><a href="https://git-scm.com/downloads">git官方下载地址</a></li>
<li><a href="https://npm.taobao.org/mirrors/git-for-windows/">git淘宝镜像下载地址</a></li>
<li><a href="https://nodejs.org/en/">Node.js官网下载地址</a></li>
</ul>
<p>hexo使用命令安装。</p>
<p><a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a>里面有关于hexo的各种使用方法，包括各个指令、文件的说明、如何更改网站的一些信息等等。</p>
<h2 id="hexo常用指令："><a href="#hexo常用指令：" class="headerlink" title="hexo常用指令："></a>hexo常用指令：</h2><p><code>hexo new &quot;title&quot;</code> 新建文章(md文件)，title为文章的标题<br> <code>hexo new page &quot;pagename&quot;</code> 新建网页，pagename为网页的名称<br> <code>hexo clean</code> 清除部署的緩存<br> <code>hexo n == hexo new</code> 新建一篇文章<br> <code>hexo g == hexo generate</code> 生成静态页面<br> <code>hexo s == hexo server</code> 本地部署，可预览网站，默认端口为4000，浏览器输入<code>localhost:4000</code>即可进入网站进行预览，回到git-bash按<code>ctrl+c</code>退出预览(退出后<code>localhost:4000</code>失效)<br> <code>hexo d == hexo deploy</code> 将网站部署到GitHub<br> <code>hexo g -d</code> 生成页面并部署到GitHub<br> <code>hexo g -s</code> 生成页面并本地部署进行预览</p>
<h2 id="安装git："><a href="#安装git：" class="headerlink" title="安装git："></a>安装git：</h2><p>本文章书写日期时最新版本为2.22.0版本</p>
<p>因版本可能不同，因此安装过程中的组件选择可能会有所差异，基本默认选项即可</p>
<p>下载完成后进入安装界面 (注:以下安装的选项请以实际自身需求为准，仅供参考):</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030720.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030720.png" alt="mark"></a></p>
<p>选择需要安装的组件。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030722.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030722.png" alt="mark"></a></p>
<p>选择git的默认编辑器:</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030724.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030724.png" alt="mark"></a></p>
<p>配置环境变量选项,推荐默认第二项:</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030721.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030721.png" alt="mark"></a></p>
<p>选择https传输协议 默认即可:</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030723.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030723.png" alt="mark"></a></p>
<p>选择git的换行方式 请根据自身需求更改:</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030725.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030725.png" alt="mark"></a></p>
<p>设置git命令行的样式:</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030726.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030726.png" alt="mark"></a></p>
<p>设置选项：1.是否允许文件缓存 2.是否允许git许可证管理，默认勾选：</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030740.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030740.png" alt="mark"></a></p>
<p>是否参与新的测试,貌似是会使git更快，但还不稳定:</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030727.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030727.png" alt="mark"></a></p>
<p>install 安装即可:</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030728.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030728.png" alt="mark"></a></p>
<p>git安装完成后，需要进行配置，在git安装目录或菜单栏中找到git-bash，打开后如图</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030737.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030737.png" alt="mark"></a></p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030729.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030729.png" alt="mark"></a></p>
<p>输入如下，其中” “中的your name 和your email为你的Git Hub用户名(非昵称)与邮箱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot;</span><br><span class="line">git config --global user.email &quot;your email&quot;</span><br></pre></td></tr></table></figure>

<p>并可通过以下命令查询用户名与邮箱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030731.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030731.png" alt="mark"></a></p>
<h2 id="安装Node-js："><a href="#安装Node-js：" class="headerlink" title="安装Node.js："></a>安装Node.js：</h2><p>Node.js 不要用太高的版本，用 12.14即可。 最近hexo g的时候 用 14.14版本出现了一些问题。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030730.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030730.png" alt="mark"></a></p>
<p>安装界面:</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030732.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030732.png" alt="mark"></a></p>
<p>next即可:</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030733.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030733.png" alt="mark"></a></p>
<p>以下过程命令行既可使用windows的cmd，也可以使用git安装过程中的 git-bash进行操作</p>
<p>命令行中输入<code>node -v</code>可查看node的版本 ,输入 <code>npm -v</code>查看npm包的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030735.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030735.png" alt="mark"></a></p>
<p>因为npm为国外源，下载速度感人，故使用cnpm使下载指向国内源。</p>
<p>利用淘宝服务器安装cnpm ,因为翻使用npm墙慢. -g表示全局安装.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>下载完后查看cnpm版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure>

<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030734.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030734.png" alt="mark"></a></p>
<p>查询成功则证明安装完成。</p>
<h2 id="安装hexo："><a href="#安装hexo：" class="headerlink" title="安装hexo："></a>安装hexo：</h2><p>使用cnpm下载hexo,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>用hexo -v查看hexo的版本:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>

<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030736.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030736.png" alt="mark"></a></p>
<h2 id="hexo部署博客："><a href="#hexo部署博客：" class="headerlink" title="hexo部署博客："></a>hexo部署博客：</h2><p>在我的电脑中创建文件夹用于存储博客网站，即网站的站点。文件夹名称自定义，我使用blog,目录为D:\blog。.如果后面操作有失误,直接把文件夹干掉重来即可.<br>打开blog文件夹，右键空白处点击Git Bash Here在该目录下打开Git Bash(或者用CMD切换到该目录也行)。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030738.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030738.png" alt="mark"></a></p>
<p><strong>Windows Linux</strong> 可以再CMD直接 <code>hexo init</code> (前提是git安装好,并添加进环境变量. cnmp也安装好)  </p>
<p>或者不配置 git path， 在git Bash 打开之后,就可以直接输入<code>hexo init</code>  之后要等待一段时间.在blog目录下面看到很多文件即可.</p>
<p>输入<code>hexo init</code>进行初始化，等待时间较长，约几分钟。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/image-20201107163932172.png" alt="image-20201107163932172"></p>
<p><strong>注</strong>：若blog文件夹非空，则会报错:</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030742.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030742.png" alt="mark"></a></p>
<blockquote>
<p>可选：安装组件。(这一步其实在 hexo init 的时候已经自动做好了。)</p>
<p>cnpm install hexo –save</p>
</blockquote>
<p>用 hexo s 启动本地服务 默认端口号是 4000 自动生成一个HelloWord的md文档,放在 blog\source_posts 下面.可以在这个文件夹下自己新建一个我的第一篇博客.md. 然后<br>   <code>hexo clean</code> 清除一下 <code>hexo g</code>    generated嘛 重新构建一下.就可以新建博客啦.!</p>
<p>使用<code>hexo s</code> 在本地启动博客</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/image-20201107164105344.png" alt="image-20201107164105344"></p>
<p>如图所示显示本地部署成功</p>
<p>打开网页，地址栏输入<code>http://localhost:4000</code>即可从本地进入博客</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030746.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030746.png" alt="mark"></a></p>
<p>目录内的各个文件的作用参考<a href="https://hexo.io/zh-cn/docs/setup">官方文档</a></p>
<h1 id="静态页面部署到github过程"><a href="#静态页面部署到github过程" class="headerlink" title="静态页面部署到github过程"></a>静态页面部署到github过程</h1><h2 id="1-在github上创建静态网站的存储库："><a href="#1-在github上创建静态网站的存储库：" class="headerlink" title="1.在github上创建静态网站的存储库："></a>1.在github上创建静态网站的存储库：</h2><p>通过<code>Ctrl+C</code>停止服务</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030744.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030744.png" alt="mark"></a></p>
<p>登陆自己的Git Hub <a href="https://github.com/login">点击进入登陆界面</a></p>
<p>登陆成功后，网页右上角个人头像旁边，点击 + 号 选择New repository创建一个新的仓库</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030743.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030743.png" alt="mark"></a></p>
<p>输入的信息如下，其中 Repository name内容必须是 github的用户名，而不是昵称。点击Create repository创建项目。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030745.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030745.png" alt="mark"></a></p>
<p>创建成功后，界面如图，复制https的链接。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030748.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030748.png" alt="mark"></a></p>
<p>回到git-bash 使用cnpm安装git部署插件，插件名为:hexo-deployer-git</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>安装过程中若有警告可以忽略</p>
<h2 id="2-修改-config-yml-文件："><a href="#2-修改-config-yml-文件：" class="headerlink" title="2.修改 _config.yml 文件："></a>2.修改 _config.yml 文件：</h2><p>打开网站目录的 _config.yml</p>
<p>移动到最低端，在deploy:后面写入内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: https:&#x2F;&#x2F;github.com&#x2F;ZhangHao0810&#x2F;ZhangHao0810.github.io.git </span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>

<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030747.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030747.png" alt="mark"></a></p>
<h2 id="3-推送到github-page："><a href="#3-推送到github-page：" class="headerlink" title="3.推送到github page："></a>3.推送到github page：</h2><p>修改完成后，保存文件，在Git Bash中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>即可将本地的网站服务器渲染出的静态页面上传到github。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030809.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030809.png" alt="mark"></a></p>
<p>该过程可能需要输入github和coding的用户名和密码，若GitHub配置过SSH则不需要输入。</p>
<p>如果有报错，检查之前的配置是否有误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot;</span><br><span class="line">git config --global user.email &quot;your email&quot;</span><br></pre></td></tr></table></figure>

<p>配置语句是否正确 your name为用户名(非昵称)</p>
<p>推送完成后，再次进入仓库，即可看到上传完成的静态网页。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030750.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030750.png" alt="mark"></a></p>
<p>并且可以通过 <code>你的用户名.github.io</code> 来进入网站，此时网站已经部署到github page，其他人也可以通过该地址访问你的网站。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030751.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030751.png" alt="mark"></a></p>
<p><code>hexo s</code>指令仅启动本地服务，修改后只能通过localhost:4000来进行访问，此时没有推送页面到github。想要推送到github生成页面的话，需要通过<code>hexo d</code>进行推送。</p>
<p>推送前输入指令<code>hexo clean</code>清除缓存，然后再输入<code>hexo g</code>重新生成静态页面，然后推送即可。</p>
<h2 id="如何自定义一个主题"><a href="#如何自定义一个主题" class="headerlink" title="如何自定义一个主题?"></a>如何自定义一个主题?</h2><p>githbu上有好的主题,可以在blog下 </p>
<p>cmd git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia  </p>
<p>即将这个项目clone到 theme/yilia下.</p>
<p>然后打开_config.yml 把theme 换成yilia 默认是 landscape</p>
<p>然后<code>hexo clean</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p><code>hexo s</code><br>查看一下 本地ok了之后关闭.再推到远端,  <code>hexo d</code><br>之后再照着主题的开发文档来美化自己的网站就行了.</p>
<h1 id="博客修改配置"><a href="#博客修改配置" class="headerlink" title="博客修改配置"></a>博客修改配置</h1><p><a href="https://hexo.io/zh-cn/docs/configuration">官方文档</a>里有基本的配置文件内容说明，例如修改博主名称、网站名称、副标题、描述等等。</p>
<h2 id="永久链接："><a href="#永久链接：" class="headerlink" title="永久链接："></a>永久链接：</h2><p>打开博客目录下的配置文件_config.yml，按<code>Ctrl+F</code>搜索 URL</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030800.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030800.png" alt="mark"></a></p>
<p>url内容不用改，修改permalink内容</p>
<p>其意思为：修改一篇文章的url</p>
<p>默认的设置为将一篇文章的创建日期+title作为永久链接，但这样并不美观，并且在分享链接时因为编码问题中文会被转码造成如下结果</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030749.png"><img src="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030749.png" alt="mark"></a></p>
<p>链接的格式为 你的域名/permalink内容，</p>
<p>比如我修改后的<code>post/:year:month:day:hour:minute/</code></p>
<p>会将创建文件时的年月日时分作为永久链接，避免了分享中文时的乱码。</p>
<p>加一个post是为了将文章统一放在一个文件夹中，在生成静态网页时，会生成一个post文件夹，里面存放生成的文章。还有其余的样式，在官方文档的永久链接中有说明。</p>
<p>还有一种改法是使用<code>:urlname</code>，然后在文档的头信息中给urlname参数，让该参数的值为永久链接，但同样避免不了中文转码的问题，我个人就使用日期作为永久链接了。但这样其实有个问题就是以后管理文档时，post文件夹内显示的都是日期数字，不能直观的看到文章标题。</p>
<h2 id="修改默认文章模板："><a href="#修改默认文章模板：" class="headerlink" title="修改默认文章模板："></a>修改默认文章模板：</h2><p>打开站点目录下的<code>scaffolds</code>文件夹，打开<code>post.md</code></p>
<p>该markdown文档的内容会在生成一个markdown文档后自动添加进去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125; </span><br><span class="line">date: &#123;&#123; date &#125;&#125; </span><br><span class="line">comments: true</span><br><span class="line">toc: true</span><br><span class="line">top: false</span><br><span class="line"></span><br><span class="line"># 若使用urlname作为永久链接则添加该项</span><br><span class="line">urlname:</span><br><span class="line"></span><br><span class="line">categories: </span><br><span class="line">- [父类,子类]</span><br><span class="line">- 同级分类</span><br><span class="line">tags: [标签1,标签2]</span><br><span class="line">---</span><br><span class="line"># 前言</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<p>提前设置好模板，这样生成一个新markdown文档后，只需修改urlname以及设置分类<code>categories</code>与标签<code>tags</code>即可，若主题支持，可设置是否有目录<code>toc</code>，是否置顶<code>top</code>，是否开启评论<code>comments</code>，不同的主题可能名称不同，根据自己的主题修改即可。</p>
<p>若有不支持的功能也不会出错，仅仅无法加载该内容。</p>
<p>hexo博客本地部署流程与1586351508914 为标题与文档创建日期，不需要改动</p>
<p>分类<code>categories</code>里，前面有减号<code>-</code>的表示为同级分类，中括号<code>[]</code>括起来的为父子分类。</p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories: </span><br><span class="line">- [生活,笔记]</span><br><span class="line">- 娱乐</span><br></pre></td></tr></table></figure>

<p>文档在推送后，分类为生活类中的笔记类，同时也是娱乐类。</p>
<p>也可以将娱乐类改为 <code>[娱乐,音乐]</code>，这样就同时是娱乐类中的音乐类。</p>
<h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><p>以我的域名为例，不同商家解析时都差不多。在域名管理处点击解析</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030752.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030752.png" alt="mark"></a></p>
<p>点击添加记录。会出现如图的添加设置。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030755.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030755.png" alt="mark"></a></p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030757.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030757.png" alt="mark"></a></p>
<p>主机记录可理解为域名前缀，即用户输入什么样的网址访问到该解析目标。如果主机记录为www   ，则用户需要输入www.[你的域名]才能访问到该解析目标。如果为@，则直接输入域名即可。如果不添加www   ，则通过www+域名方式访问的用户将访问失败，@同理，其余的也同理。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030754.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030754.png" alt="mark"></a></p>
<p>记录类型为解析目标的类型，如果想把该域名绑定到一个ip地址，则选A，如果目标为一个网址，则选CNAME。</p>
<p>这里有两种绑定方法，一种是选CNAME然后在记录值填写 [yourname].github.io ，另一种是选A，然后通过cmd命令行输入 <code>ping [yourname].github.io</code> 获取ip地址，记录值里填入ip地址。</p>
<p>获取 [yourname].github.io 的ip地址，如图，ping通后会显示ip地址。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030753.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030753.png" alt="mark"></a></p>
<p>记录值根据选择的记录类型进行填写。线路选默认。TTL为缓存生效时间，默认600秒即可，即10分钟后生效(实际大约需要5 分钟)。填写完毕后点击保存。可以为域名填写多个记录， 如图</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030756.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030756.png" alt="mark"></a></p>
<p>前两个是为github   pages绑定时添加的记录，一个www、一个@，这样可以让用域名直接访问的和加了www访问的用户都能访问到自己的博客   (部署到服务器后就不再用了所以暂停了)。接下来两条A类型是将网站部署到自己的服务器时，把域名解析到了自己的服务器IP地址，这样可以通过www、或者直接输入域名的方式来访问自己的服务器。最后一条是绑定的七牛云，用来当做博客的图床。每条记录后面都有操作可以进行修改以及暂停和开启。</p>
<h2 id="绑定到github-pages"><a href="#绑定到github-pages" class="headerlink" title="绑定到github pages"></a>绑定到github pages</h2><p>登陆到自己的github，进入网站绑定的仓库，进入设置</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030759.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030759.png" alt="mark"></a></p>
<p>往下找到GitHub Pages，在Custom domain填入刚刚购买的域名，点击save保存。勾选Enforce HTTPS则开启HTTPS安全协议。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030758.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030758.png" alt="mark"></a></p>
<p>然后到本地博客<code>source</code>文件夹下新建文件CNAME，输入内容为自己的域名，并将文件尾缀如<code>.txt</code>等删掉然后保存即可。(没有的话貌似每次将代码从本地推到github都会使域名访问404，因为每次推送都会覆盖原本的仓库代码。所以把CNAME文件放在source中，使每次推送都会建立一个CNAME)</p>
<p>至此，github pages的域名绑定完成了，稍等片刻即可尝试使用域名访问。</p>
<h1 id="源代码保存到github"><a href="#源代码保存到github" class="headerlink" title="源代码保存到github"></a>源代码保存到github</h1><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p>在仓库中的文件列表的左上方，点击Branch。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030802.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030802.png" alt="mark"></a></p>
<p>搜索 source （分支名，自定义），会提示未找到，是否创建，点击即可创建该分支</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030804.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030804.png" alt="mark"></a></p>
<h2 id="设置新建分支为默认分支"><a href="#设置新建分支为默认分支" class="headerlink" title="设置新建分支为默认分支"></a>设置新建分支为默认分支</h2><p>进入设置，左边的列表中选择 Branches，默认分支为master，改为新建的分支，然后点击Update更新。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030805.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030805.png" alt="mark"></a></p>
<h2 id="同步配置"><a href="#同步配置" class="headerlink" title="同步配置"></a>同步配置</h2><p>首先随便找个地方新建一个文件夹，将你的仓库克隆下来。</p>
<p>打开新建的文件夹，右键空白处点击<code>Git Bash Here</code></p>
<p>然后输入下方命令克隆文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone 【你的仓库地址】</span><br></pre></td></tr></table></figure>

<p>仓库地址获取方法：</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030803.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030803.png" alt="mark"></a></p>
<p>点击红框内的按钮复制，然后粘贴到clone后面即可，用空格与clone隔开。</p>
<p>克隆完成后，该文件夹内会出现<code>【你的用户名】.github.io</code>文件夹，进去拷贝<code>.git</code>文件夹到本地的博客根目录，然后这个新建的文件夹就可以删除了。</p>
<p>接下来在博客根目录右键空白处，打开git bash，输入下方命令，警告不用理会，若没出现报错就没问题。</p>
<p>会需要github的帐号密码，填一下就OK了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin 【你的仓库地址】</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;【描述，随便写】&quot;</span><br><span class="line">git push origin 【你的保存源代码的分支名】</span><br></pre></td></tr></table></figure>

<p>描述部分的效果如图，会将内容显示在该分支上。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030807.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030807.png" alt="mark"></a></p>
<p>每次推送时，输入的描述都会在这次推送时更新的文件后面显示出来。</p>
<p>接下来每次想保存时，输入下方指令即可，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;【描述】&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>但每次都要输入这么多很麻烦，可以创建一个脚本文件，在博客根目录下新建一个txt文本文件，名字随意自己能知道是保存用的就行，将上方三条指令写进去，描述写好后以后固定都是这个，然后将文件改为<code>.sh</code>结尾。也可以直接建一个<code>.sh</code>尾缀文件，然后用编辑器打开写入。这样以后每次运行这个脚本文件就会自动执行上面三条指令，完成推送。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030806.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030806.png" alt="mark"></a></p>
<p>本地同步到github就完成了，但要注意的是只保存了关键文件，如主题、文章、配置等。</p>
<p>node_modules文件夹和public文件夹是没有保存上去的，public文件夹是生成的静态页面，不需要保存，若迁移后直接生成就有了。</p>
<p>node_modules文件夹存放着需要用到的插件，如果想保存的话，打开<code>.gitignore</code>文件，把里面的node_modules删掉保存即可，但是这样会造成每次保存都需要很久时间，因为里面东西太多了，看个人需要决定是否需要保存。</p>
<p>只要配置文件里面的deploy里的branch的值是master的话，生成的静态页面会推送到master分支</p>
<p><a href="https://cdn.jsdelivr.net/gh/lluuiq/blog_img/img/20200324030808.png"><img src="/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/20200324030808.png" alt="mark"></a></p>
<p>配置完成后，若以后要迁移到其他的服务器或者电脑上，只需要安装好git、Node.js、hexo，然后使用<code>hexo init</code>命令初始化一个根目录，再克隆下来就行了，若不指定克隆分支的话，会克隆默认分支，即设置好的保存博客源代码的分支。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 实践 Mapper 与 DAO</title>
    <url>/2020/10/28/4-JavaEE-%E2%98%85%E2%98%85%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E2%98%85%E2%98%85/03-Mybatis-Mybatis%20Plus/MyBatis%20%E5%AE%9E%E8%B7%B5%20%20-Mapper%E4%B8%8EDAO/</url>
    <content><![CDATA[<h1 id="MyBatis-实践-Mapper与DAO"><a href="#MyBatis-实践-Mapper与DAO" class="headerlink" title="MyBatis 实践  -Mapper与DAO"></a>MyBatis 实践  -Mapper与DAO</h1><p>标签： Java与存储</p>
<hr>
<h2 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h2><p><strong>MyBatis</strong>前身是<strong>iBatis</strong>,是一个基于Java的<strong>数据持久层/对象关系映射(ORM)框架</strong>. </p>
<p><img src="https://mybatis.org/images/mybatis-logo.png"></p>
<p> MyBatis是对JDBC的封装,使开发人员只需关注SQL本身,而不需花费过多的精力去处理如<strong>注册驱动</strong>、<strong>设置参数</strong>、<strong>创建<code>Connection</code>/<code>Statement</code>**、</strong>解析结果集**等JDBC过程性代码.MyBatis基于XML/注解的方式配置<code>Statement</code>,执行SQL,并将执行结果映射成Java对象, 大大降低了数据库开发的难度.</p>
<blockquote>
<p>MyBatis is a first class persistence framework with support for  custom SQL, stored procedures and advanced mappings. MyBatis eliminates  almost all of the JDBC code and manual setting of parameters and  retrieval of results. MyBatis can use simple XML or Annotations for  configuration and map primitives, Map interfaces and Java POJOs (Plain  Old Java Objects) to database records.<br> – MyBatis<a href="https://github.com/mybatis/mybatis-3">项目地址</a>/<a href="http://www.mybatis.org/mybatis-3/">在线文档</a>.</p>
</blockquote>
<hr>
<h2 id="初识MyBatis"><a href="#初识MyBatis" class="headerlink" title="初识MyBatis"></a>初识MyBatis</h2><p>使用MyBatis需要在pom.xml中添加如下依赖:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.0.16&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><ul>
<li>配置mybatis/<strong>mybatis-configuration.xml</strong><br> 作为MyBatis的全局配置文件,其配置了MyBatis的运行环境信息(如数据源/mapper文件等).</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;environments default&#x3D;&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class="line">            &lt;!-- 配置JDBC事务管理--&gt;</span><br><span class="line">            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;</span><br><span class="line">            &lt;!-- 配置数据源--&gt;</span><br><span class="line">            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;host:port&#x2F;db?characterEncoding&#x3D;utf-8&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;username&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;password&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;dataSource&gt;</span><br><span class="line">        &lt;&#x2F;environment&gt;</span><br><span class="line">    &lt;&#x2F;environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 加载mapper映射文件 --&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource&#x3D;&quot;mybatis&#x2F;mapper&#x2F;UserDAO.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>书写UserDAO(mapper映射)<br> 最为MyBatis最核心的部分,配置了操作数据库的<strong>SQL语句</strong>:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;namespace&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id&#x3D;&quot;selectUserById&quot; parameterType&#x3D;&quot;java.lang.Integer&quot; resultType&#x3D;&quot;com.fq.domain.User&quot;&gt;</span><br><span class="line">        SELECT * FROM user WHERE id &#x3D; #&#123;id&#125;;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id&#x3D;&quot;selectUserByName&quot; parameterType&#x3D;&quot;java.lang.String&quot; resultType&#x3D;&quot;com.fq.domain.User&quot;&gt;</span><br><span class="line">        SELECT * FROM user WHERE name LIKE &#39;%$&#123;value&#125;%&#39;;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>namespace</code></td>
<td>命名空间,用于隔离SQL语句</td>
</tr>
<tr>
<td><code>parameterType</code></td>
<td>定义SQL输入映射类型,MyBatis通过**<em>OGNL**</em>从输入对象中获取参数传入SQL语句.</td>
</tr>
<tr>
<td><code>resultType</code></td>
<td>定义SQL输出映射类型,MyBatis将SQL查询结果的<strong>一行记录</strong>映射为<code>resultType</code>指定的类型.</td>
</tr>
</tbody></table>
<blockquote>
<p>mapper映射文件名有<em>UserDAO.xml</em>/<em>UserMapper.xml</em>/<em>User.xml</em>等几种形式, 其一般存放在与mybatis-configuration.xml同级的mapper目录下,由于其主要作用为定义SQL语句与映射关系, 因此一般统称为**<em>mapper映射文件**</em>.</p>
</blockquote>
<ul>
<li>定义PO类<br> PO类主要作用为SQL(输入/输出)映射,通常与数据库表对应:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author zhanghao</span><br><span class="line"> * @since 15&#x2F;12&#x2F;31 下午2:27.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(Integer id, String name, String password) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39; &#39;&#39; +</span><br><span class="line">                &quot;, password&#x3D;&#39;&quot; + password + &#39; &#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserDAO(Java对象)<br> 获得SqlSession,执行SQL语句, 得到映射结果:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author zhanghao</span><br><span class="line"> * @since 16&#x2F;2&#x2F;24 下午6:15.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class UserDAO &#123;</span><br><span class="line"></span><br><span class="line">    private SqlSessionFactory factory;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() throws IOException &#123;</span><br><span class="line">        String resource &#x3D; &quot;mybatis&#x2F;mybatis-configuration.xml&quot;;</span><br><span class="line">        factory &#x3D; new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(resource));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void selectUserById() &#123;</span><br><span class="line">        try (SqlSession session &#x3D; factory.openSession()) &#123;</span><br><span class="line">            User user &#x3D; session.selectOne(&quot;namespace.selectUserById&quot;, 1);</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void selectUserByName() &#123;</span><br><span class="line">        try (SqlSession session &#x3D; factory.openSession()) &#123;</span><br><span class="line">            List&lt;User&gt; users &#x3D; session.selectList(&quot;namespace.selectUserByName&quot;, &quot;student&quot;);</span><br><span class="line">            for (User user : users) &#123;</span><br><span class="line">                System.out.println(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><ul>
<li>mapper</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;insert id&#x3D;&quot;insertUser&quot; parameterType&#x3D;&quot;com.fq.domain.User&quot;&gt;</span><br><span class="line">    INSERT INTO user(name, password) VALUES(#&#123;name&#125;, #&#123;password&#125;);</span><br><span class="line">&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserDAO</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void insertUser() &#123;</span><br><span class="line">    try (SqlSession session &#x3D; factory.openSession()) &#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setName(&quot;new_name1&quot;);</span><br><span class="line">        user.setPassword(&quot;new_password&quot;);</span><br><span class="line">        session.insert(&quot;namespace.insertUser&quot;, user);</span><br><span class="line">        session.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自增主键返回"><a href="#自增主键返回" class="headerlink" title="自增主键返回"></a>自增主键返回</h3><p>修改mapper文件,添加<selectKey>,可以将MySQL的自增主键(即刚刚插入数据时生成的ID)返回:</selectKey></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;insert id&#x3D;&quot;insertUser&quot; parameterType&#x3D;&quot;com.fq.domain.User&quot;&gt;</span><br><span class="line">    &lt;selectKey keyProperty&#x3D;&quot;id&quot; order&#x3D;&quot;AFTER&quot; resultType&#x3D;&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">        SELECT LAST_INSERT_ID();</span><br><span class="line">    &lt;&#x2F;selectKey&gt;</span><br><span class="line">    INSERT INTO user(name, password) VALUES(#&#123;name&#125;, #&#123;password&#125;);</span><br><span class="line">&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>keyProperty</code></td>
<td>指定存储到DO中的哪个属性;</td>
</tr>
<tr>
<td><code>order</code></td>
<td><code>selectKey</code>执行顺序(相对于<code>insert</code>语句),<code>AFTER</code>/<code>BEFORE</code>;</td>
</tr>
<tr>
<td><code>resultType</code></td>
<td>主键返回类型(DO中对应属性的类型);</td>
</tr>
<tr>
<td><code>LAST_INSERT_ID()</code></td>
<td>MySQL函数,返回**<em>auto_increment **</em>自增列新记录值.</td>
</tr>
</tbody></table>
<ul>
<li>UserDAO</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void insertUser() &#123;</span><br><span class="line">    try (SqlSession session &#x3D; factory.openSession()) &#123;</span><br><span class="line">        System.out.println(session);</span><br><span class="line">        User user &#x3D; new User(null, &quot;new_name&quot;, &quot;new_password&quot;);</span><br><span class="line">        session.insert(&quot;namespace.insertUser&quot;, user);</span><br><span class="line">        &#x2F;&#x2F; 需要在commit之后才能获得自增主键</span><br><span class="line">        session.commit();</span><br><span class="line">        System.out.println(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该功能还可以通过<insert>的useGeneratedKeys/keyProperty两个属性合作完成, 详见<a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#insert_update_and_delete">MyBatis文档</a>.</insert></p>
</blockquote>
<hr>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><ul>
<li>mapper</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;update id&#x3D;&quot;updateUserById&quot; parameterType&#x3D;&quot;com.fq.domain.User&quot;&gt;</span><br><span class="line">    UPDATE user SET name &#x3D; #&#123;name&#125;, password &#x3D; #&#123;password&#125; WHERE id &#x3D; #&#123;id&#125;;</span><br><span class="line">&lt;&#x2F;update&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserDAO</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void updateUserById() &#123;</span><br><span class="line">    try (SqlSession session &#x3D; factory.openSession(true)) &#123;</span><br><span class="line">        session.update(&quot;namespace.updateUserById&quot;,</span><br><span class="line">                new User(1, &quot;feiqing&quot;, &quot;ICy5YqxZB1uWSwcVLSNLcA&#x3D;&#x3D;&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;1234567</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><ul>
<li>mapper</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;delete id&#x3D;&quot;deleteUserById&quot; parameterType&#x3D;&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">    DELETE FROM user WHERE id &#x3D; #&#123;id&#125;;</span><br><span class="line">&lt;&#x2F;delete&gt;123</span><br></pre></td></tr></table></figure>

<ul>
<li>UserDAO</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void deleteUserById() &#123;</span><br><span class="line">    try (SqlSession session &#x3D; factory.openSession(true)) &#123;</span><br><span class="line">        session.delete(&quot;namespace.deleteUserById&quot;, 51615);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><code>#&#123;&#125;</code>/<code>$&#123;&#125;</code><ul>
<li><code>#&#123;&#125;</code>: 表示一个占位符号,实现向<code>PreparedStatement</code>占位符中设置值(<code>#&#123;&#125;</code>表示一个占位符<code>?</code>),自动进行Java类型到JDBC类型的转换(因此<code>#&#123;&#125;</code>可以有效防止SQL注入).<code>#&#123;&#125;</code>可以接收简单类型或PO属性值,如果<code>parameterType</code>传输的是单个简单类型值,<code>#&#123;&#125;</code>花括号中可以是<code>value</code>或其它名称.</li>
<li><code>$&#123;&#125;</code>: 表示拼接SQL串,通过<code>$&#123;&#125;</code>可将<code>parameterType</code>内容**<em>拼接**</em>在SQL中而<em>不进行JDBC类型转换</em>,<code>$&#123;&#125;</code>可以接收简单类型或PO属性值,如果<code>parameterType</code>传输的是单个简单类型值,<code>$&#123;&#125;</code>花括号中只能是<code>value</code>.<br> 虽然<code>$&#123;&#125;</code>不能防止SQL注入,但有时<code>$&#123;&#125;</code>会非常方便(如<code>order by</code>排序,需要将列名通过参数传入SQL,则用<code>ORDER BY $&#123;column&#125;</code>,使用<code>#&#123;&#125;</code>则无法实现此功能(详见<a href="http://blog.csdn.net/zjf280441589/article/details/50714873">JDBC基础</a>关于<code>PreparedStatement</code>的讨论).</li>
</ul>
</li>
<li><code>SqlSession</code><br> 提供操作数据库的方法(如:<code>selectOne</code>/<code>selectList</code>).但<code>SqlSession</code>是线程不安全的,因此最好将其定义成局部变量使用.</li>
<li>MyBatis优点(与JDBC相比) <ul>
<li>SQL写在Java代码中导致不易维护, 而MyBatis将SQL写在mapper中,XML与Java代码分离.</li>
<li>向SQL语句传参繁琐(如:SQL的<strong>where条件</strong>不一,SQL数据类型与Java不同),MyBatis通过<code>parameterType</code>自动将Java对象映射至SQL语句.</li>
<li>结果集解析麻烦(SQL变化导致解析代码变化,SQL数据类型与Java不同),MyBatis通过<code>resultType</code>自动将SQL执行结果映射成Java对象.</li>
</ul>
</li>
</ul>
<hr>
<p>附: 最好在pom.xml中添加一个日志系统实现(logback/log4j), 这样会在调试程序时打印日志信息,便于查错, 以logback为例:</p>
<ul>
<li>pom.xml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;ch.qos.logback&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;logback-classic&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>logback.xml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name&#x3D;&quot;logRoot&quot; value&#x3D;&quot;&#x2F;data&#x2F;logs&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;pattern&quot; value&#x3D;&quot;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;0&#125; - %msg%n&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;appender name&#x3D;&quot;STDOUT&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;$&#123;pattern&#125;&lt;&#x2F;pattern&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;FILE&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;logRoot&#125;&#x2F;common-server.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;fileNamePattern&gt;</span><br><span class="line">            &lt;maxHistory&gt;7&lt;&#x2F;maxHistory&gt;</span><br><span class="line">        &lt;&#x2F;rollingPolicy&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;$&#123;pattern&#125;&lt;&#x2F;pattern&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;root level&#x3D;&quot;DEBUG&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;STDOUT&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;FILE&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;root&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其他关于MyBatis日志的详细信息可参考<a href="http://www.mybatis.org/mybatis-3/zh/logging.html">MyBatis文档日志部分</a>.</p>
</blockquote>
<hr>
<h2 id="DAO开发"><a href="#DAO开发" class="headerlink" title="DAO开发"></a>DAO开发</h2><p>使用MyBatis开发DAO有两个方法,<strong>原始DAO开发</strong>与<strong>Mapper映射DAO开发</strong>.</p>
<hr>
<h3 id="原始DAO开发"><a href="#原始DAO开发" class="headerlink" title="原始DAO开发"></a>原始DAO开发</h3><p>原始DAO开发需要开发人员编写<strong>DAO接口</strong>与<strong>DAO实现</strong>,如根据ID查询用户信息:</p>
<ul>
<li>mapper(同前)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectUserById&quot; parameterType&#x3D;&quot;java.lang.Integer&quot; resultType&#x3D;&quot;com.fq.domain.User&quot;&gt;</span><br><span class="line">    SELECT * FROM user WHERE id &#x3D; #&#123;id&#125;;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserDAO接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author zhanghao</span><br><span class="line"> * @since 16&#x2F;2&#x2F;22 上午10:20.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface UserDAO &#123;</span><br><span class="line">    User selectUserById(Integer id) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserDAO实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserDAOImpl implements UserDAO &#123;</span><br><span class="line"></span><br><span class="line">    private SqlSessionFactory factory;</span><br><span class="line"></span><br><span class="line">    public UserDAOImpl(SqlSessionFactory factory) &#123;</span><br><span class="line">        this.factory &#x3D; factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public User selectUserById(Integer id) throws Exception &#123;</span><br><span class="line">        SqlSession session &#x3D; factory.openSession();</span><br><span class="line">        User user &#x3D; session.selectOne(&quot;namespace.selectUserById&quot;, id);</span><br><span class="line">        session.close();</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Client</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyBatisClient &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void originalClient() throws Exception &#123;</span><br><span class="line">        UserDAO dao &#x3D; new UserDAOImpl(new SqlSessionFactoryBuilder().</span><br><span class="line">                build(ClassLoader.getSystemResourceAsStream(&quot;mybatis&#x2F;mybatis-configuration.xml&quot;)));</span><br><span class="line">        User user &#x3D; dao.selectUserById(1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原始DAO开发中存在的问题: <ol>
<li>DAO实现方法体中存在很多过程性代码. </li>
<li>调用<code>SqlSession</code>的方法(<code>select</code>/<code>insert</code>/<code>update</code>)需要指定<em>Statement</em>的id,存在硬编码,不利于代码维护.</li>
</ol>
</li>
</ul>
<hr>
<h3 id="Mapper映射开发"><a href="#Mapper映射开发" class="headerlink" title="Mapper映射开发"></a>Mapper映射开发</h3><p>mapper映射开发方法只需编写DAO接口,MyBatis根据接口定义与mapper文件中的SQL语句动态创建接口实现.</p>
<ul>
<li>mapper</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.fq.mybatis.UserDAO&quot;&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;selectUserById&quot; parameterType&#x3D;&quot;java.lang.Integer&quot; resultType&#x3D;&quot;com.fq.domain.User&quot;&gt;</span><br><span class="line">        SELECT * FROM user WHERE id &#x3D; #&#123;id&#125;;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 此时<code>namespace</code>必须与<code>UserDAO</code>接口的全限定名相同.</p>
</blockquote>
<ul>
<li>UserDAO接口与前面相同, 但不再使用<code>UserDAOImpl</code></li>
<li>Client</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author zhanghao</span><br><span class="line"> * @since 16&#x2F;2&#x2F;22 下午2:57.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyBatisClient &#123;</span><br><span class="line"></span><br><span class="line">    private SqlSession session;</span><br><span class="line"></span><br><span class="line">    private SqlSessionFactory factory;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() &#123;</span><br><span class="line">        factory &#x3D; new SqlSessionFactoryBuilder().</span><br><span class="line">                build(ClassLoader.getSystemResourceAsStream(&quot;mybatis&#x2F;mybatis-configuration.xml&quot;));</span><br><span class="line">        session &#x3D; factory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void mapperClient() throws Exception &#123;</span><br><span class="line">        UserDAO dao &#x3D; session.getMapper(UserDAO.class);</span><br><span class="line">        User user &#x3D; dao.selectUserById(1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After</span><br><span class="line">    public void tearDown() &#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>mapper映射开发方法需要遵循以下规范: <ol>
<li>mapper文件中的namespace与DAO接口的全限定名相同;</li>
<li>mapper文件中的<em>Statement</em>的id与DAO接口方法名相同;</li>
<li>mapper文件中的<em>Statement</em>的<code>parameterType</code>/<code>resultType</code>与DAO方法的入参/回参类型相同.</li>
</ol>
</li>
</ul>
</blockquote>
<hr>
<h2 id="Mapper映射"><a href="#Mapper映射" class="headerlink" title="Mapper映射"></a>Mapper映射</h2><p>mapper映射文件(如UserDAO.xml)主要作用是定义SQL语句(每个SQL是一个<em>Statement</em>),是MyBatis的核心.</p>
<blockquote>
<p>MyBatis官方推荐使用mapper映射的方法来开发DAO,因此我们以后就不再过多介绍原始DAO的开发.</p>
</blockquote>
<hr>
<h3 id="输入映射"><a href="#输入映射" class="headerlink" title="输入映射"></a>输入映射</h3><h4 id="多个形参"><a href="#多个形参" class="headerlink" title="多个形参"></a>多个形参</h4><p>传递简单类型前面示例已经使用过,在此就不再赘述.当需要传递多个形参时,不再需要设置<code>parameterType</code>参数:</p>
<ul>
<li>mapper</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;update id&#x3D;&quot;updateUserById&quot;&gt;</span><br><span class="line">    UPDATE user SET name &#x3D; #&#123;1&#125;, password &#x3D; #&#123;2&#125; WHERE id &#x3D; #&#123;0&#125;;</span><br><span class="line">&lt;&#x2F;update&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserDAO</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void updateUserById(Integer id, String name, String password) throws Exception;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="传入PO"><a href="#传入PO" class="headerlink" title="传入PO"></a>传入PO</h4><p>MyBatis使用<strong>OGNL</strong>表达式解析对象属性值:</p>
<ul>
<li>mapper</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectUserByNamePassword&quot; parameterType&#x3D;&quot;com.fq.domain.User&quot; resultType&#x3D;&quot;com.fq.domain.User&quot;&gt;</span><br><span class="line">    SELECT *</span><br><span class="line">    FROM user</span><br><span class="line">    WHERE name &#x3D; #&#123;name&#125; AND password &#x3D; #&#123;password&#125;;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserDAO</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User selectUserByNamePassword(User user) throws Exception;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="传入Map"><a href="#传入Map" class="headerlink" title="传入Map"></a>传入Map</h4><ul>
<li>mapper</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectUserByMap&quot; parameterType&#x3D;&quot;java.util.Map&quot; resultType&#x3D;&quot;com.fq.domain.User&quot;&gt;</span><br><span class="line">    SELECT *</span><br><span class="line">    FROM user</span><br><span class="line">    WHERE name &#x3D; #&#123;name&#125; AND password &#x3D; #&#123;password&#125;;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>#&#123;&#125;</code>花括号内对应<code>Map</code>的<code>key</code>.</p>
</blockquote>
<ul>
<li>UserDAO</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User selectUserByMap(Map&lt;String, Object&gt; map) throws Exception;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="输出映射"><a href="#输出映射" class="headerlink" title="输出映射"></a>输出映射</h3><h4 id="输出简单类型"><a href="#输出简单类型" class="headerlink" title="输出简单类型"></a>输出简单类型</h4><ul>
<li>mapper</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectUserCount&quot; parameterType&#x3D;&quot;java.lang.String&quot; resultType&#x3D;&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">    SELECT count(*)</span><br><span class="line">    FROM user</span><br><span class="line">    WHERE name LIKE &#39;%$&#123;value&#125;%&#39;;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserDAO</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer selectUserCount(String name) throws Exception;1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回简单类型必须保证**<em>查询结果只有一行记录 **</em>,最终将第一个字段的值转换为输出类型.</p>
</blockquote>
<hr>
<h4 id="输出PO对象-列表"><a href="#输出PO对象-列表" class="headerlink" title="输出PO对象/列表"></a>输出PO对象/列表</h4><ul>
<li><p>前面已经演示过输出两种类型(  <code> selectUserById </code>  /<code>  selectUserByName</code>  虽然当时使用的是原始DAO开发方法, 但mapper定义形式大同小异),因此在这儿只做简单总结: </p>
<ol>
<li>输出单个PO对象和输出PO列表在mapper中定义的<code>resultType</code>是一样的;</li>
<li>输出单个PO对象要保证SQL查询结果为单条数据,其内部使用<code>selectOne</code>方法调用;</li>
<li>输出PO列表表示<strong>查询结果可能为多条</strong>,其内部使用<code>selectList</code>方法调用,接口返回值可用<code>List</code>/<code>Set</code>承载.</li>
</ol>
</li>
</ul>
<hr>
<h4 id="输出Map"><a href="#输出Map" class="headerlink" title="输出Map"></a>输出Map</h4><p>输出PO对象完全可以改用<code>Map</code>输出,<strong>字段名作key,字段值作value</strong>.</p>
<ul>
<li>mapper</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectUserLikeName&quot; resultType&#x3D;&quot;java.util.Map&quot;&gt;</span><br><span class="line">    SELECT *</span><br><span class="line">    FROM user</span><br><span class="line">    WHERE name LIKE &#39;%$&#123;value&#125;%&#39;;</span><br><span class="line">&lt;&#x2F;select&gt;12345</span><br></pre></td></tr></table></figure>

<ul>
<li>UserDAO</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; selectUserLikeName(String name) throws Exception;1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h3><p><code>resultType</code>可将查询结果映射为PO,但前提是<strong>PO属性名</strong>与<strong>SQL字段名</strong>必须一致,如不一致,则可通过<code>resultMap</code>作对应映射:</p>
<ul>
<li>mapper</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id&#x3D;&quot;userMap&quot; type&#x3D;&quot;com.fq.domain.User&quot;&gt;</span><br><span class="line">    &lt;id column&#x3D;&quot;user_id&quot; property&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">    &lt;result column&#x3D;&quot;user_name&quot; property&#x3D;&quot;name&quot;&#x2F;&gt;</span><br><span class="line">    &lt;result column&#x3D;&quot;user_password&quot; property&#x3D;&quot;password&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;selectUserByName&quot; parameterType&#x3D;&quot;java.lang.String&quot; resultMap&#x3D;&quot;userMap&quot;&gt;</span><br><span class="line">    SELECT</span><br><span class="line">        id       user_id,</span><br><span class="line">        name     user_name,</span><br><span class="line">        password user_password</span><br><span class="line">    FROM user</span><br><span class="line">    WHERE name &#x3D; #&#123;name&#125;;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>表示查询结果集的唯一标识;</td>
</tr>
<tr>
<td><code>result</code></td>
<td>表示普通结果,即PO属性;</td>
</tr>
<tr>
<td><code>column</code></td>
<td>表示SQL查询出来的字段名,</td>
</tr>
<tr>
<td><code>property</code></td>
<td>表示PO属性.</td>
</tr>
</tbody></table>
<ul>
<li>UserDAO接口同前.</li>
</ul>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>【深度学习理论与实战】python基础</title>
    <url>/2020/12/04/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%91python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><a href="http://localhost:8888/tree?token=e6e13df7c7ef8cc8bed27f46c0e599cad61d7cb278a4bc7b">       <img src="http://localhost:8888/static/base/images/logo.png?v=641991992878ee24c6f3826e81054a0f" alt="Jupyter Notebook">   </a></p>
<p>​        </p>
<p>老师是做NLP 语义理解的。  NLP5年从业者，大厂经历。 Bert是现在先进的常用的方法。 有的时候项目中，实时性的要求高。 C++ 在解决这个领域实时性更好。 如果从事数据行业，数据Python语言就够了， 但是如果想 搜索等 算法工作 就要掌握C++ C等语言。</p>
<h1 id="一、什么是python？"><a href="#一、什么是python？" class="headerlink" title="一、什么是python？"></a>一、什么是python？</h1><p>python是一种面向对象、解释型的计算机语言，它的特点是语法简洁、优雅、简单易学。在1989诞生，Guido(龟叔)开发。</p>
<h1 id="二、解释型语言和编译型语言"><a href="#二、解释型语言和编译型语言" class="headerlink" title="二、解释型语言和编译型语言"></a>二、解释型语言和编译型语言</h1><p>编译型语言就是先把写好的程序翻译成计算机语言然后执行，就是所谓的“一次编译，到处运行“，比如c、c++就是编译型语言，这样的语言特点是运行效率高，但是需要事先把程序编译好才可以。<br> 解释型语言就是程序在运行的时候，通过一个解释器，把代码一句一句的翻译成计算机语言然后运行，比如说python、shell等，这样的语言由于原理不一样，执行速度没有编译型语言快。</p>
<h1 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h1><p>变量是一段有名字的连续存储空间。当定义变量的时候，会在内存中申请一块空间专门用来存放变量值，变量名则是为了能找到这块内存空间。</p>
<p>python中定义变量，直接用等号即可，不需要指定数据类型，直接定义就ok</p>
<h2 id="3-1变量命名规则"><a href="#3-1变量命名规则" class="headerlink" title="3.1变量命名规则"></a>3.1变量命名规则</h2><p>需要使用标识符给变量命名，你可以理解为，标识符就是合法的名字。可以用于给程序中变量、类、方法命名的符号。<br> 命名规范：<br> 1.可以由字母、数字、下画线（_）组成，其中数字不能打头<br> 2.不能是 Python 关键字，但可以包含关键字。<br> 3.不能包含空格。</p>
<h4 id="比如："><a href="#比如：" class="headerlink" title="比如："></a>比如：</h4><p>a_xyz：合法<br> HelloWorld：合法<br> xyz#abc：不合法，标识符中不允许出现“#”号<br> bc：合法<br> c1：合法<br> 1ac：不合法，标识符不允许数字开头</p>
<h2 id="3-2变量的类型"><a href="#3-2变量的类型" class="headerlink" title="3.2变量的类型"></a>3.2变量的类型</h2><h3 id="3-2-1-数字型"><a href="#3-2-1-数字型" class="headerlink" title="3.2.1 数字型"></a>3.2.1 数字型</h3><p>整型 (int)<br> 浮点型（float）<br> 布尔型（bool）      真 True, 假 False<br> 复数型: 主要用于科学计算。例如：complex(1, 2)。 平面场问题、波动问题、电感电容等问题</p>
<h3 id="3-2-2-非数字型"><a href="#3-2-2-非数字型" class="headerlink" title="3.2.2 非数字型"></a>3.2.2 非数字型</h3><p>字符串 列表 元组 字典 集合 数组  …</p>
<h4 id="1）字符串"><a href="#1）字符串" class="headerlink" title="1）字符串"></a>1）字符串</h4><p>序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。<br> 序列都可以进行的操作包括索引，切片，添加成员等操作。<br> 此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &#39;hello world!&#39;</span><br><span class="line">#1 索引:第一个索引是0，第二个索引是1，依此类推</span><br><span class="line">s[0] #取第一个字符</span><br><span class="line">s[-1] #取最后一位字符</span><br><span class="line">&#39;!&#39;</span><br><span class="line">#2 切片：从第三位开始取 剩下的字符串，python语言，索引0代表第一位。</span><br><span class="line">s[2:]</span><br><span class="line">&#39;llo world!&#39;</span><br><span class="line">#3 字符串拼接</span><br><span class="line">s[0] + s[-1] #取第一位字符 与 最后一位字符 相加，字符相加&#x2F;字符串相加</span><br><span class="line">&#39;h!&#39;</span><br><span class="line">#4 字符串最大值 与 最小值</span><br><span class="line">max(s), min(s)</span><br><span class="line">(&#39;w&#39;, &#39; &#39;)</span><br><span class="line">#5 字符串排序</span><br><span class="line">#sorted(list(s))</span><br></pre></td></tr></table></figure>

<h4 id="2）列表"><a href="#2）列表" class="headerlink" title="2）列表"></a>2）列表</h4><p>列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。<br> 列表的数据项不需要具有相同的类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1 定义</span><br><span class="line">l1 &#x3D; [&#39;a&#39;, &#39;bv&#39;, 456, 2000]</span><br><span class="line">l2 &#x3D; [1, 2, 3, 4, 5, 6, 7 ]</span><br><span class="line">print (l1,l2)</span><br><span class="line">[&#39;a&#39;, &#39;bv&#39;, 456, 2000] [1, 2, 3, 4, 5, 6, 7]</span><br><span class="line">#1 索引:第一个索引是0，第二个索引是1，依此类推</span><br><span class="line">l1[0], l2[-1]</span><br><span class="line">(&#39;a&#39;, 7)</span><br><span class="line">#2 切片：从第三位开始取 剩下的所有元素，索引0代表第一位。</span><br><span class="line">l1[2:]</span><br><span class="line">[456, 2000]</span><br><span class="line">#3 字符串最大值 与 最小值， 当list中 同时存在 多种类型的时候，无法判断</span><br><span class="line">max(l2), min(l2)</span><br><span class="line">(7, 1)</span><br><span class="line">#4 更新列表</span><br><span class="line">s &#x3D; [&#39;a&#39;,&#39;4&#39;,5]</span><br><span class="line">s.append(99)</span><br><span class="line">print (s)</span><br><span class="line">#列表可以从前面加元素  [bbb]+s</span><br><span class="line">[&#39;a&#39;, &#39;4&#39;, 5, 99]</span><br><span class="line">#5 删除列表元素</span><br><span class="line">s &#x3D; [&#39;a&#39;,&#39;4&#39;,5]</span><br><span class="line">del s[0]</span><br><span class="line">print (s)</span><br><span class="line">[&#39;4&#39;, 5]</span><br><span class="line">s &#x3D; [1,2,3,2,2]</span><br><span class="line">s.count(2)</span><br><span class="line">3</span><br><span class="line">#6 其他操作</span><br><span class="line"></span><br><span class="line">len([1, 2, 3]) #计算列表长度</span><br><span class="line"></span><br><span class="line">[1, 2, 3] + [4, 5, 6] #列表组合</span><br><span class="line"></span><br><span class="line">[&#39;Hi!&#39;] * 4 #重复</span><br><span class="line"></span><br><span class="line">3 in [1, 2, 3] #判断元素是否存在于列表中</span><br><span class="line"></span><br><span class="line"># 迭代</span><br><span class="line">for x in [1, 2, 3]:</span><br><span class="line">    print (x)</span><br><span class="line">    </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h4 id="3）元组"><a href="#3）元组" class="headerlink" title="3）元组"></a>3）元组</h4><p>Python的元组与列表类似，不同之处在于元组的元素不能修改。<br> 元组使用小括号，列表使用方括号。<br> 元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1 定义</span><br><span class="line">tup1 &#x3D; (50,)</span><br><span class="line">#（39，） 才是元组， （30）不是元组。 </span><br><span class="line">tup1[0]</span><br><span class="line">50</span><br><span class="line">#2 不允许修改元素，列表是可以修改元素的</span><br><span class="line">tup2 &#x3D; (50,4,6,7)</span><br><span class="line">tup2 &#x3D; [50,4,6,7]</span><br><span class="line">tup2[0]</span><br><span class="line">#3 元组相加</span><br><span class="line">tup1 &#x3D; (12, 34.56)</span><br><span class="line">tup2 &#x3D; (&#39;abc&#39;, &#39;xyz&#39;)</span><br><span class="line"></span><br><span class="line"># 创建一个新的元组</span><br><span class="line">tup1 + tup2</span><br><span class="line">(12, 34.56, &#39;abc&#39;, &#39;xyz&#39;)</span><br><span class="line">#4 其他操作</span><br><span class="line"></span><br><span class="line">len( (1, 2, 3) ) #计算元组长度</span><br><span class="line"></span><br><span class="line">(1, 2, 3) + (4, 5, 6) #元组组合</span><br><span class="line"></span><br><span class="line">(&#39;Hi!&#39;) * 4 #重复</span><br><span class="line"></span><br><span class="line">3 in (1, 2, 3) #判断元素是否存在于元组中</span><br><span class="line"></span><br><span class="line"># 迭代</span><br><span class="line">for x in (1, 2, 3):</span><br><span class="line">    print (x)</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h4 id="4）字典"><a href="#4）字典" class="headerlink" title="4）字典"></a>4）字典</h4><p>字典是另一种可变容器模型，且可存储任意类型对象。<br> 字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示：<br> d = {key1 : value1, key2 : value2 }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1 定义</span><br><span class="line">d &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;b&#39;: &#39;3&#39;&#125;</span><br><span class="line">d[&#39;a&#39;]</span><br><span class="line">1</span><br><span class="line">#2 字典的更新与添加</span><br><span class="line">d &#x3D; &#123;&#39;name&#39;: &#39;lili&#39;, &#39;age&#39;: 7, &#39;class&#39;: &#39;First&#39;&#125;</span><br><span class="line"></span><br><span class="line">d[&#39;age&#39;] &#x3D; 10 # 更新</span><br><span class="line">d[&#39;school&#39;] &#x3D; &quot;RUNOOB&quot; # 添加</span><br><span class="line">print (d)</span><br><span class="line">&#123;&#39;name&#39;: &#39;lili&#39;, &#39;age&#39;: 10, &#39;class&#39;: &#39;First&#39;, &#39;school&#39;: &#39;RUNOOB&#39;&#125;</span><br><span class="line">del d[&#39;name&#39;]  # 删除键是&#39;Name&#39;的条目</span><br><span class="line">print (d)</span><br><span class="line">&#123;&#39;age&#39;: 10, &#39;class&#39;: &#39;First&#39;, &#39;school&#39;: &#39;RUNOOB&#39;&#125;</span><br><span class="line">d.clear()      # 清空字典所有条目</span><br><span class="line">print (d)</span><br><span class="line">&#123;&#125;</span><br><span class="line"># 以列表返回可遍历的(键, 值) 元组数组</span><br><span class="line">d &#x3D; &#123;&#39;name&#39;: &#39;lili&#39;, &#39;age&#39;: 7, &#39;class&#39;: &#39;First&#39;&#125;</span><br><span class="line">d.items()</span><br><span class="line">dict_items([(&#39;name&#39;, &#39;lili&#39;), (&#39;age&#39;, 7), (&#39;class&#39;, &#39;First&#39;)])</span><br><span class="line">for i in d:</span><br><span class="line">    print (i,d[i])</span><br><span class="line">    # 单纯取字典，取的是key。 </span><br><span class="line">name lili</span><br><span class="line">age 7</span><br><span class="line">class First</span><br></pre></td></tr></table></figure>

<h4 id="5）集合"><a href="#5）集合" class="headerlink" title="5）集合"></a>5）集合</h4><p>集合（set）是一个 <strong>无序的不重复</strong>元素序列。<br> 可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1 集合创建</span><br><span class="line">set([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])</span><br><span class="line">&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;</span><br><span class="line">set(&#39;abr&#39;)</span><br><span class="line">&#123;&#39;a&#39;, &#39;b&#39;, &#39;r&#39;&#125;</span><br><span class="line">&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;</span><br><span class="line">&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;</span><br><span class="line">#2 基本操作</span><br><span class="line"></span><br><span class="line">#2-1 添加元素</span><br><span class="line">s &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;</span><br><span class="line">s.add(&quot;Facebook&quot;)</span><br><span class="line">print (s)</span><br><span class="line"></span><br><span class="line">#2-2 移除元素</span><br><span class="line">s.remove(&quot;Facebook&quot;)</span><br><span class="line">print (s)</span><br><span class="line"></span><br><span class="line">#2-3 清空集合</span><br><span class="line">s.clear()</span><br><span class="line">print (s)</span><br><span class="line"></span><br><span class="line">#2-4 判断元素是否在集合中存在</span><br><span class="line"></span><br><span class="line">&#123;&#39;b&#39;, &#39;Facebook&#39;, &#39;c&#39;, &#39;a&#39;&#125;</span><br><span class="line">&#123;&#39;b&#39;, &#39;c&#39;, &#39;a&#39;&#125;</span><br><span class="line">set()</span><br><span class="line">#2-5  返回集合的交集</span><br><span class="line">#A，B是两个集合，由所有属于集合A且属于集合B的元素所组成的集合，叫做集合A与集合B的交集（intersection），记作A∩B</span><br><span class="line">&#123;&#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;Facebook&#39;&#125; &amp; &#123;&#39;c&#39;, &#39;a&#39;, &#39;b&#39;&#125; </span><br><span class="line">&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;</span><br><span class="line">#2-6  返回集合的并集</span><br><span class="line"># 给定两个集合A，B，把他们所有的元素合并在一起组成的集合，叫做集合A与集合B的并集，记作A∪B</span><br><span class="line">&#123;&#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;Facebook&#39;&#125; | &#123;&#39;c&#39;, &#39;a&#39;, &#39;b&#39;&#125; </span><br><span class="line">&#123;&#39;Facebook&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;</span><br><span class="line">#2-7 差集</span><br><span class="line">&#123;&#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;Facebook&#39;&#125; - &#123;&#39;c&#39;, &#39;a&#39;, &#39;b&#39;&#125;</span><br><span class="line">&#123;&#39;Facebook&#39;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6）数组"><a href="#6）数组" class="headerlink" title="6）数组"></a>6）数组</h4><p>数组与列表相同点:<br> 都可以根据索引来取其中的元素<br> 数组和张量可以互换。张量是网络的底子 </p>
<p>数组与列表区别:<br> a.列表list中的元素的数据类型可以不一样。数组array里的元素的数据类型必须一样；<br> b.列表list不可以进行数学四则运算，数组array可以进行数学四则运算；<br> c.相对于array，列表会使用更多的存储空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">#1 定义一维数组</span><br><span class="line">np.array( [1,2,4,5,6] )</span><br><span class="line">array([1, 2, 4, 5, 6])</span><br><span class="line">#2 定义2*3二维数组</span><br><span class="line">np.array( [ [1,2,3] , [3,4,5] ] )</span><br><span class="line">array([[1, 2, 3],</span><br><span class="line">       [3, 4, 5]])</span><br><span class="line">#3 四则运算</span><br><span class="line">np.array( [1,2,4,5,6] ) + 3</span><br><span class="line">array([4, 5, 7, 8, 9])</span><br><span class="line">np.array( [ [1,2,3] , [3,4,5] ] ) + 2</span><br><span class="line">array([[3, 4, 5],</span><br><span class="line">       [5, 6, 7]])</span><br><span class="line">np.array( [ [1,2,3] , [3,4,5] ] ) + [[2],[10]]</span><br><span class="line">array([[ 3,  4,  5],</span><br><span class="line">       [13, 14, 15]])</span><br></pre></td></tr></table></figure>

<h2 id="课堂小测试"><a href="#课堂小测试" class="headerlink" title="课堂小测试"></a>课堂小测试</h2><p>对下面定义的列表进行排序，s = [4,6,12,3,1], 从小到大，返回排序后的列表.<br> output = [1, 3, 4, 6, 12]</p>
<p>提到了预训练，  我用别人学习好的东西拿来用，我只需要做个微调即可。 数据处理，分析，转换，构建模型（设计模型:要明白cnn模型，Rnn模型。）</p>
<p>很值得，老师经常会说文本的处理。NLP 牛逼。</p>
<h1 id="四、python常用包及功能介绍"><a href="#四、python常用包及功能介绍" class="headerlink" title="四、python常用包及功能介绍"></a>四、python常用包及功能介绍</h1><h2 id="4-1-NumPy"><a href="#4-1-NumPy" class="headerlink" title="4.1 NumPy"></a>4.1 NumPy</h2><h3 id="什么是-NumPy？"><a href="#什么是-NumPy？" class="headerlink" title="什么是 NumPy？"></a>什么是 NumPy？</h3><p> NumPy 是用于处理数组的 python 库。是Python进行科学计算的基础包。<br> 它还拥有在线性代数、傅立叶变换和矩阵领域中工作的函数。<br> NumPy 由 Travis Oliphant 于 2005 年创建。它是一个开源项目，您可以自由使用它。<br> NumPy 指的是数值 Python（Numerical Python）。</p>
<h3 id="为何使用-NumPy？"><a href="#为何使用-NumPy？" class="headerlink" title="为何使用 NumPy？"></a>为何使用 NumPy？</h3><p> 在 Python 中，我们有满足数组功能的列表，但是处理起来很慢。<br> NumPy 旨在提供一个比传统 Python 列表快 50 倍的数组对象。<br> NumPy 中的数组对象称为 ndarray，它提供了许多支持函数，使得利用 ndarray 非常容易。<br> 数组在数据科学中非常常用，因为速度和资源非常重要。<br> 数据科学：计算机科学的一个分支，研究如何存储、使用和分析数据以从中获取信息。</p>
<h3 id="NumPy-用哪种语言编写？"><a href="#NumPy-用哪种语言编写？" class="headerlink" title="NumPy 用哪种语言编写？"></a>NumPy 用哪种语言编写？</h3><p> NumPy 是一个 Python 库，部分用 Python 编写，但是大多数需要快速计算的部分都是用 C 或 C ++ 编写的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"># 传入元祖，定义一个 6*3数组，元素是0-1随机浮点数</span><br><span class="line">x &#x3D; np.random.random( (6,3) )</span><br><span class="line">x</span><br><span class="line">array([[0.93036869, 0.36344013, 0.40994415],</span><br><span class="line">       [0.76242106, 0.55727401, 0.58451496],</span><br><span class="line">       [0.23535283, 0.46414574, 0.422967  ],</span><br><span class="line">       [0.57995231, 0.33819452, 0.66144957],</span><br><span class="line">       [0.77789209, 0.01100769, 0.00724789],</span><br><span class="line">       [0.81898849, 0.79222986, 0.61005305]])</span><br><span class="line">x.ndim #ndarray维度</span><br><span class="line">2</span><br><span class="line">x.shape #形状</span><br><span class="line">(6, 3)</span><br><span class="line">x.size  #元素个数</span><br><span class="line">18</span><br><span class="line">x.itemsize #每个元素占字节数</span><br><span class="line">8</span><br><span class="line"># 数组形状转换</span><br><span class="line">x.shape &#x3D; (2,9)</span><br><span class="line">x</span><br><span class="line">array([[0.93036869, 0.36344013, 0.40994415, 0.76242106, 0.55727401,</span><br><span class="line">        0.58451496, 0.23535283, 0.46414574, 0.422967  ],</span><br><span class="line">       [0.57995231, 0.33819452, 0.66144957, 0.77789209, 0.01100769,</span><br><span class="line">        0.00724789, 0.81898849, 0.79222986, 0.61005305]])</span><br><span class="line">x.reshape(9,-1)# 用-1 让计算机自己计算另一个维度。</span><br><span class="line">array([[0.93036869, 0.36344013],</span><br><span class="line">       [0.40994415, 0.76242106],</span><br><span class="line">       [0.55727401, 0.58451496],</span><br><span class="line">       [0.23535283, 0.46414574],</span><br><span class="line">       [0.422967  , 0.57995231],</span><br><span class="line">       [0.33819452, 0.66144957],</span><br><span class="line">       [0.77789209, 0.01100769],</span><br><span class="line">       [0.00724789, 0.81898849],</span><br><span class="line">       [0.79222986, 0.61005305]])</span><br><span class="line">x</span><br><span class="line">array([[0.93036869, 0.36344013, 0.40994415, 0.76242106, 0.55727401,</span><br><span class="line">        0.58451496, 0.23535283, 0.46414574, 0.422967  ],</span><br><span class="line">       [0.57995231, 0.33819452, 0.66144957, 0.77789209, 0.01100769,</span><br><span class="line">        0.00724789, 0.81898849, 0.79222986, 0.61005305]])</span><br></pre></td></tr></table></figure>

<h2 id="4-2-pandas数据处理"><a href="#4-2-pandas数据处理" class="headerlink" title="4.2 pandas数据处理"></a>4.2 pandas数据处理</h2><p>pandas 是python的一个数据分析包,是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。pandas提供了大量能使我们快速便捷地处理数据的函数和方法。数据结构如下：</p>
<p>Series：一维数组，与Numpy中的一维array类似。二者与Python基本的数据结构List也很相近。Series如今能保存不同种数据类型，字符串、boolean值、数字等都能保存在Series中。</p>
<p>Time- Series：以时间为索引的Series。</p>
<p>DataFrame：二维的表格型数据结构。很多功能与R中的data.frame类似。可以将DataFrame理解为Series的容器。</p>
<p>Panel ：三维的数组，可以理解为DataFrame的容器。</p>
<p>作用：<br> 该工具是为了解决数据分析任务而创建的。<br> 提供了大量能使我们快速便捷地处理数据的函数和方法。<br> 最初被用作金融数据分析工具而开发出来，为时间序列分析提供了很好的支持。</p>
<h3 id="实战数据分析-pandas"><a href="#实战数据分析-pandas" class="headerlink" title="实战数据分析-pandas"></a>实战数据分析-pandas</h3><p>整合上面知识内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">samples &#x3D; pd.read_csv(&#39;..&#x2F;data&#x2F;train.csv&#39;)</span><br><span class="line">samples</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>content_id</th>
<th>content</th>
<th>subject</th>
<th>sentiment_value</th>
<th>sentiment_word</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>vUXizsqexyZVRdFH</td>
<td>因为森林人即将换代，这套系统没必要装在一款即将换代的车型上，因为肯定会影响价格。</td>
<td>价格</td>
<td>0</td>
<td>影响</td>
</tr>
<tr>
<td>1</td>
<td>4QroPd9hNfnCHVt7</td>
<td>四驱价格貌似挺高的，高的可以看齐XC60了，看实车前脸有点违和感。不过大众的车应该不会差。</td>
<td>价格</td>
<td>-1</td>
<td>高</td>
</tr>
<tr>
<td>2</td>
<td>QmqJ2AvM5GplaRyz</td>
<td>斯柯达要说质量，似乎比大众要好一点，价格也低一些，用料完全一样。我听说过野帝，但没听说过你说…</td>
<td>价格</td>
<td>1</td>
<td>低</td>
</tr>
<tr>
<td>3</td>
<td>KMT1gFJiU4NWrVDn</td>
<td>这玩意都是给有钱任性又不懂车的土豪用的，这价格换一次我妹夫EP020可以换三锅了</td>
<td>价格</td>
<td>-1</td>
<td>有钱任性</td>
</tr>
<tr>
<td>4</td>
<td>nVIlGd5yMmc37t1o</td>
<td>17价格忒高，估计也就是14-15左右。</td>
<td>价格</td>
<td>-1</td>
<td>高</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>9942</td>
<td>VywQTI4iLuzd1DZ3</td>
<td>老铁没毛病…双击666！！！是不是这样？我这理解逻辑也挑不出毛病吧！你不矫情你试试？多大…</td>
<td>外观</td>
<td>1</td>
<td>NaN</td>
</tr>
<tr>
<td>9943</td>
<td>Ufv6VpyNaGnShzlJ</td>
<td>2.0时尚，四川这段时间温度最低-1，基本上下班用，现在均速18，表显油耗9.2</td>
<td>油耗</td>
<td>0</td>
<td>NaN</td>
</tr>
<tr>
<td>9944</td>
<td>S8tmC0gxyBjzvLuN</td>
<td>相貌不起眼，内饰太平淡，开起来才知道好</td>
<td>内饰</td>
<td>-1</td>
<td>NaN</td>
</tr>
<tr>
<td>9945</td>
<td>vpaS3ueRQi2rhAgH</td>
<td>一看就知道山寨的！用的肯定是中控的普通视频输入接口而已，这种无屏的记录仪淘宝也就一两百块的东…</td>
<td>配置</td>
<td>-1</td>
<td>NaN</td>
</tr>
<tr>
<td>9946</td>
<td>5R0ZoOdv8H2MNGgt</td>
<td>楼主还在吗，同在上海，想咨询一下家用首辆车，到底是买森林人还是力狮好？如果森林人，2.0的动…</td>
<td>动力</td>
<td>0</td>
<td>NaN</td>
</tr>
</tbody></table>
<p>9947 rows × 5 columns</p>
<h1 id="1-EDA（描述性统计分析）"><a href="#1-EDA（描述性统计分析）" class="headerlink" title="1. EDA（描述性统计分析）"></a>1. EDA（描述性统计分析）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">samples[&#39;len_content&#39;] &#x3D; samples[&#39;content&#39;].apply(lambda x:len(x))</span><br><span class="line">samples[&#39;len_content&#39;].describe()</span><br><span class="line">count    9947.000000</span><br><span class="line">mean       49.205389</span><br><span class="line">std        33.870401</span><br><span class="line">min        10.000000</span><br><span class="line">25%        24.500000</span><br><span class="line">50%        40.000000</span><br><span class="line">75%        64.000000</span><br><span class="line">max       200.000000</span><br><span class="line">Name: len_content, dtype: float64</span><br><span class="line"># 统计文本长度的分位数</span><br><span class="line">for i in range(75,100):</span><br><span class="line">    print (i, np.percentile(samples[&#39;len_content&#39;], i))</span><br><span class="line">75 64.0</span><br><span class="line">76 65.0</span><br><span class="line">77 66.0</span><br><span class="line">78 68.0</span><br><span class="line">79 69.0</span><br><span class="line">80 71.0</span><br><span class="line">81 72.0</span><br><span class="line">82 74.0</span><br><span class="line">83 76.0</span><br><span class="line">84 77.0</span><br><span class="line">85 79.0</span><br><span class="line">86 81.0</span><br><span class="line">87 84.0</span><br><span class="line">88 86.0</span><br><span class="line">89 89.0</span><br><span class="line">90 92.0</span><br><span class="line">91 97.0</span><br><span class="line">92 101.0</span><br><span class="line">93 107.0</span><br><span class="line">94 113.0</span><br><span class="line">95 120.69999999999891</span><br><span class="line">96 129.0</span><br><span class="line">97 139.0</span><br><span class="line">98 152.0</span><br><span class="line">99 172.0</span><br><span class="line"># 标签分布 - subject</span><br><span class="line">samples[&#39;subject&#39;].value_counts()</span><br><span class="line">动力     2732</span><br><span class="line">价格     1273</span><br><span class="line">油耗     1082</span><br><span class="line">操控     1036</span><br><span class="line">舒适性     931</span><br><span class="line">配置      853</span><br><span class="line">安全性     573</span><br><span class="line">内饰      536</span><br><span class="line">外观      489</span><br><span class="line">空间      442</span><br><span class="line">Name: subject, dtype: int64</span><br><span class="line"># 标签分布 - sentiment_value【情感极性】</span><br><span class="line">samples[&#39;sentiment_value&#39;].value_counts()</span><br><span class="line"> 0    6661</span><br><span class="line"> 1    1670</span><br><span class="line">-1    1616</span><br><span class="line">Name: sentiment_value, dtype: int64</span><br><span class="line"># 读取测试集数据</span><br><span class="line">test &#x3D; pd.read_csv(&#39;..&#x2F;data&#x2F;test_public.csv&#39;)</span><br><span class="line">test</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>content_id</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>XuPwKCnA2fqNh5vm</td>
<td>欧蓝德，价格便宜，森林人太贵啦！</td>
</tr>
<tr>
<td>1</td>
<td>2jNbDn85goX3IuPE</td>
<td>楼主什么时候提的车，南昌优惠多少啊</td>
</tr>
<tr>
<td>2</td>
<td>hLgEADQ8sUnvGFK9</td>
<td>吉林，2.5优惠20000，送三年九次保养，贴膜</td>
</tr>
<tr>
<td>3</td>
<td>nZmM7LQsfr03wUaz</td>
<td>便宜2万的豪华特装，实用配制提升，优惠还给力，确实划算。</td>
</tr>
<tr>
<td>4</td>
<td>pwd8MnrthDqLZafe</td>
<td>如果实在想买就等车展期间，优惠2万，我24.98万入的2.5豪</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>2359</td>
<td>IoKEnR3JdXu0gG4h</td>
<td>我觉得斯巴鲁的CVT比奥迪的CVT还要好，新XV上的CVT更猛。已经习惯了CVT持续加速感后…</td>
</tr>
<tr>
<td>2360</td>
<td>4p5xbNDUMLAwvzrY</td>
<td>全时四驱仅比一般SUV车强一点，肯定干不过Q5，XC60，连A4也干不过。水平对置仅体现在低…</td>
</tr>
<tr>
<td>2361</td>
<td>VYJEH3N0ZkGt5Xvy</td>
<td>哈哈，终于看到有人开始厌烦前置雷达的声音了，这个亲，那个声音来自哪里？</td>
</tr>
<tr>
<td>2362</td>
<td>iSp7q8d4eW9honmI</td>
<td>请教一下，变速箱油，差速器油，火花塞，分别多久更换。</td>
</tr>
<tr>
<td>2363</td>
<td>WLHp3PYJ9FvOGXE2</td>
<td>求购二手１４款ＸＴ的后刹车总成。（已网购到手了）</td>
</tr>
</tbody></table>
<p>2364 rows × 2 columns</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test[&#39;len_content&#39;] &#x3D; test[&#39;content&#39;].apply(lambda x:len(x))</span><br><span class="line">test[&#39;len_content&#39;].describe()</span><br><span class="line">count    2364.000000</span><br><span class="line">mean       45.490271</span><br><span class="line">std        30.264393</span><br><span class="line">min        10.000000</span><br><span class="line">25%        24.000000</span><br><span class="line">50%        37.000000</span><br><span class="line">75%        58.000000</span><br><span class="line">max       200.000000</span><br><span class="line">Name: len_content, dtype: float64</span><br></pre></td></tr></table></figure>

<h2 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import jieba</span><br><span class="line"></span><br><span class="line">def word_cut(text):</span><br><span class="line">    return [word for word in jieba.cut(text) if word.strip()]</span><br><span class="line"></span><br><span class="line">samples[&#39;cut-content&#39;] &#x3D; samples[&#39;content&#39;].apply(lambda x:word_cut(x))</span><br><span class="line">Building prefix dict from the default dictionary ...</span><br><span class="line">Loading model from cache C:\Users\Allan\AppData\Local\Temp\jieba.cache</span><br><span class="line">Loading model cost 0.856 seconds.</span><br><span class="line">Prefix dict has been built successfully.</span><br><span class="line">samples[&#39;len-cut-content&#39;] &#x3D; samples[&#39;cut-content&#39;].apply(lambda x:len(x))</span><br><span class="line">samples[&#39;len-cut-content&#39;].describe()</span><br><span class="line">count    9947.000000</span><br><span class="line">mean       29.813512</span><br><span class="line">std        20.952262</span><br><span class="line">min         4.000000</span><br><span class="line">25%        14.000000</span><br><span class="line">50%        24.000000</span><br><span class="line">75%        39.000000</span><br><span class="line">max       128.000000</span><br><span class="line">Name: len-cut-content, dtype: float64</span><br></pre></td></tr></table></figure>

<h2 id="对分词后的数据进行编码"><a href="#对分词后的数据进行编码" class="headerlink" title="对分词后的数据进行编码"></a>对分词后的数据进行编码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def read_json_from_file(file_name):</span><br><span class="line">    #read json file</span><br><span class="line">    print(file_name)</span><br><span class="line">    print(&#39;load .. &#39;+file_name)</span><br><span class="line">    fp &#x3D; open(file_name, &quot;rb&quot;)</span><br><span class="line">    data &#x3D; json.load(fp)</span><br><span class="line">    fp.close()</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def save_json_to_file(file_name,data):</span><br><span class="line">    #保存dict to json file</span><br><span class="line">    print(&#39;save .. &#39; + file_name)</span><br><span class="line">    fp &#x3D; open(file_name,&quot;w&quot;)</span><br><span class="line">    json.dump(data,fp)</span><br><span class="line">    fp.close()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">if not os.path.exists(&#39;.&#x2F;cache&#x2F;words2id.json&#39;):</span><br><span class="line">    vocabs &#x3D; set( [i for l in samples[&#39;cut-content&#39;] for i in l] ) | set([&quot;[unk]&quot;, &quot;[pad]&quot;])</span><br><span class="line">    words2id &#x3D; &#123; w: idx for idx, w in enumerate( vocabs ) &#125;</span><br><span class="line">    save_json_to_file(&#39;.&#x2F;cache&#x2F;words2id.json&#39;,words2id)</span><br><span class="line">else:</span><br><span class="line">    words2id &#x3D; read_json_from_file(&#39;.&#x2F;cache&#x2F;words2id.json&#39;)</span><br><span class="line">    </span><br><span class="line">.&#x2F;cache&#x2F;words2id.json</span><br><span class="line">load .. .&#x2F;cache&#x2F;words2id.json</span><br><span class="line">def read_json_from_file(file_name):</span><br><span class="line">    #read json file</span><br><span class="line">    print(file_name)</span><br><span class="line">    print(&#39;load .. &#39;+file_name)</span><br><span class="line">    fp &#x3D; open(file_name, &quot;rb&quot;)</span><br><span class="line">    data &#x3D; json.load(fp)</span><br><span class="line">    fp.close()</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def save_json_to_file(file_name,data):</span><br><span class="line">    #保存dict to json file</span><br><span class="line">    print(&#39;save .. &#39; + file_name)</span><br><span class="line">    fp &#x3D; open(file_name,&quot;w&quot;)</span><br><span class="line">    json.dump(data,fp)</span><br><span class="line">    fp.close()</span><br><span class="line"></span><br><span class="line">unkid &#x3D; words2id.get(&quot;[unk]&quot;)</span><br><span class="line">samples[&#39;contentId&#39;] &#x3D; samples[&#39;cut-content&#39;].apply(lambda x:[words2id.get(i,unkid) for i in x])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">samples &#x3D; samples[[&#39;contentId&#39;, &#39;sentiment_value&#39;]]</span><br><span class="line"></span><br><span class="line">train &#x3D; &#123;&#125;</span><br><span class="line">for offset,s in enumerate( samples.iterrows() ):</span><br><span class="line">    s &#x3D; s[1]</span><br><span class="line">    train[str(offset)] &#x3D; (s[&#39;contentId&#39;], s[&#39;sentiment_value&#39;])</span><br><span class="line"></span><br><span class="line">save_json_to_file(&#39;cache&#x2F;train.json&#39;,train)</span><br><span class="line"></span><br><span class="line">save .. cache&#x2F;train.json</span><br></pre></td></tr></table></figure>

<h2 id="4-3-其他包"><a href="#4-3-其他包" class="headerlink" title="4.3 其他包"></a>4.3 其他包</h2><h3 id="matplotlib数据可视化"><a href="#matplotlib数据可视化" class="headerlink" title="matplotlib数据可视化"></a>matplotlib数据可视化</h3><p> Matplotlib是强大的数据可视化工具和作图库，是主要用于绘制数据图表的Python库，提供了绘制各类可视化图形的命令字库、简单的接口，可以方便用户轻松掌握图形的格式，绘制各类可视化图形。使用Matplotlib，可以定制所做图表的任一方面。他支持所有操作系统下不同的GUI后端，并且可以将图形输出为常见的矢量图和图形测试，如PDF SVG JPG PNG BMP GIF.通过数据绘图，我们可以将枯燥的数字转化成人们容易接收的图表。  Matplotlib有一套允许定制各种属性的默认设置，可以控制Matplotlib中的每一个默认属性：图像大小、每英寸点数、线宽、色彩和样式、子图、坐标轴、网个属性、文字和文字属性。<br> 作用：是基于Numpy的一套Python包，这个包提供了吩咐的数据绘图工具，主要用于绘制一些统计图形。Matplotlib是Python的一个可视化模块，他能方便的只做线条图、饼图、柱状图以及其他专业图形。 </p>
<h3 id="sciPy科学计算"><a href="#sciPy科学计算" class="headerlink" title="sciPy科学计算"></a>sciPy科学计算</h3><p> SciPy是一款方便、易于使用、专为科学和工程设计的Python工具包.它包括统计,优化,整合,线性代数模块,傅里叶变换,信号和图像处理,常微分方程求解器等等.<br> SciPy是一组专门解决科学计算中各种标准问题域的包的集合，包含的功能有最优化、线性代数、积分、插值、拟合、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算等，这些对数据分析和挖掘十分有用。<br> Scipy是一款方便、易于使用、专门为科学和工程设计的Python包，它包括统计、优化、整合、线性代数模块、傅里叶变换、信号和图像处理、常微分方程求解器等。Scipy依赖于Numpy，并提供许多对用户友好的和有效的数值例程，如数值积分和优化。</p>
<h3 id="Scrapy爬虫"><a href="#Scrapy爬虫" class="headerlink" title="Scrapy爬虫"></a>Scrapy爬虫</h3><p> Scrapy是专门为爬虫而生的工具，具有URL读取、HTML解析、存储数据等功能，可以使用Twisted异步网络库来处理网络通讯，架构清晰，且包含了各种中间件接口，可以灵活的完成各种需求。</p>
<h3 id="scikit-learn机器学习"><a href="#scikit-learn机器学习" class="headerlink" title="scikit-learn机器学习"></a>scikit-learn机器学习</h3><p> Scikit-Learn是Python常用的机器学习工具包，提供了完善的机器学习工具箱，支持数据预处理、分类、回归、聚类、预测和模型分析等强大机器学习库，其依赖于Numpy、Scipy和Matplotlib等。<br> Scikit-Learn是基于Python机器学习的模块，基于BSD开源许可证。<br> Scikit-Learn的安装需要Numpy Scopy Matplotlib等模块，Scikit-Learn的主要功能分为六个部分，分类、回归、聚类、数据降维、模型选择、数据预处理。<br> Scikit-Learn自带一些经典的数据集，比如用于分类的iris和digits数据集，还有用于回归分析的boston house  prices数据集。该数据集是一种字典结构，数据存储在.data成员中，输出标签存储在.target成员中。Scikit-Learn建立在Scipy之上，提供了一套常用的机器学习算法，通过一个统一的接口来使用，Scikit-Learn有助于在数据集上实现流行的算法。<br> Scikit-Learn还有一些库，比如：用于自然语言处理的Nltk、用于网站数据抓取的Scrappy、用于网络挖掘的Pattern、用于深度学习的Theano等。</p>
<h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><p> Keras/tensorflow/pytorch</p>
<h3 id="statsmodels统计建模计量经济"><a href="#statsmodels统计建模计量经济" class="headerlink" title="statsmodels统计建模计量经济"></a>statsmodels统计建模计量经济</h3><p> Statsmodels是Python的统计建模和计量经济学工具包，包括一些描述统计、统计模型估计和推断。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
</search>
